package _generated

// NOTE: THIS FILE WAS PRODUCED BY THE
// MSGP CODE GENERATION TOOL (github.com/tinylib/msgp)
// DO NOT EDIT

import (
	"fmt"
	"time"

	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *AliasContainer) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields0zzqb = 1

	// -- templateDecodeMsg starts here--
	var totalEncodedFields0zzqb uint32
	totalEncodedFields0zzqb, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft0zzqb := totalEncodedFields0zzqb
	missingFieldsLeft0zzqb := maxFields0zzqb - totalEncodedFields0zzqb

	var nextMiss0zzqb int32 = -1
	var found0zzqb [maxFields0zzqb]bool
	var curField0zzqb string

doneWithStruct0zzqb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft0zzqb > 0 || missingFieldsLeft0zzqb > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft0zzqb, missingFieldsLeft0zzqb, msgp.ShowFound(found0zzqb[:]), decodeMsgFieldOrder0zzqb)
		if encodedFieldsLeft0zzqb > 0 {
			encodedFieldsLeft0zzqb--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField0zzqb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss0zzqb < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss0zzqb = 0
			}
			for nextMiss0zzqb < maxFields0zzqb && found0zzqb[nextMiss0zzqb] {
				nextMiss0zzqb++
			}
			if nextMiss0zzqb == maxFields0zzqb {
				// filled all the empty fields!
				break doneWithStruct0zzqb
			}
			missingFieldsLeft0zzqb--
			curField0zzqb = decodeMsgFieldOrder0zzqb[nextMiss0zzqb]
		}
		fmt.Printf("switching on curField: '%v'\n", curField0zzqb)
		switch curField0zzqb {
		// -- templateDecodeMsg ends here --

		case "Fast":
			found0zzqb[0] = true
			err = z.Fast.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss0zzqb != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of AliasContainer
var decodeMsgFieldOrder0zzqb = []string{"Fast"}

// fieldsNotEmpty supports omitempty tags
func (z *AliasContainer) fieldsNotEmpty(isempty []bool) uint32 {
	return 1
}

// EncodeMsg implements msgp.Encodable
func (z *AliasContainer) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Fast"
	err = en.Append(0x81, 0xa4, 0x46, 0x61, 0x73, 0x74)
	if err != nil {
		return err
	}
	err = z.Fast.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AliasContainer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Fast"
	o = append(o, 0x81, 0xa4, 0x46, 0x61, 0x73, 0x74)
	o, err = z.Fast.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AliasContainer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields1zdvk = 1

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields1zdvk uint32
	if !nbs.AlwaysNil {
		totalEncodedFields1zdvk, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft1zdvk := totalEncodedFields1zdvk
	missingFieldsLeft1zdvk := maxFields1zdvk - totalEncodedFields1zdvk

	var nextMiss1zdvk int32 = -1
	var found1zdvk [maxFields1zdvk]bool
	var curField1zdvk string

doneWithStruct1zdvk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft1zdvk > 0 || missingFieldsLeft1zdvk > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft1zdvk, missingFieldsLeft1zdvk, msgp.ShowFound(found1zdvk[:]), unmarshalMsgFieldOrder1zdvk)
		if encodedFieldsLeft1zdvk > 0 {
			encodedFieldsLeft1zdvk--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField1zdvk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss1zdvk < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss1zdvk = 0
			}
			for nextMiss1zdvk < maxFields1zdvk && found1zdvk[nextMiss1zdvk] {
				nextMiss1zdvk++
			}
			if nextMiss1zdvk == maxFields1zdvk {
				// filled all the empty fields!
				break doneWithStruct1zdvk
			}
			missingFieldsLeft1zdvk--
			curField1zdvk = unmarshalMsgFieldOrder1zdvk[nextMiss1zdvk]
		}
		fmt.Printf("switching on curField: '%v'\n", curField1zdvk)
		switch curField1zdvk {
		// -- templateUnmarshalMsg ends here --

		case "Fast":
			found1zdvk[0] = true
			bts, err = z.Fast.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss1zdvk != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of AliasContainer
var unmarshalMsgFieldOrder1zdvk = []string{"Fast"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AliasContainer) Msgsize() (s int) {
	s = 1 + 5 + z.Fast.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Block) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	if dc.AlwaysNil {
		// nothing more here
	} else if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			return
		}
	}
	err = dc.ReadExactBytes(z[:])
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *Block) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes(z[:])
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Block) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, z[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Block) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	bts, err = nbs.ReadExactBytes(bts, z[:])
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Block) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Bunny) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields2zwob = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields2zwob uint32
	totalEncodedFields2zwob, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft2zwob := totalEncodedFields2zwob
	missingFieldsLeft2zwob := maxFields2zwob - totalEncodedFields2zwob

	var nextMiss2zwob int32 = -1
	var found2zwob [maxFields2zwob]bool
	var curField2zwob string

doneWithStruct2zwob:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft2zwob > 0 || missingFieldsLeft2zwob > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft2zwob, missingFieldsLeft2zwob, msgp.ShowFound(found2zwob[:]), decodeMsgFieldOrder2zwob)
		if encodedFieldsLeft2zwob > 0 {
			encodedFieldsLeft2zwob--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField2zwob = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss2zwob < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss2zwob = 0
			}
			for nextMiss2zwob < maxFields2zwob && found2zwob[nextMiss2zwob] {
				nextMiss2zwob++
			}
			if nextMiss2zwob == maxFields2zwob {
				// filled all the empty fields!
				break doneWithStruct2zwob
			}
			missingFieldsLeft2zwob--
			curField2zwob = decodeMsgFieldOrder2zwob[nextMiss2zwob]
		}
		fmt.Printf("switching on curField: '%v'\n", curField2zwob)
		switch curField2zwob {
		// -- templateDecodeMsg ends here --

		case "Carrots":
			found2zwob[0] = true
			var zrie uint32
			zrie, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Carrots) >= int(zrie) {
				z.Carrots = (z.Carrots)[:zrie]
			} else {
				z.Carrots = make([]int, zrie)
			}
			for zuhv := range z.Carrots {
				z.Carrots[zuhv], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "Sayings":
			found2zwob[1] = true
			var zpfz uint32
			zpfz, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Sayings == nil && zpfz > 0 {
				z.Sayings = make(map[string]string, zpfz)
			} else if len(z.Sayings) > 0 {
				for key, _ := range z.Sayings {
					delete(z.Sayings, key)
				}
			}
			for zpfz > 0 {
				zpfz--
				var zwgn string
				var znob string
				zwgn, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				znob, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Sayings[zwgn] = znob
			}
		case "BunnyId":
			found2zwob[2] = true
			z.BunnyId, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss2zwob != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Bunny
var decodeMsgFieldOrder2zwob = []string{"Carrots", "Sayings", "BunnyId"}

// fieldsNotEmpty supports omitempty tags
func (z *Bunny) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (len(z.Carrots) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Sayings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.BunnyId == 0) // number, omitempty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Bunny) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zgfj [3]bool
	fieldsInUse_zrmp := z.fieldsNotEmpty(empty_zgfj[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zrmp)
	if err != nil {
		return err
	}

	if !empty_zgfj[0] {
		// write "Carrots"
		err = en.Append(0xa7, 0x43, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Carrots)))
		if err != nil {
			panic(err)
		}
		for zuhv := range z.Carrots {
			err = en.WriteInt(z.Carrots[zuhv])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zgfj[1] {
		// write "Sayings"
		err = en.Append(0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Sayings)))
		if err != nil {
			panic(err)
		}
		for zwgn, znob := range z.Sayings {
			err = en.WriteString(zwgn)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(znob)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zgfj[2] {
		// write "BunnyId"
		err = en.Append(0xa7, 0x42, 0x75, 0x6e, 0x6e, 0x79, 0x49, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.BunnyId)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Bunny) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Carrots"
		o = append(o, 0xa7, 0x43, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Carrots)))
		for zuhv := range z.Carrots {
			o = msgp.AppendInt(o, z.Carrots[zuhv])
		}
	}

	if !empty[1] {
		// string "Sayings"
		o = append(o, 0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Sayings)))
		for zwgn, znob := range z.Sayings {
			o = msgp.AppendString(o, zwgn)
			o = msgp.AppendString(o, znob)
		}
	}

	if !empty[2] {
		// string "BunnyId"
		o = append(o, 0xa7, 0x42, 0x75, 0x6e, 0x6e, 0x79, 0x49, 0x64)
		o = msgp.AppendInt(o, z.BunnyId)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bunny) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields3zgvs = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields3zgvs uint32
	if !nbs.AlwaysNil {
		totalEncodedFields3zgvs, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft3zgvs := totalEncodedFields3zgvs
	missingFieldsLeft3zgvs := maxFields3zgvs - totalEncodedFields3zgvs

	var nextMiss3zgvs int32 = -1
	var found3zgvs [maxFields3zgvs]bool
	var curField3zgvs string

doneWithStruct3zgvs:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft3zgvs > 0 || missingFieldsLeft3zgvs > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft3zgvs, missingFieldsLeft3zgvs, msgp.ShowFound(found3zgvs[:]), unmarshalMsgFieldOrder3zgvs)
		if encodedFieldsLeft3zgvs > 0 {
			encodedFieldsLeft3zgvs--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField3zgvs = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss3zgvs < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss3zgvs = 0
			}
			for nextMiss3zgvs < maxFields3zgvs && found3zgvs[nextMiss3zgvs] {
				nextMiss3zgvs++
			}
			if nextMiss3zgvs == maxFields3zgvs {
				// filled all the empty fields!
				break doneWithStruct3zgvs
			}
			missingFieldsLeft3zgvs--
			curField3zgvs = unmarshalMsgFieldOrder3zgvs[nextMiss3zgvs]
		}
		fmt.Printf("switching on curField: '%v'\n", curField3zgvs)
		switch curField3zgvs {
		// -- templateUnmarshalMsg ends here --

		case "Carrots":
			found3zgvs[0] = true
			if nbs.AlwaysNil {
				(z.Carrots) = (z.Carrots)[:0]
			} else {

				var zjug uint32
				zjug, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Carrots) >= int(zjug) {
					z.Carrots = (z.Carrots)[:zjug]
				} else {
					z.Carrots = make([]int, zjug)
				}
				for zuhv := range z.Carrots {
					z.Carrots[zuhv], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Sayings":
			found3zgvs[1] = true
			if nbs.AlwaysNil {
				if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}

			} else {

				var zrbx uint32
				zrbx, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Sayings == nil && zrbx > 0 {
					z.Sayings = make(map[string]string, zrbx)
				} else if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}
				for zrbx > 0 {
					var zwgn string
					var znob string
					zrbx--
					zwgn, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					znob, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Sayings[zwgn] = znob
				}
			}
		case "BunnyId":
			found3zgvs[2] = true
			z.BunnyId, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss3zgvs != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Bunny
var unmarshalMsgFieldOrder3zgvs = []string{"Carrots", "Sayings", "BunnyId"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bunny) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize + (len(z.Carrots) * (msgp.IntSize)) + 8 + msgp.MapHeaderSize
	if z.Sayings != nil {
		for zwgn, znob := range z.Sayings {
			_ = znob
			s += msgp.StringPrefixSize + len(zwgn) + msgp.StringPrefixSize + len(znob)
		}
	}
	s += 8 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Custom) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields4zblq = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields4zblq uint32
	totalEncodedFields4zblq, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft4zblq := totalEncodedFields4zblq
	missingFieldsLeft4zblq := maxFields4zblq - totalEncodedFields4zblq

	var nextMiss4zblq int32 = -1
	var found4zblq [maxFields4zblq]bool
	var curField4zblq string

doneWithStruct4zblq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft4zblq > 0 || missingFieldsLeft4zblq > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft4zblq, missingFieldsLeft4zblq, msgp.ShowFound(found4zblq[:]), decodeMsgFieldOrder4zblq)
		if encodedFieldsLeft4zblq > 0 {
			encodedFieldsLeft4zblq--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField4zblq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss4zblq < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss4zblq = 0
			}
			for nextMiss4zblq < maxFields4zblq && found4zblq[nextMiss4zblq] {
				nextMiss4zblq++
			}
			if nextMiss4zblq == maxFields4zblq {
				// filled all the empty fields!
				break doneWithStruct4zblq
			}
			missingFieldsLeft4zblq--
			curField4zblq = decodeMsgFieldOrder4zblq[nextMiss4zblq]
		}
		fmt.Printf("switching on curField: '%v'\n", curField4zblq)
		switch curField4zblq {
		// -- templateDecodeMsg ends here --

		case "bts":
			found4zblq[0] = true
			{
				var zgpb []byte
				zgpb, err = dc.ReadBytes([]byte(z.Bts))
				z.Bts = CustomBytes(zgpb)
			}
			if err != nil {
				panic(err)
			}
		case "mp":
			found4zblq[1] = true
			var ziwo uint32
			ziwo, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Mp == nil && ziwo > 0 {
				z.Mp = make(map[string]*Embedded, ziwo)
			} else if len(z.Mp) > 0 {
				for key, _ := range z.Mp {
					delete(z.Mp, key)
				}
			}
			for ziwo > 0 {
				ziwo--
				var zanx string
				var znxv *Embedded
				zanx, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					if znxv != nil {
						dc.PushAlwaysNil()
						err = znxv.DecodeMsg(dc)
						if err != nil {
							return
						}
						dc.PopAlwaysNil()
					}
				} else {
					// not Nil, we have something to read

					if znxv == nil {
						znxv = new(Embedded)
					}
					err = znxv.DecodeMsg(dc)
					if err != nil {
						panic(err)
					}
				}
				z.Mp[zanx] = znxv
			}
		case "enums":
			found4zblq[2] = true
			var zqrz uint32
			zqrz, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Enums) >= int(zqrz) {
				z.Enums = (z.Enums)[:zqrz]
			} else {
				z.Enums = make([]MyEnum, zqrz)
			}
			for zkwm := range z.Enums {
				{
					var zdnn string
					zdnn, err = dc.ReadString()
					z.Enums[zkwm] = myenumStr(zdnn)
				}
				if err != nil {
					panic(err)
				}
			}
		case "Some":
			found4zblq[3] = true
			err = z.Some.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss4zblq != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Custom
var decodeMsgFieldOrder4zblq = []string{"bts", "mp", "enums", "Some"}

// fieldsNotEmpty supports omitempty tags
func (z *Custom) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Custom) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "bts"
	err = en.Append(0x84, 0xa3, 0x62, 0x74, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteBytes([]byte(z.Bts))
	if err != nil {
		panic(err)
	}
	// write "mp"
	err = en.Append(0xa2, 0x6d, 0x70)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Mp)))
	if err != nil {
		panic(err)
	}
	for zanx, znxv := range z.Mp {
		err = en.WriteString(zanx)
		if err != nil {
			panic(err)
		}
		if znxv == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = znxv.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}
	// write "enums"
	err = en.Append(0xa5, 0x65, 0x6e, 0x75, 0x6d, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Enums)))
	if err != nil {
		panic(err)
	}
	for zkwm := range z.Enums {
		err = en.WriteString((MyEnum).String(z.Enums[zkwm]))
		if err != nil {
			panic(err)
		}
	}
	// write "Some"
	err = en.Append(0xa4, 0x53, 0x6f, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = z.Some.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Custom) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "bts"
	o = append(o, 0x84, 0xa3, 0x62, 0x74, 0x73)
	o = msgp.AppendBytes(o, []byte(z.Bts))
	// string "mp"
	o = append(o, 0xa2, 0x6d, 0x70)
	o = msgp.AppendMapHeader(o, uint32(len(z.Mp)))
	for zanx, znxv := range z.Mp {
		o = msgp.AppendString(o, zanx)
		if znxv == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = znxv.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}
	// string "enums"
	o = append(o, 0xa5, 0x65, 0x6e, 0x75, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Enums)))
	for zkwm := range z.Enums {
		o = msgp.AppendString(o, (MyEnum).String(z.Enums[zkwm]))
	}
	// string "Some"
	o = append(o, 0xa4, 0x53, 0x6f, 0x6d, 0x65)
	o, err = z.Some.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Custom) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields5zcde = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields5zcde uint32
	if !nbs.AlwaysNil {
		totalEncodedFields5zcde, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft5zcde := totalEncodedFields5zcde
	missingFieldsLeft5zcde := maxFields5zcde - totalEncodedFields5zcde

	var nextMiss5zcde int32 = -1
	var found5zcde [maxFields5zcde]bool
	var curField5zcde string

doneWithStruct5zcde:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft5zcde > 0 || missingFieldsLeft5zcde > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft5zcde, missingFieldsLeft5zcde, msgp.ShowFound(found5zcde[:]), unmarshalMsgFieldOrder5zcde)
		if encodedFieldsLeft5zcde > 0 {
			encodedFieldsLeft5zcde--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField5zcde = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss5zcde < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss5zcde = 0
			}
			for nextMiss5zcde < maxFields5zcde && found5zcde[nextMiss5zcde] {
				nextMiss5zcde++
			}
			if nextMiss5zcde == maxFields5zcde {
				// filled all the empty fields!
				break doneWithStruct5zcde
			}
			missingFieldsLeft5zcde--
			curField5zcde = unmarshalMsgFieldOrder5zcde[nextMiss5zcde]
		}
		fmt.Printf("switching on curField: '%v'\n", curField5zcde)
		switch curField5zcde {
		// -- templateUnmarshalMsg ends here --

		case "bts":
			found5zcde[0] = true
			{
				var zycg []byte
				if nbs.AlwaysNil || msgp.IsNil(bts) {
					if !nbs.AlwaysNil {
						bts = bts[1:]
					}
					zycg = zycg[:0]
				} else {
					zycg, bts, err = nbs.ReadBytesBytes(bts, []byte(z.Bts))

					if err != nil {
						panic(err)
					}
				}
				if err != nil {
					panic(err)
				}
				z.Bts = CustomBytes(zycg)
			}
		case "mp":
			found5zcde[1] = true
			if nbs.AlwaysNil {
				if len(z.Mp) > 0 {
					for key, _ := range z.Mp {
						delete(z.Mp, key)
					}
				}

			} else {

				var zwrv uint32
				zwrv, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Mp == nil && zwrv > 0 {
					z.Mp = make(map[string]*Embedded, zwrv)
				} else if len(z.Mp) > 0 {
					for key, _ := range z.Mp {
						delete(z.Mp, key)
					}
				}
				for zwrv > 0 {
					var zanx string
					var znxv *Embedded
					zwrv--
					zanx, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					if nbs.AlwaysNil {
						if znxv != nil {
							znxv.UnmarshalMsg(msgp.OnlyNilSlice)
						}
					} else {
						// not nbs.AlwaysNil
						if msgp.IsNil(bts) {
							bts = bts[1:]
							if nil != znxv {
								znxv.UnmarshalMsg(msgp.OnlyNilSlice)
							}
						} else {
							// not nbs.AlwaysNil and not IsNil(bts): have something to read

							if znxv == nil {
								znxv = new(Embedded)
							}
							bts, err = znxv.UnmarshalMsg(bts)
							if err != nil {
								panic(err)
							}
							if err != nil {
								panic(err)
							}
						}
					}
					z.Mp[zanx] = znxv
				}
			}
		case "enums":
			found5zcde[2] = true
			if nbs.AlwaysNil {
				(z.Enums) = (z.Enums)[:0]
			} else {

				var zuwq uint32
				zuwq, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Enums) >= int(zuwq) {
					z.Enums = (z.Enums)[:zuwq]
				} else {
					z.Enums = make([]MyEnum, zuwq)
				}
				for zkwm := range z.Enums {
					{
						var zlgn string
						zlgn, bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
						z.Enums[zkwm] = myenumStr(zlgn)
					}
				}
			}
		case "Some":
			found5zcde[3] = true
			bts, err = z.Some.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss5zcde != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Custom
var unmarshalMsgFieldOrder5zcde = []string{"bts", "mp", "enums", "Some"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Custom) Msgsize() (s int) {
	s = 1 + 4 + msgp.BytesPrefixSize + len([]byte(z.Bts)) + 3 + msgp.MapHeaderSize
	if z.Mp != nil {
		for zanx, znxv := range z.Mp {
			_ = znxv
			s += msgp.StringPrefixSize + len(zanx)
			if znxv == nil {
				s += msgp.NilSize
			} else {
				s += znxv.Msgsize()
			}
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for zkwm := range z.Enums {
		s += msgp.StringPrefixSize + len((MyEnum).String(z.Enums[zkwm]))
	}
	s += 5 + z.Some.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *CustomBytes) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zjvs []byte
		zjvs, err = dc.ReadBytes([]byte((*z)))
		(*z) = CustomBytes(zjvs)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z CustomBytes) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes([]byte(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CustomBytes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CustomBytes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zlpz []byte
		if nbs.AlwaysNil || msgp.IsNil(bts) {
			if !nbs.AlwaysNil {
				bts = bts[1:]
			}
			zlpz = zlpz[:0]
		} else {
			zlpz, bts, err = nbs.ReadBytesBytes(bts, []byte((*z)))

			if err != nil {
				panic(err)
			}
		}
		if err != nil {
			panic(err)
		}
		(*z) = CustomBytes(zlpz)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CustomBytes) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *CustomInt) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zbtw int
		zbtw, err = dc.ReadInt()
		(*z) = CustomInt(zbtw)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z CustomInt) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CustomInt) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CustomInt) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zafp int
		zafp, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = CustomInt(zafp)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CustomInt) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Embedded) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields6zegm = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields6zegm uint32
	totalEncodedFields6zegm, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft6zegm := totalEncodedFields6zegm
	missingFieldsLeft6zegm := maxFields6zegm - totalEncodedFields6zegm

	var nextMiss6zegm int32 = -1
	var found6zegm [maxFields6zegm]bool
	var curField6zegm string

doneWithStruct6zegm:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft6zegm > 0 || missingFieldsLeft6zegm > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft6zegm, missingFieldsLeft6zegm, msgp.ShowFound(found6zegm[:]), decodeMsgFieldOrder6zegm)
		if encodedFieldsLeft6zegm > 0 {
			encodedFieldsLeft6zegm--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField6zegm = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss6zegm < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss6zegm = 0
			}
			for nextMiss6zegm < maxFields6zegm && found6zegm[nextMiss6zegm] {
				nextMiss6zegm++
			}
			if nextMiss6zegm == maxFields6zegm {
				// filled all the empty fields!
				break doneWithStruct6zegm
			}
			missingFieldsLeft6zegm--
			curField6zegm = decodeMsgFieldOrder6zegm[nextMiss6zegm]
		}
		fmt.Printf("switching on curField: '%v'\n", curField6zegm)
		switch curField6zegm {
		// -- templateDecodeMsg ends here --

		case "Embedded":
			found6zegm[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Embedded != nil {
					dc.PushAlwaysNil()
					err = z.Embedded.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Embedded == nil {
					z.Embedded = new(Embedded)
				}
				err = z.Embedded.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "Children":
			found6zegm[1] = true
			var zvrv uint32
			zvrv, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Children) >= int(zvrv) {
				z.Children = (z.Children)[:zvrv]
			} else {
				z.Children = make([]Embedded, zvrv)
			}
			for zcjz := range z.Children {
				err = z.Children[zcjz].DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "PtrChildren":
			found6zegm[2] = true
			var zhjv uint32
			zhjv, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.PtrChildren) >= int(zhjv) {
				z.PtrChildren = (z.PtrChildren)[:zhjv]
			} else {
				z.PtrChildren = make([]*Embedded, zhjv)
			}
			for ztvu := range z.PtrChildren {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					if z.PtrChildren[ztvu] != nil {
						dc.PushAlwaysNil()
						err = z.PtrChildren[ztvu].DecodeMsg(dc)
						if err != nil {
							return
						}
						dc.PopAlwaysNil()
					}
				} else {
					// not Nil, we have something to read

					if z.PtrChildren[ztvu] == nil {
						z.PtrChildren[ztvu] = new(Embedded)
					}
					err = z.PtrChildren[ztvu].DecodeMsg(dc)
					if err != nil {
						panic(err)
					}
				}
			}
		case "Other":
			found6zegm[3] = true
			z.Other, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss6zegm != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Embedded
var decodeMsgFieldOrder6zegm = []string{"Embedded", "Children", "PtrChildren", "Other"}

// fieldsNotEmpty supports omitempty tags
func (z *Embedded) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Embedded) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Embedded"
	err = en.Append(0x84, 0xa8, 0x45, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64)
	if err != nil {
		return err
	}
	if z.Embedded == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Embedded.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "Children"
	err = en.Append(0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Children)))
	if err != nil {
		panic(err)
	}
	for zcjz := range z.Children {
		err = z.Children[zcjz].EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "PtrChildren"
	err = en.Append(0xab, 0x50, 0x74, 0x72, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.PtrChildren)))
	if err != nil {
		panic(err)
	}
	for ztvu := range z.PtrChildren {
		if z.PtrChildren[ztvu] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.PtrChildren[ztvu].EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}
	// write "Other"
	err = en.Append(0xa5, 0x4f, 0x74, 0x68, 0x65, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Other)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Embedded) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Embedded"
	o = append(o, 0x84, 0xa8, 0x45, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64)
	if z.Embedded == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Embedded.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "Children"
	o = append(o, 0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Children)))
	for zcjz := range z.Children {
		o, err = z.Children[zcjz].MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "PtrChildren"
	o = append(o, 0xab, 0x50, 0x74, 0x72, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PtrChildren)))
	for ztvu := range z.PtrChildren {
		if z.PtrChildren[ztvu] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.PtrChildren[ztvu].MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}
	// string "Other"
	o = append(o, 0xa5, 0x4f, 0x74, 0x68, 0x65, 0x72)
	o = msgp.AppendString(o, z.Other)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Embedded) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields7zxtm = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields7zxtm uint32
	if !nbs.AlwaysNil {
		totalEncodedFields7zxtm, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft7zxtm := totalEncodedFields7zxtm
	missingFieldsLeft7zxtm := maxFields7zxtm - totalEncodedFields7zxtm

	var nextMiss7zxtm int32 = -1
	var found7zxtm [maxFields7zxtm]bool
	var curField7zxtm string

doneWithStruct7zxtm:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft7zxtm > 0 || missingFieldsLeft7zxtm > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft7zxtm, missingFieldsLeft7zxtm, msgp.ShowFound(found7zxtm[:]), unmarshalMsgFieldOrder7zxtm)
		if encodedFieldsLeft7zxtm > 0 {
			encodedFieldsLeft7zxtm--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField7zxtm = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss7zxtm < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss7zxtm = 0
			}
			for nextMiss7zxtm < maxFields7zxtm && found7zxtm[nextMiss7zxtm] {
				nextMiss7zxtm++
			}
			if nextMiss7zxtm == maxFields7zxtm {
				// filled all the empty fields!
				break doneWithStruct7zxtm
			}
			missingFieldsLeft7zxtm--
			curField7zxtm = unmarshalMsgFieldOrder7zxtm[nextMiss7zxtm]
		}
		fmt.Printf("switching on curField: '%v'\n", curField7zxtm)
		switch curField7zxtm {
		// -- templateUnmarshalMsg ends here --

		case "Embedded":
			found7zxtm[0] = true
			if nbs.AlwaysNil {
				if z.Embedded != nil {
					z.Embedded.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Embedded {
						z.Embedded.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Embedded == nil {
						z.Embedded = new(Embedded)
					}
					bts, err = z.Embedded.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "Children":
			found7zxtm[1] = true
			if nbs.AlwaysNil {
				(z.Children) = (z.Children)[:0]
			} else {

				var zjan uint32
				zjan, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Children) >= int(zjan) {
					z.Children = (z.Children)[:zjan]
				} else {
					z.Children = make([]Embedded, zjan)
				}
				for zcjz := range z.Children {
					bts, err = z.Children[zcjz].UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "PtrChildren":
			found7zxtm[2] = true
			if nbs.AlwaysNil {
				(z.PtrChildren) = (z.PtrChildren)[:0]
			} else {

				var zvsl uint32
				zvsl, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.PtrChildren) >= int(zvsl) {
					z.PtrChildren = (z.PtrChildren)[:zvsl]
				} else {
					z.PtrChildren = make([]*Embedded, zvsl)
				}
				for ztvu := range z.PtrChildren {
					if nbs.AlwaysNil {
						if z.PtrChildren[ztvu] != nil {
							z.PtrChildren[ztvu].UnmarshalMsg(msgp.OnlyNilSlice)
						}
					} else {
						// not nbs.AlwaysNil
						if msgp.IsNil(bts) {
							bts = bts[1:]
							if nil != z.PtrChildren[ztvu] {
								z.PtrChildren[ztvu].UnmarshalMsg(msgp.OnlyNilSlice)
							}
						} else {
							// not nbs.AlwaysNil and not IsNil(bts): have something to read

							if z.PtrChildren[ztvu] == nil {
								z.PtrChildren[ztvu] = new(Embedded)
							}
							bts, err = z.PtrChildren[ztvu].UnmarshalMsg(bts)
							if err != nil {
								panic(err)
							}
							if err != nil {
								panic(err)
							}
						}
					}
				}
			}
		case "Other":
			found7zxtm[3] = true
			z.Other, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss7zxtm != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Embedded
var unmarshalMsgFieldOrder7zxtm = []string{"Embedded", "Children", "PtrChildren", "Other"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Embedded) Msgsize() (s int) {
	s = 1 + 9
	if z.Embedded == nil {
		s += msgp.NilSize
	} else {
		s += z.Embedded.Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for zcjz := range z.Children {
		s += z.Children[zcjz].Msgsize()
	}
	s += 12 + msgp.ArrayHeaderSize
	for ztvu := range z.PtrChildren {
		if z.PtrChildren[ztvu] == nil {
			s += msgp.NilSize
		} else {
			s += z.PtrChildren[ztvu].Msgsize()
		}
	}
	s += 6 + msgp.StringPrefixSize + len(z.Other)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *FastAlias) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields8zrpw = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields8zrpw uint32
	totalEncodedFields8zrpw, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft8zrpw := totalEncodedFields8zrpw
	missingFieldsLeft8zrpw := maxFields8zrpw - totalEncodedFields8zrpw

	var nextMiss8zrpw int32 = -1
	var found8zrpw [maxFields8zrpw]bool
	var curField8zrpw string

doneWithStruct8zrpw:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft8zrpw > 0 || missingFieldsLeft8zrpw > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft8zrpw, missingFieldsLeft8zrpw, msgp.ShowFound(found8zrpw[:]), decodeMsgFieldOrder8zrpw)
		if encodedFieldsLeft8zrpw > 0 {
			encodedFieldsLeft8zrpw--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField8zrpw = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss8zrpw < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss8zrpw = 0
			}
			for nextMiss8zrpw < maxFields8zrpw && found8zrpw[nextMiss8zrpw] {
				nextMiss8zrpw++
			}
			if nextMiss8zrpw == maxFields8zrpw {
				// filled all the empty fields!
				break doneWithStruct8zrpw
			}
			missingFieldsLeft8zrpw--
			curField8zrpw = decodeMsgFieldOrder8zrpw[nextMiss8zrpw]
		}
		fmt.Printf("switching on curField: '%v'\n", curField8zrpw)
		switch curField8zrpw {
		// -- templateDecodeMsg ends here --

		case "Lat":
			found8zrpw[0] = true
			z.Lat, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Long":
			found8zrpw[1] = true
			z.Long, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Alt":
			found8zrpw[2] = true
			z.Alt, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Data":
			found8zrpw[3] = true
			z.Data, err = dc.ReadBytes(z.Data)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss8zrpw != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of FastAlias
var decodeMsgFieldOrder8zrpw = []string{"Lat", "Long", "Alt", "Data"}

// fieldsNotEmpty supports omitempty tags
func (z *FastAlias) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *FastAlias) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Lat"
	err = en.Append(0x84, 0xa3, 0x4c, 0x61, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Lat)
	if err != nil {
		panic(err)
	}
	// write "Long"
	err = en.Append(0xa4, 0x4c, 0x6f, 0x6e, 0x67)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Long)
	if err != nil {
		panic(err)
	}
	// write "Alt"
	err = en.Append(0xa3, 0x41, 0x6c, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Alt)
	if err != nil {
		panic(err)
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FastAlias) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Lat"
	o = append(o, 0x84, 0xa3, 0x4c, 0x61, 0x74)
	o = msgp.AppendFloat64(o, z.Lat)
	// string "Long"
	o = append(o, 0xa4, 0x4c, 0x6f, 0x6e, 0x67)
	o = msgp.AppendFloat64(o, z.Long)
	// string "Alt"
	o = append(o, 0xa3, 0x41, 0x6c, 0x74)
	o = msgp.AppendFloat64(o, z.Alt)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FastAlias) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields9zykh = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields9zykh uint32
	if !nbs.AlwaysNil {
		totalEncodedFields9zykh, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft9zykh := totalEncodedFields9zykh
	missingFieldsLeft9zykh := maxFields9zykh - totalEncodedFields9zykh

	var nextMiss9zykh int32 = -1
	var found9zykh [maxFields9zykh]bool
	var curField9zykh string

doneWithStruct9zykh:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft9zykh > 0 || missingFieldsLeft9zykh > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft9zykh, missingFieldsLeft9zykh, msgp.ShowFound(found9zykh[:]), unmarshalMsgFieldOrder9zykh)
		if encodedFieldsLeft9zykh > 0 {
			encodedFieldsLeft9zykh--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField9zykh = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss9zykh < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss9zykh = 0
			}
			for nextMiss9zykh < maxFields9zykh && found9zykh[nextMiss9zykh] {
				nextMiss9zykh++
			}
			if nextMiss9zykh == maxFields9zykh {
				// filled all the empty fields!
				break doneWithStruct9zykh
			}
			missingFieldsLeft9zykh--
			curField9zykh = unmarshalMsgFieldOrder9zykh[nextMiss9zykh]
		}
		fmt.Printf("switching on curField: '%v'\n", curField9zykh)
		switch curField9zykh {
		// -- templateUnmarshalMsg ends here --

		case "Lat":
			found9zykh[0] = true
			z.Lat, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Long":
			found9zykh[1] = true
			z.Long, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Alt":
			found9zykh[2] = true
			z.Alt, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Data":
			found9zykh[3] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Data = z.Data[:0]
			} else {
				z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

				if err != nil {
					panic(err)
				}
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss9zykh != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of FastAlias
var unmarshalMsgFieldOrder9zykh = []string{"Lat", "Long", "Alt", "Data"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FastAlias) Msgsize() (s int) {
	s = 1 + 4 + msgp.Float64Size + 5 + msgp.Float64Size + 4 + msgp.Float64Size + 5 + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *FileHandle) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields10zgar = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields10zgar uint32
	totalEncodedFields10zgar, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft10zgar := totalEncodedFields10zgar
	missingFieldsLeft10zgar := maxFields10zgar - totalEncodedFields10zgar

	var nextMiss10zgar int32 = -1
	var found10zgar [maxFields10zgar]bool
	var curField10zgar string

doneWithStruct10zgar:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft10zgar > 0 || missingFieldsLeft10zgar > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft10zgar, missingFieldsLeft10zgar, msgp.ShowFound(found10zgar[:]), decodeMsgFieldOrder10zgar)
		if encodedFieldsLeft10zgar > 0 {
			encodedFieldsLeft10zgar--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField10zgar = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss10zgar < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss10zgar = 0
			}
			for nextMiss10zgar < maxFields10zgar && found10zgar[nextMiss10zgar] {
				nextMiss10zgar++
			}
			if nextMiss10zgar == maxFields10zgar {
				// filled all the empty fields!
				break doneWithStruct10zgar
			}
			missingFieldsLeft10zgar--
			curField10zgar = decodeMsgFieldOrder10zgar[nextMiss10zgar]
		}
		fmt.Printf("switching on curField: '%v'\n", curField10zgar)
		switch curField10zgar {
		// -- templateDecodeMsg ends here --

		case "files":
			found10zgar[0] = true
			var zhxo uint32
			zhxo, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Relevent) >= int(zhxo) {
				z.Relevent = (z.Relevent)[:zhxo]
			} else {
				z.Relevent = make(Files, zhxo)
			}
			for zudz := range z.Relevent {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

				} else {

					{
						var zfid string
						zfid, err = dc.ReadString()
						z.Relevent[zudz] = filefromstr(zfid)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "name":
			found10zgar[1] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss10zgar != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of FileHandle
var decodeMsgFieldOrder10zgar = []string{"files", "name"}

// fieldsNotEmpty supports omitempty tags
func (z *FileHandle) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *FileHandle) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "files"
	err = en.Append(0x82, 0xa5, 0x66, 0x69, 0x6c, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Relevent)))
	if err != nil {
		panic(err)
	}
	for zudz := range z.Relevent {
		if z.Relevent[zudz] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(filetostr(z.Relevent[zudz]))
			if err != nil {
				panic(err)
			}
		}
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Name)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileHandle) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "files"
	o = append(o, 0x82, 0xa5, 0x66, 0x69, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Relevent)))
	for zudz := range z.Relevent {
		if z.Relevent[zudz] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, filetostr(z.Relevent[zudz]))
		}
	}
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileHandle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields11zmcb = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields11zmcb uint32
	if !nbs.AlwaysNil {
		totalEncodedFields11zmcb, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft11zmcb := totalEncodedFields11zmcb
	missingFieldsLeft11zmcb := maxFields11zmcb - totalEncodedFields11zmcb

	var nextMiss11zmcb int32 = -1
	var found11zmcb [maxFields11zmcb]bool
	var curField11zmcb string

doneWithStruct11zmcb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft11zmcb > 0 || missingFieldsLeft11zmcb > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft11zmcb, missingFieldsLeft11zmcb, msgp.ShowFound(found11zmcb[:]), unmarshalMsgFieldOrder11zmcb)
		if encodedFieldsLeft11zmcb > 0 {
			encodedFieldsLeft11zmcb--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField11zmcb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss11zmcb < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss11zmcb = 0
			}
			for nextMiss11zmcb < maxFields11zmcb && found11zmcb[nextMiss11zmcb] {
				nextMiss11zmcb++
			}
			if nextMiss11zmcb == maxFields11zmcb {
				// filled all the empty fields!
				break doneWithStruct11zmcb
			}
			missingFieldsLeft11zmcb--
			curField11zmcb = unmarshalMsgFieldOrder11zmcb[nextMiss11zmcb]
		}
		fmt.Printf("switching on curField: '%v'\n", curField11zmcb)
		switch curField11zmcb {
		// -- templateUnmarshalMsg ends here --

		case "files":
			found11zmcb[0] = true
			if nbs.AlwaysNil {
				(z.Relevent) = (z.Relevent)[:0]
			} else {

				var zuga uint32
				zuga, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Relevent) >= int(zuga) {
					z.Relevent = (z.Relevent)[:zuga]
				} else {
					z.Relevent = make(Files, zuga)
				}
				for zudz := range z.Relevent {
					// default gPtr logic.
					if nbs.PeekNil(bts) && z.Relevent[zudz] == nil {
						// nothing more to do
					} else {
						// wire has bytes

						{
							var zrlk string
							zrlk, bts, err = nbs.ReadStringBytes(bts)

							if err != nil {
								panic(err)
							}
							z.Relevent[zudz] = filefromstr(zrlk)
						}
					}
				}
			}
		case "name":
			found11zmcb[1] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss11zmcb != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of FileHandle
var unmarshalMsgFieldOrder11zmcb = []string{"files", "name"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileHandle) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for zudz := range z.Relevent {
		if z.Relevent[zudz] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(filetostr(z.Relevent[zudz]))
		}
	}
	s += 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Files) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zpza uint32
	zpza, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap((*z)) >= int(zpza) {
		(*z) = (*z)[:zpza]
	} else {
		(*z) = make(Files, zpza)
	}
	for zlla := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				return
			}

		} else {

			{
				var zapj string
				zapj, err = dc.ReadString()
				(*z)[zlla] = filefromstr(zapj)
			}
			if err != nil {
				panic(err)
			}
		}
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z Files) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		panic(err)
	}
	for zxem := range z {
		if z[zxem] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(filetostr(z[zxem]))
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Files) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zxem := range z {
		if z[zxem] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, filetostr(z[zxem]))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Files) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zleq uint32
		zleq, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap((*z)) >= int(zleq) {
			(*z) = (*z)[:zleq]
		} else {
			(*z) = make(Files, zleq)
		}
		for zwpx := range *z {
			// default gPtr logic.
			if nbs.PeekNil(bts) && (*z)[zwpx] == nil {
				// nothing more to do
			} else {
				// wire has bytes

				{
					var znqu string
					znqu, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					(*z)[zwpx] = filefromstr(znqu)
				}
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Files) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zugz := range z {
		if z[zugz] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(filetostr(z[zugz]))
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Fixed) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields12zzgw = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields12zzgw uint32
	totalEncodedFields12zzgw, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft12zzgw := totalEncodedFields12zzgw
	missingFieldsLeft12zzgw := maxFields12zzgw - totalEncodedFields12zzgw

	var nextMiss12zzgw int32 = -1
	var found12zzgw [maxFields12zzgw]bool
	var curField12zzgw string

doneWithStruct12zzgw:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft12zzgw > 0 || missingFieldsLeft12zzgw > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft12zzgw, missingFieldsLeft12zzgw, msgp.ShowFound(found12zzgw[:]), decodeMsgFieldOrder12zzgw)
		if encodedFieldsLeft12zzgw > 0 {
			encodedFieldsLeft12zzgw--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField12zzgw = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss12zzgw < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss12zzgw = 0
			}
			for nextMiss12zzgw < maxFields12zzgw && found12zzgw[nextMiss12zzgw] {
				nextMiss12zzgw++
			}
			if nextMiss12zzgw == maxFields12zzgw {
				// filled all the empty fields!
				break doneWithStruct12zzgw
			}
			missingFieldsLeft12zzgw--
			curField12zzgw = decodeMsgFieldOrder12zzgw[nextMiss12zzgw]
		}
		fmt.Printf("switching on curField: '%v'\n", curField12zzgw)
		switch curField12zzgw {
		// -- templateDecodeMsg ends here --

		case "A":
			found12zzgw[0] = true
			z.A, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "B":
			found12zzgw[1] = true
			z.B, err = dc.ReadBool()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss12zzgw != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Fixed
var decodeMsgFieldOrder12zzgw = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z Fixed) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z Fixed) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "A"
	err = en.Append(0x82, 0xa1, 0x41)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.A)
	if err != nil {
		panic(err)
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return err
	}
	err = en.WriteBool(z.B)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Fixed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "A"
	o = append(o, 0x82, 0xa1, 0x41)
	o = msgp.AppendFloat64(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendBool(o, z.B)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Fixed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields13zmyr = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields13zmyr uint32
	if !nbs.AlwaysNil {
		totalEncodedFields13zmyr, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft13zmyr := totalEncodedFields13zmyr
	missingFieldsLeft13zmyr := maxFields13zmyr - totalEncodedFields13zmyr

	var nextMiss13zmyr int32 = -1
	var found13zmyr [maxFields13zmyr]bool
	var curField13zmyr string

doneWithStruct13zmyr:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft13zmyr > 0 || missingFieldsLeft13zmyr > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft13zmyr, missingFieldsLeft13zmyr, msgp.ShowFound(found13zmyr[:]), unmarshalMsgFieldOrder13zmyr)
		if encodedFieldsLeft13zmyr > 0 {
			encodedFieldsLeft13zmyr--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField13zmyr = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss13zmyr < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss13zmyr = 0
			}
			for nextMiss13zmyr < maxFields13zmyr && found13zmyr[nextMiss13zmyr] {
				nextMiss13zmyr++
			}
			if nextMiss13zmyr == maxFields13zmyr {
				// filled all the empty fields!
				break doneWithStruct13zmyr
			}
			missingFieldsLeft13zmyr--
			curField13zmyr = unmarshalMsgFieldOrder13zmyr[nextMiss13zmyr]
		}
		fmt.Printf("switching on curField: '%v'\n", curField13zmyr)
		switch curField13zmyr {
		// -- templateUnmarshalMsg ends here --

		case "A":
			found13zmyr[0] = true
			z.A, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "B":
			found13zmyr[1] = true
			z.B, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss13zmyr != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Fixed
var unmarshalMsgFieldOrder13zmyr = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Fixed) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.BoolSize
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Insane) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(3)
	if err != nil {
		panic(err)
	}
	for ziwg := range z {
		err = en.WriteMapHeader(uint32(len(z[ziwg])))
		if err != nil {
			panic(err)
		}
		for zauk, zsjh := range z[ziwg] {
			err = en.WriteString(zauk)
			if err != nil {
				panic(err)
			}
			// map header, size 2
			// write "A"
			err = en.Append(0x82, 0xa1, 0x41)
			if err != nil {
				return err
			}
			err = en.WriteInt(int(zsjh.A))
			if err != nil {
				panic(err)
			}
			// write "B"
			err = en.Append(0xa1, 0x42)
			if err != nil {
				return err
			}
			err = en.WriteInt(int(zsjh.B))
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Insane) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, 3)
	for ziwg := range z {
		o = msgp.AppendMapHeader(o, uint32(len(z[ziwg])))
		for zauk, zsjh := range z[ziwg] {
			o = msgp.AppendString(o, zauk)
			// map header, size 2
			// string "A"
			o = append(o, 0x82, 0xa1, 0x41)
			o = msgp.AppendInt(o, int(zsjh.A))
			// string "B"
			o = append(o, 0xa1, 0x42)
			o = msgp.AppendInt(o, int(zsjh.B))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Insane) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zauq uint32
	zauq, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if !nbs.IsNil(bts) && zauq != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zauq}
		return
	}
	for ziwg := range z {
		if nbs.AlwaysNil {
			if len(z[ziwg]) > 0 {
				for key, _ := range z[ziwg] {
					delete(z[ziwg], key)
				}
			}

		} else {

			var zvaa uint32
			zvaa, bts, err = nbs.ReadMapHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if z[ziwg] == nil && zvaa > 0 {
				z[ziwg] = make(map[string]struct {
					A CustomInt
					B CustomInt
				}, zvaa)
			} else if len(z[ziwg]) > 0 {
				for key, _ := range z[ziwg] {
					delete(z[ziwg], key)
				}
			}
			for zvaa > 0 {
				var zauk string
				var zsjh struct {
					A CustomInt
					B CustomInt
				}
				zvaa--
				zauk, bts, err = nbs.ReadStringBytes(bts)
				if err != nil {
					panic(err)
				}
				var field []byte
				_ = field
				const maxFields14zany = 2

				// -- templateUnmarshalMsg starts here--
				var totalEncodedFields14zany uint32
				if !nbs.AlwaysNil {
					totalEncodedFields14zany, bts, err = nbs.ReadMapHeaderBytes(bts)
					if err != nil {
						panic(err)
						return
					}
				}
				encodedFieldsLeft14zany := totalEncodedFields14zany
				missingFieldsLeft14zany := maxFields14zany - totalEncodedFields14zany

				var nextMiss14zany int32 = -1
				var found14zany [maxFields14zany]bool
				var curField14zany string

			doneWithStruct14zany:
				// First fill all the encoded fields, then
				// treat the remaining, missing fields, as Nil.
				for encodedFieldsLeft14zany > 0 || missingFieldsLeft14zany > 0 {
					fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft14zany, missingFieldsLeft14zany, msgp.ShowFound(found14zany[:]), unmarshalMsgFieldOrder14zany)
					if encodedFieldsLeft14zany > 0 {
						encodedFieldsLeft14zany--
						field, bts, err = nbs.ReadMapKeyZC(bts)
						if err != nil {
							panic(err)
							return
						}
						curField14zany = msgp.UnsafeString(field)
					} else {
						//missing fields need handling
						if nextMiss14zany < 0 {
							// set bts to contain just mnil (0xc0)
							bts = nbs.PushAlwaysNil(bts)
							nextMiss14zany = 0
						}
						for nextMiss14zany < maxFields14zany && found14zany[nextMiss14zany] {
							nextMiss14zany++
						}
						if nextMiss14zany == maxFields14zany {
							// filled all the empty fields!
							break doneWithStruct14zany
						}
						missingFieldsLeft14zany--
						curField14zany = unmarshalMsgFieldOrder14zany[nextMiss14zany]
					}
					fmt.Printf("switching on curField: '%v'\n", curField14zany)
					switch curField14zany {
					// -- templateUnmarshalMsg ends here --

					case "A":
						found14zany[0] = true
						{
							var zyiy int
							zyiy, bts, err = nbs.ReadIntBytes(bts)

							if err != nil {
								panic(err)
							}
							zsjh.A = CustomInt(zyiy)
						}
					case "B":
						found14zany[1] = true
						{
							var zpwp int
							zpwp, bts, err = nbs.ReadIntBytes(bts)

							if err != nil {
								panic(err)
							}
							zsjh.B = CustomInt(zpwp)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							panic(err)
						}
					}
				}
				if nextMiss14zany != -1 {
					bts = nbs.PopAlwaysNil()
				}

				z[ziwg][zauk] = zsjh
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of struct{;A CustomInt;;B CustomInt;;}
var unmarshalMsgFieldOrder14zany = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Insane) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for ziwg := range z {
		s += msgp.MapHeaderSize
		if z[ziwg] != nil {
			for zauk, zsjh := range z[ziwg] {
				_ = zsjh
				s += msgp.StringPrefixSize + len(zauk) + 1 + 2 + msgp.IntSize + 2 + msgp.IntSize
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntA) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zlbc int
		zlbc, err = dc.ReadInt()
		(*z) = IntA(zlbc)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntA) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntA) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntA) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zylm int
		zylm, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntA(zylm)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntA) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntB) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zpqr int
		zpqr, err = dc.ReadInt()
		(*z) = IntB(zpqr)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntB) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntB) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntB) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zdot int
		zdot, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntB(zdot)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntB) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntC) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zwba int
		zwba, err = dc.ReadInt()
		(*z) = IntC(zwba)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntC) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntC) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntC) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zihk int
		zihk, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntC(zihk)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntC) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Moose) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields15zwwn = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields15zwwn uint32
	totalEncodedFields15zwwn, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft15zwwn := totalEncodedFields15zwwn
	missingFieldsLeft15zwwn := maxFields15zwwn - totalEncodedFields15zwwn

	var nextMiss15zwwn int32 = -1
	var found15zwwn [maxFields15zwwn]bool
	var curField15zwwn string

doneWithStruct15zwwn:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft15zwwn > 0 || missingFieldsLeft15zwwn > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft15zwwn, missingFieldsLeft15zwwn, msgp.ShowFound(found15zwwn[:]), decodeMsgFieldOrder15zwwn)
		if encodedFieldsLeft15zwwn > 0 {
			encodedFieldsLeft15zwwn--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField15zwwn = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss15zwwn < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss15zwwn = 0
			}
			for nextMiss15zwwn < maxFields15zwwn && found15zwwn[nextMiss15zwwn] {
				nextMiss15zwwn++
			}
			if nextMiss15zwwn == maxFields15zwwn {
				// filled all the empty fields!
				break doneWithStruct15zwwn
			}
			missingFieldsLeft15zwwn--
			curField15zwwn = decodeMsgFieldOrder15zwwn[nextMiss15zwwn]
		}
		fmt.Printf("switching on curField: '%v'\n", curField15zwwn)
		switch curField15zwwn {
		// -- templateDecodeMsg ends here --

		case "Trees":
			found15zwwn[0] = true
			var zefb uint32
			zefb, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Trees) >= int(zefb) {
				z.Trees = (z.Trees)[:zefb]
			} else {
				z.Trees = make([]int, zefb)
			}
			for zbhb := range z.Trees {
				z.Trees[zbhb], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "Sayings":
			found15zwwn[1] = true
			var zdhj uint32
			zdhj, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Sayings == nil && zdhj > 0 {
				z.Sayings = make(map[string]string, zdhj)
			} else if len(z.Sayings) > 0 {
				for key, _ := range z.Sayings {
					delete(z.Sayings, key)
				}
			}
			for zdhj > 0 {
				zdhj--
				var zzth string
				var zwoo string
				zzth, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zwoo, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Sayings[zzth] = zwoo
			}
		case "Id":
			found15zwwn[2] = true
			z.Id, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss15zwwn != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Moose
var decodeMsgFieldOrder15zwwn = []string{"Trees", "Sayings", "Id"}

// fieldsNotEmpty supports omitempty tags
func (z *Moose) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (len(z.Trees) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Sayings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Moose) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_ziwx [3]bool
	fieldsInUse_zpsq := z.fieldsNotEmpty(empty_ziwx[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zpsq)
	if err != nil {
		return err
	}

	if !empty_ziwx[0] {
		// write "Trees"
		err = en.Append(0xa5, 0x54, 0x72, 0x65, 0x65, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Trees)))
		if err != nil {
			panic(err)
		}
		for zbhb := range z.Trees {
			err = en.WriteInt(z.Trees[zbhb])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_ziwx[1] {
		// write "Sayings"
		err = en.Append(0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Sayings)))
		if err != nil {
			panic(err)
		}
		for zzth, zwoo := range z.Sayings {
			err = en.WriteString(zzth)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zwoo)
			if err != nil {
				panic(err)
			}
		}
	}

	// write "Id"
	err = en.Append(0xa2, 0x49, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.Id)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Moose) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Trees"
		o = append(o, 0xa5, 0x54, 0x72, 0x65, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Trees)))
		for zbhb := range z.Trees {
			o = msgp.AppendInt(o, z.Trees[zbhb])
		}
	}

	if !empty[1] {
		// string "Sayings"
		o = append(o, 0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Sayings)))
		for zzth, zwoo := range z.Sayings {
			o = msgp.AppendString(o, zzth)
			o = msgp.AppendString(o, zwoo)
		}
	}

	// string "Id"
	o = append(o, 0xa2, 0x49, 0x64)
	o = msgp.AppendInt(o, z.Id)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Moose) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields16zkgq = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields16zkgq uint32
	if !nbs.AlwaysNil {
		totalEncodedFields16zkgq, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft16zkgq := totalEncodedFields16zkgq
	missingFieldsLeft16zkgq := maxFields16zkgq - totalEncodedFields16zkgq

	var nextMiss16zkgq int32 = -1
	var found16zkgq [maxFields16zkgq]bool
	var curField16zkgq string

doneWithStruct16zkgq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft16zkgq > 0 || missingFieldsLeft16zkgq > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft16zkgq, missingFieldsLeft16zkgq, msgp.ShowFound(found16zkgq[:]), unmarshalMsgFieldOrder16zkgq)
		if encodedFieldsLeft16zkgq > 0 {
			encodedFieldsLeft16zkgq--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField16zkgq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss16zkgq < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss16zkgq = 0
			}
			for nextMiss16zkgq < maxFields16zkgq && found16zkgq[nextMiss16zkgq] {
				nextMiss16zkgq++
			}
			if nextMiss16zkgq == maxFields16zkgq {
				// filled all the empty fields!
				break doneWithStruct16zkgq
			}
			missingFieldsLeft16zkgq--
			curField16zkgq = unmarshalMsgFieldOrder16zkgq[nextMiss16zkgq]
		}
		fmt.Printf("switching on curField: '%v'\n", curField16zkgq)
		switch curField16zkgq {
		// -- templateUnmarshalMsg ends here --

		case "Trees":
			found16zkgq[0] = true
			if nbs.AlwaysNil {
				(z.Trees) = (z.Trees)[:0]
			} else {

				var zkho uint32
				zkho, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Trees) >= int(zkho) {
					z.Trees = (z.Trees)[:zkho]
				} else {
					z.Trees = make([]int, zkho)
				}
				for zbhb := range z.Trees {
					z.Trees[zbhb], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Sayings":
			found16zkgq[1] = true
			if nbs.AlwaysNil {
				if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}

			} else {

				var zcml uint32
				zcml, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Sayings == nil && zcml > 0 {
					z.Sayings = make(map[string]string, zcml)
				} else if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}
				for zcml > 0 {
					var zzth string
					var zwoo string
					zcml--
					zzth, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zwoo, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Sayings[zzth] = zwoo
				}
			}
		case "Id":
			found16zkgq[2] = true
			z.Id, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss16zkgq != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Moose
var unmarshalMsgFieldOrder16zkgq = []string{"Trees", "Sayings", "Id"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Moose) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize + (len(z.Trees) * (msgp.IntSize)) + 8 + msgp.MapHeaderSize
	if z.Sayings != nil {
		for zzth, zwoo := range z.Sayings {
			_ = zwoo
			s += msgp.StringPrefixSize + len(zzth) + msgp.StringPrefixSize + len(zwoo)
		}
	}
	s += 3 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *MyEnum) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zyez string
		zyez, err = dc.ReadString()
		(*z) = myenumStr(zyez)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z MyEnum) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString((MyEnum).String(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MyEnum) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, (MyEnum).String(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MyEnum) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zpbw string
		zpbw, bts, err = nbs.ReadStringBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = myenumStr(zpbw)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MyEnum) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len((MyEnum).String(z))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Object) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zfmz uint32
	zfmz, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zfmz != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zfmz}
		return
	}
	z.ObjectNo, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	var zngi uint32
	zngi, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap(z.Slice1) >= int(zngi) {
		z.Slice1 = (z.Slice1)[:zngi]
	} else {
		z.Slice1 = make([]string, zngi)
	}
	for zdbp := range z.Slice1 {
		z.Slice1[zdbp], err = dc.ReadString()
		if err != nil {
			panic(err)
		}
	}
	var zmqh uint32
	zmqh, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap(z.Slice2) >= int(zmqh) {
		z.Slice2 = (z.Slice2)[:zmqh]
	} else {
		z.Slice2 = make([]string, zmqh)
	}
	for zzic := range z.Slice2 {
		z.Slice2[zzic], err = dc.ReadString()
		if err != nil {
			panic(err)
		}
	}
	var zgrp uint32
	zgrp, err = dc.ReadMapHeader()
	if err != nil {
		panic(err)
	}
	if z.MapMap == nil && zgrp > 0 {
		z.MapMap = make(map[string]map[string]string, zgrp)
	} else if len(z.MapMap) > 0 {
		for key, _ := range z.MapMap {
			delete(z.MapMap, key)
		}
	}
	for zgrp > 0 {
		zgrp--
		var zpxp string
		var zvvz map[string]string
		zpxp, err = dc.ReadString()
		if err != nil {
			panic(err)
		}
		var zmif uint32
		zmif, err = dc.ReadMapHeader()
		if err != nil {
			panic(err)
		}
		if zvvz == nil && zmif > 0 {
			zvvz = make(map[string]string, zmif)
		} else if len(zvvz) > 0 {
			for key, _ := range zvvz {
				delete(zvvz, key)
			}
		}
		for zmif > 0 {
			zmif--
			var zizi string
			var ziac string
			zizi, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
			ziac, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
			zvvz[zizi] = ziac
		}
		z.MapMap[zpxp] = zvvz
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *Object) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Object) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return err
	}
	err = en.WriteString(z.ObjectNo)
	if err != nil {
		panic(err)
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice1)))
	if err != nil {
		panic(err)
	}
	for zdbp := range z.Slice1 {
		err = en.WriteString(z.Slice1[zdbp])
		if err != nil {
			panic(err)
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice2)))
	if err != nil {
		panic(err)
	}
	for zzic := range z.Slice2 {
		err = en.WriteString(z.Slice2[zzic])
		if err != nil {
			panic(err)
		}
	}
	err = en.WriteMapHeader(uint32(len(z.MapMap)))
	if err != nil {
		panic(err)
	}
	for zpxp, zvvz := range z.MapMap {
		err = en.WriteString(zpxp)
		if err != nil {
			panic(err)
		}
		err = en.WriteMapHeader(uint32(len(zvvz)))
		if err != nil {
			panic(err)
		}
		for zizi, ziac := range zvvz {
			err = en.WriteString(zizi)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(ziac)
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Object) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendString(o, z.ObjectNo)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice1)))
	for zdbp := range z.Slice1 {
		o = msgp.AppendString(o, z.Slice1[zdbp])
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice2)))
	for zzic := range z.Slice2 {
		o = msgp.AppendString(o, z.Slice2[zzic])
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.MapMap)))
	for zpxp, zvvz := range z.MapMap {
		o = msgp.AppendString(o, zpxp)
		o = msgp.AppendMapHeader(o, uint32(len(zvvz)))
		for zizi, ziac := range zvvz {
			o = msgp.AppendString(o, zizi)
			o = msgp.AppendString(o, ziac)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Object) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zxcp uint32
	zxcp, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zxcp != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zxcp}
		return
	}
	z.ObjectNo, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	if nbs.AlwaysNil {
		(z.Slice1) = (z.Slice1)[:0]
	} else {

		var znri uint32
		znri, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap(z.Slice1) >= int(znri) {
			z.Slice1 = (z.Slice1)[:znri]
		} else {
			z.Slice1 = make([]string, znri)
		}
		for zdbp := range z.Slice1 {
			z.Slice1[zdbp], bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		}
	}
	if nbs.AlwaysNil {
		(z.Slice2) = (z.Slice2)[:0]
	} else {

		var zbgt uint32
		zbgt, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap(z.Slice2) >= int(zbgt) {
			z.Slice2 = (z.Slice2)[:zbgt]
		} else {
			z.Slice2 = make([]string, zbgt)
		}
		for zzic := range z.Slice2 {
			z.Slice2[zzic], bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		}
	}
	if nbs.AlwaysNil {
		if len(z.MapMap) > 0 {
			for key, _ := range z.MapMap {
				delete(z.MapMap, key)
			}
		}

	} else {

		var ztle uint32
		ztle, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if z.MapMap == nil && ztle > 0 {
			z.MapMap = make(map[string]map[string]string, ztle)
		} else if len(z.MapMap) > 0 {
			for key, _ := range z.MapMap {
				delete(z.MapMap, key)
			}
		}
		for ztle > 0 {
			var zpxp string
			var zvvz map[string]string
			ztle--
			zpxp, bts, err = nbs.ReadStringBytes(bts)
			if err != nil {
				panic(err)
			}
			if nbs.AlwaysNil {
				if len(zvvz) > 0 {
					for key, _ := range zvvz {
						delete(zvvz, key)
					}
				}

			} else {

				var zffn uint32
				zffn, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if zvvz == nil && zffn > 0 {
					zvvz = make(map[string]string, zffn)
				} else if len(zvvz) > 0 {
					for key, _ := range zvvz {
						delete(zvvz, key)
					}
				}
				for zffn > 0 {
					var zizi string
					var ziac string
					zffn--
					zizi, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					ziac, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					zvvz[zizi] = ziac
				}
			}
			z.MapMap[zpxp] = zvvz
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Object) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.ObjectNo) + msgp.ArrayHeaderSize
	for zdbp := range z.Slice1 {
		s += msgp.StringPrefixSize + len(z.Slice1[zdbp])
	}
	s += msgp.ArrayHeaderSize
	for zzic := range z.Slice2 {
		s += msgp.StringPrefixSize + len(z.Slice2[zzic])
	}
	s += msgp.MapHeaderSize
	if z.MapMap != nil {
		for zpxp, zvvz := range z.MapMap {
			_ = zvvz
			s += msgp.StringPrefixSize + len(zpxp) + msgp.MapHeaderSize
			if zvvz != nil {
				for zizi, ziac := range zvvz {
					_ = ziac
					s += msgp.StringPrefixSize + len(zizi) + msgp.StringPrefixSize + len(ziac)
				}
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitEmptyInside1) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields17zwia = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields17zwia uint32
	totalEncodedFields17zwia, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft17zwia := totalEncodedFields17zwia
	missingFieldsLeft17zwia := maxFields17zwia - totalEncodedFields17zwia

	var nextMiss17zwia int32 = -1
	var found17zwia [maxFields17zwia]bool
	var curField17zwia string

doneWithStruct17zwia:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft17zwia > 0 || missingFieldsLeft17zwia > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft17zwia, missingFieldsLeft17zwia, msgp.ShowFound(found17zwia[:]), decodeMsgFieldOrder17zwia)
		if encodedFieldsLeft17zwia > 0 {
			encodedFieldsLeft17zwia--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField17zwia = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss17zwia < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss17zwia = 0
			}
			for nextMiss17zwia < maxFields17zwia && found17zwia[nextMiss17zwia] {
				nextMiss17zwia++
			}
			if nextMiss17zwia == maxFields17zwia {
				// filled all the empty fields!
				break doneWithStruct17zwia
			}
			missingFieldsLeft17zwia--
			curField17zwia = decodeMsgFieldOrder17zwia[nextMiss17zwia]
		}
		fmt.Printf("switching on curField: '%v'\n", curField17zwia)
		switch curField17zwia {
		// -- templateDecodeMsg ends here --

		case "CountOfMonteCrisco":
			found17zwia[0] = true
			z.CountOfMonteCrisco, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "name":
			found17zwia[1] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Inside2":
			found17zwia[2] = true
			const maxFields18zvkm = 1

			// -- templateDecodeMsg starts here--
			var totalEncodedFields18zvkm uint32
			totalEncodedFields18zvkm, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft18zvkm := totalEncodedFields18zvkm
			missingFieldsLeft18zvkm := maxFields18zvkm - totalEncodedFields18zvkm

			var nextMiss18zvkm int32 = -1
			var found18zvkm [maxFields18zvkm]bool
			var curField18zvkm string

		doneWithStruct18zvkm:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft18zvkm > 0 || missingFieldsLeft18zvkm > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft18zvkm, missingFieldsLeft18zvkm, msgp.ShowFound(found18zvkm[:]), decodeMsgFieldOrder18zvkm)
				if encodedFieldsLeft18zvkm > 0 {
					encodedFieldsLeft18zvkm--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField18zvkm = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss18zvkm < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss18zvkm = 0
					}
					for nextMiss18zvkm < maxFields18zvkm && found18zvkm[nextMiss18zvkm] {
						nextMiss18zvkm++
					}
					if nextMiss18zvkm == maxFields18zvkm {
						// filled all the empty fields!
						break doneWithStruct18zvkm
					}
					missingFieldsLeft18zvkm--
					curField18zvkm = decodeMsgFieldOrder18zvkm[nextMiss18zvkm]
				}
				fmt.Printf("switching on curField: '%v'\n", curField18zvkm)
				switch curField18zvkm {
				// -- templateDecodeMsg ends here --

				case "NameSuey":
					found18zvkm[0] = true
					z.Inside2.NameSuey, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss18zvkm != -1 {
				dc.PopAlwaysNil()
			}

		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss17zwia != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitEmptyInside1
var decodeMsgFieldOrder17zwia = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder18zvkm = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z *OmitEmptyInside1) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[1] = (len(z.Name) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = false // struct values are never empty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *OmitEmptyInside1) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zdbp [3]bool
	fieldsInUse_zhvl := z.fieldsNotEmpty(empty_zdbp[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zhvl)
	if err != nil {
		return err
	}

	// write "CountOfMonteCrisco"
	err = en.Append(0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.CountOfMonteCrisco)
	if err != nil {
		panic(err)
	}
	if !empty_zdbp[1] {
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Name)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdbp[2] {
		// write "Inside2"
		// map header, size 1
		// write "NameSuey"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Inside2.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OmitEmptyInside1) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "CountOfMonteCrisco"
	o = append(o, 0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
	o = msgp.AppendInt(o, z.CountOfMonteCrisco)
	if !empty[1] {
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
	}

	if !empty[2] {
		// string "Inside2"
		// map header, size 1
		// string "NameSuey"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.Inside2.NameSuey)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitEmptyInside1) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields19zvxc = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields19zvxc uint32
	if !nbs.AlwaysNil {
		totalEncodedFields19zvxc, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft19zvxc := totalEncodedFields19zvxc
	missingFieldsLeft19zvxc := maxFields19zvxc - totalEncodedFields19zvxc

	var nextMiss19zvxc int32 = -1
	var found19zvxc [maxFields19zvxc]bool
	var curField19zvxc string

doneWithStruct19zvxc:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft19zvxc > 0 || missingFieldsLeft19zvxc > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft19zvxc, missingFieldsLeft19zvxc, msgp.ShowFound(found19zvxc[:]), unmarshalMsgFieldOrder19zvxc)
		if encodedFieldsLeft19zvxc > 0 {
			encodedFieldsLeft19zvxc--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField19zvxc = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss19zvxc < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss19zvxc = 0
			}
			for nextMiss19zvxc < maxFields19zvxc && found19zvxc[nextMiss19zvxc] {
				nextMiss19zvxc++
			}
			if nextMiss19zvxc == maxFields19zvxc {
				// filled all the empty fields!
				break doneWithStruct19zvxc
			}
			missingFieldsLeft19zvxc--
			curField19zvxc = unmarshalMsgFieldOrder19zvxc[nextMiss19zvxc]
		}
		fmt.Printf("switching on curField: '%v'\n", curField19zvxc)
		switch curField19zvxc {
		// -- templateUnmarshalMsg ends here --

		case "CountOfMonteCrisco":
			found19zvxc[0] = true
			z.CountOfMonteCrisco, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "name":
			found19zvxc[1] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Inside2":
			found19zvxc[2] = true
			const maxFields20zwmh = 1

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields20zwmh uint32
			if !nbs.AlwaysNil {
				totalEncodedFields20zwmh, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft20zwmh := totalEncodedFields20zwmh
			missingFieldsLeft20zwmh := maxFields20zwmh - totalEncodedFields20zwmh

			var nextMiss20zwmh int32 = -1
			var found20zwmh [maxFields20zwmh]bool
			var curField20zwmh string

		doneWithStruct20zwmh:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft20zwmh > 0 || missingFieldsLeft20zwmh > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft20zwmh, missingFieldsLeft20zwmh, msgp.ShowFound(found20zwmh[:]), unmarshalMsgFieldOrder20zwmh)
				if encodedFieldsLeft20zwmh > 0 {
					encodedFieldsLeft20zwmh--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField20zwmh = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss20zwmh < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss20zwmh = 0
					}
					for nextMiss20zwmh < maxFields20zwmh && found20zwmh[nextMiss20zwmh] {
						nextMiss20zwmh++
					}
					if nextMiss20zwmh == maxFields20zwmh {
						// filled all the empty fields!
						break doneWithStruct20zwmh
					}
					missingFieldsLeft20zwmh--
					curField20zwmh = unmarshalMsgFieldOrder20zwmh[nextMiss20zwmh]
				}
				fmt.Printf("switching on curField: '%v'\n", curField20zwmh)
				switch curField20zwmh {
				// -- templateUnmarshalMsg ends here --

				case "NameSuey":
					found20zwmh[0] = true
					z.Inside2.NameSuey, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss20zwmh != -1 {
				bts = nbs.PopAlwaysNil()
			}

		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss19zvxc != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitEmptyInside1
var unmarshalMsgFieldOrder19zvxc = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder20zwmh = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OmitEmptyInside1) Msgsize() (s int) {
	s = 1 + 19 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 8 + 1 + 9 + msgp.StringPrefixSize + len(z.Inside2.NameSuey)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitEmptyInside2) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields21zkdu = 1

	// -- templateDecodeMsg starts here--
	var totalEncodedFields21zkdu uint32
	totalEncodedFields21zkdu, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft21zkdu := totalEncodedFields21zkdu
	missingFieldsLeft21zkdu := maxFields21zkdu - totalEncodedFields21zkdu

	var nextMiss21zkdu int32 = -1
	var found21zkdu [maxFields21zkdu]bool
	var curField21zkdu string

doneWithStruct21zkdu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft21zkdu > 0 || missingFieldsLeft21zkdu > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft21zkdu, missingFieldsLeft21zkdu, msgp.ShowFound(found21zkdu[:]), decodeMsgFieldOrder21zkdu)
		if encodedFieldsLeft21zkdu > 0 {
			encodedFieldsLeft21zkdu--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField21zkdu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss21zkdu < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss21zkdu = 0
			}
			for nextMiss21zkdu < maxFields21zkdu && found21zkdu[nextMiss21zkdu] {
				nextMiss21zkdu++
			}
			if nextMiss21zkdu == maxFields21zkdu {
				// filled all the empty fields!
				break doneWithStruct21zkdu
			}
			missingFieldsLeft21zkdu--
			curField21zkdu = decodeMsgFieldOrder21zkdu[nextMiss21zkdu]
		}
		fmt.Printf("switching on curField: '%v'\n", curField21zkdu)
		switch curField21zkdu {
		// -- templateDecodeMsg ends here --

		case "NameSuey":
			found21zkdu[0] = true
			z.NameSuey, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss21zkdu != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder21zkdu = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z OmitEmptyInside2) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 1
	}
	var fieldsInUse uint32 = 1
	isempty[0] = (len(z.NameSuey) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z OmitEmptyInside2) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zmti [1]bool
	fieldsInUse_zyvp := z.fieldsNotEmpty(empty_zmti[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zyvp)
	if err != nil {
		return err
	}

	if !empty_zmti[0] {
		// write "NameSuey"
		err = en.Append(0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z OmitEmptyInside2) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [1]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "NameSuey"
		o = append(o, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.NameSuey)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitEmptyInside2) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields22zzbt = 1

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields22zzbt uint32
	if !nbs.AlwaysNil {
		totalEncodedFields22zzbt, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft22zzbt := totalEncodedFields22zzbt
	missingFieldsLeft22zzbt := maxFields22zzbt - totalEncodedFields22zzbt

	var nextMiss22zzbt int32 = -1
	var found22zzbt [maxFields22zzbt]bool
	var curField22zzbt string

doneWithStruct22zzbt:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft22zzbt > 0 || missingFieldsLeft22zzbt > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft22zzbt, missingFieldsLeft22zzbt, msgp.ShowFound(found22zzbt[:]), unmarshalMsgFieldOrder22zzbt)
		if encodedFieldsLeft22zzbt > 0 {
			encodedFieldsLeft22zzbt--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField22zzbt = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss22zzbt < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss22zzbt = 0
			}
			for nextMiss22zzbt < maxFields22zzbt && found22zzbt[nextMiss22zzbt] {
				nextMiss22zzbt++
			}
			if nextMiss22zzbt == maxFields22zzbt {
				// filled all the empty fields!
				break doneWithStruct22zzbt
			}
			missingFieldsLeft22zzbt--
			curField22zzbt = unmarshalMsgFieldOrder22zzbt[nextMiss22zzbt]
		}
		fmt.Printf("switching on curField: '%v'\n", curField22zzbt)
		switch curField22zzbt {
		// -- templateUnmarshalMsg ends here --

		case "NameSuey":
			found22zzbt[0] = true
			z.NameSuey, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss22zzbt != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder22zzbt = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OmitEmptyInside2) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.NameSuey)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitSimple) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields23zkhk = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields23zkhk uint32
	totalEncodedFields23zkhk, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft23zkhk := totalEncodedFields23zkhk
	missingFieldsLeft23zkhk := maxFields23zkhk - totalEncodedFields23zkhk

	var nextMiss23zkhk int32 = -1
	var found23zkhk [maxFields23zkhk]bool
	var curField23zkhk string

doneWithStruct23zkhk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft23zkhk > 0 || missingFieldsLeft23zkhk > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft23zkhk, missingFieldsLeft23zkhk, msgp.ShowFound(found23zkhk[:]), decodeMsgFieldOrder23zkhk)
		if encodedFieldsLeft23zkhk > 0 {
			encodedFieldsLeft23zkhk--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField23zkhk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss23zkhk < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss23zkhk = 0
			}
			for nextMiss23zkhk < maxFields23zkhk && found23zkhk[nextMiss23zkhk] {
				nextMiss23zkhk++
			}
			if nextMiss23zkhk == maxFields23zkhk {
				// filled all the empty fields!
				break doneWithStruct23zkhk
			}
			missingFieldsLeft23zkhk--
			curField23zkhk = decodeMsgFieldOrder23zkhk[nextMiss23zkhk]
		}
		fmt.Printf("switching on curField: '%v'\n", curField23zkhk)
		switch curField23zkhk {
		// -- templateDecodeMsg ends here --

		case "CountDrocula":
			found23zkhk[0] = true
			z.CountDrocula, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Inside1":
			found23zkhk[1] = true
			err = z.Inside1.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss23zkhk != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitSimple
var decodeMsgFieldOrder23zkhk = []string{"CountDrocula", "Inside1"}

// fieldsNotEmpty supports omitempty tags
func (z *OmitSimple) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 2
	}
	var fieldsInUse uint32 = 2
	isempty[1] = false
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *OmitSimple) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zazn [2]bool
	fieldsInUse_zbda := z.fieldsNotEmpty(empty_zazn[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zbda)
	if err != nil {
		return err
	}

	// write "CountDrocula"
	err = en.Append(0xac, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x72, 0x6f, 0x63, 0x75, 0x6c, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.CountDrocula)
	if err != nil {
		panic(err)
	}
	if !empty_zazn[1] {
		// write "Inside1"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		if err != nil {
			return err
		}
		err = z.Inside1.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OmitSimple) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [2]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "CountDrocula"
	o = append(o, 0xac, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x72, 0x6f, 0x63, 0x75, 0x6c, 0x61)
	o = msgp.AppendInt(o, z.CountDrocula)
	if !empty[1] {
		// string "Inside1"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		o, err = z.Inside1.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitSimple) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields24zjjm = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields24zjjm uint32
	if !nbs.AlwaysNil {
		totalEncodedFields24zjjm, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft24zjjm := totalEncodedFields24zjjm
	missingFieldsLeft24zjjm := maxFields24zjjm - totalEncodedFields24zjjm

	var nextMiss24zjjm int32 = -1
	var found24zjjm [maxFields24zjjm]bool
	var curField24zjjm string

doneWithStruct24zjjm:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft24zjjm > 0 || missingFieldsLeft24zjjm > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft24zjjm, missingFieldsLeft24zjjm, msgp.ShowFound(found24zjjm[:]), unmarshalMsgFieldOrder24zjjm)
		if encodedFieldsLeft24zjjm > 0 {
			encodedFieldsLeft24zjjm--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField24zjjm = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss24zjjm < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss24zjjm = 0
			}
			for nextMiss24zjjm < maxFields24zjjm && found24zjjm[nextMiss24zjjm] {
				nextMiss24zjjm++
			}
			if nextMiss24zjjm == maxFields24zjjm {
				// filled all the empty fields!
				break doneWithStruct24zjjm
			}
			missingFieldsLeft24zjjm--
			curField24zjjm = unmarshalMsgFieldOrder24zjjm[nextMiss24zjjm]
		}
		fmt.Printf("switching on curField: '%v'\n", curField24zjjm)
		switch curField24zjjm {
		// -- templateUnmarshalMsg ends here --

		case "CountDrocula":
			found24zjjm[0] = true
			z.CountDrocula, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Inside1":
			found24zjjm[1] = true
			bts, err = z.Inside1.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss24zjjm != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitSimple
var unmarshalMsgFieldOrder24zjjm = []string{"CountDrocula", "Inside1"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OmitSimple) Msgsize() (s int) {
	s = 1 + 13 + msgp.IntSize + 8 + z.Inside1.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Rocky) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields25zdan = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields25zdan uint32
	totalEncodedFields25zdan, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft25zdan := totalEncodedFields25zdan
	missingFieldsLeft25zdan := maxFields25zdan - totalEncodedFields25zdan

	var nextMiss25zdan int32 = -1
	var found25zdan [maxFields25zdan]bool
	var curField25zdan string

doneWithStruct25zdan:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft25zdan > 0 || missingFieldsLeft25zdan > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft25zdan, missingFieldsLeft25zdan, msgp.ShowFound(found25zdan[:]), decodeMsgFieldOrder25zdan)
		if encodedFieldsLeft25zdan > 0 {
			encodedFieldsLeft25zdan--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField25zdan = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss25zdan < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss25zdan = 0
			}
			for nextMiss25zdan < maxFields25zdan && found25zdan[nextMiss25zdan] {
				nextMiss25zdan++
			}
			if nextMiss25zdan == maxFields25zdan {
				// filled all the empty fields!
				break doneWithStruct25zdan
			}
			missingFieldsLeft25zdan--
			curField25zdan = decodeMsgFieldOrder25zdan[nextMiss25zdan]
		}
		fmt.Printf("switching on curField: '%v'\n", curField25zdan)
		switch curField25zdan {
		// -- templateDecodeMsg ends here --

		case "Bugs":
			found25zdan[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bugs != nil {
					dc.PushAlwaysNil()
					err = z.Bugs.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bugs == nil {
					z.Bugs = new(Bunny)
				}
				err = z.Bugs.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "Road":
			found25zdan[1] = true
			z.Road, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Moose":
			found25zdan[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Moose != nil {
					dc.PushAlwaysNil()
					err = z.Moose.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Moose == nil {
					z.Moose = new(Moose)
				}
				err = z.Moose.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss25zdan != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Rocky
var decodeMsgFieldOrder25zdan = []string{"Bugs", "Road", "Moose"}

// fieldsNotEmpty supports omitempty tags
func (z *Rocky) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (z.Bugs == nil) // pointer, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Road) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Moose == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Rocky) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zsjt [3]bool
	fieldsInUse_zqze := z.fieldsNotEmpty(empty_zsjt[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zqze)
	if err != nil {
		return err
	}

	if !empty_zsjt[0] {
		// write "Bugs"
		err = en.Append(0xa4, 0x42, 0x75, 0x67, 0x73)
		if err != nil {
			return err
		}
		if z.Bugs == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bugs.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zsjt[1] {
		// write "Road"
		err = en.Append(0xa4, 0x52, 0x6f, 0x61, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Road)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zsjt[2] {
		// write "Moose"
		err = en.Append(0xa5, 0x4d, 0x6f, 0x6f, 0x73, 0x65)
		if err != nil {
			return err
		}
		if z.Moose == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Moose.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Rocky) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Bugs"
		o = append(o, 0xa4, 0x42, 0x75, 0x67, 0x73)
		if z.Bugs == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bugs.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[1] {
		// string "Road"
		o = append(o, 0xa4, 0x52, 0x6f, 0x61, 0x64)
		o = msgp.AppendString(o, z.Road)
	}

	if !empty[2] {
		// string "Moose"
		o = append(o, 0xa5, 0x4d, 0x6f, 0x6f, 0x73, 0x65)
		if z.Moose == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Moose.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Rocky) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields26zmut = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields26zmut uint32
	if !nbs.AlwaysNil {
		totalEncodedFields26zmut, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft26zmut := totalEncodedFields26zmut
	missingFieldsLeft26zmut := maxFields26zmut - totalEncodedFields26zmut

	var nextMiss26zmut int32 = -1
	var found26zmut [maxFields26zmut]bool
	var curField26zmut string

doneWithStruct26zmut:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft26zmut > 0 || missingFieldsLeft26zmut > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft26zmut, missingFieldsLeft26zmut, msgp.ShowFound(found26zmut[:]), unmarshalMsgFieldOrder26zmut)
		if encodedFieldsLeft26zmut > 0 {
			encodedFieldsLeft26zmut--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField26zmut = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss26zmut < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss26zmut = 0
			}
			for nextMiss26zmut < maxFields26zmut && found26zmut[nextMiss26zmut] {
				nextMiss26zmut++
			}
			if nextMiss26zmut == maxFields26zmut {
				// filled all the empty fields!
				break doneWithStruct26zmut
			}
			missingFieldsLeft26zmut--
			curField26zmut = unmarshalMsgFieldOrder26zmut[nextMiss26zmut]
		}
		fmt.Printf("switching on curField: '%v'\n", curField26zmut)
		switch curField26zmut {
		// -- templateUnmarshalMsg ends here --

		case "Bugs":
			found26zmut[0] = true
			if nbs.AlwaysNil {
				if z.Bugs != nil {
					z.Bugs.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bugs {
						z.Bugs.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bugs == nil {
						z.Bugs = new(Bunny)
					}
					bts, err = z.Bugs.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "Road":
			found26zmut[1] = true
			z.Road, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Moose":
			found26zmut[2] = true
			if nbs.AlwaysNil {
				if z.Moose != nil {
					z.Moose.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Moose {
						z.Moose.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Moose == nil {
						z.Moose = new(Moose)
					}
					bts, err = z.Moose.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss26zmut != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Rocky
var unmarshalMsgFieldOrder26zmut = []string{"Bugs", "Road", "Moose"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Rocky) Msgsize() (s int) {
	s = 1 + 5
	if z.Bugs == nil {
		s += msgp.NilSize
	} else {
		s += z.Bugs.Msgsize()
	}
	s += 5 + msgp.StringPrefixSize + len(z.Road) + 6
	if z.Moose == nil {
		s += msgp.NilSize
	} else {
		s += z.Moose.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestBench) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zgas uint32
	zgas, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zgas != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zgas}
		return
	}
	z.Name, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	z.BirthDay, err = dc.ReadTime()
	if err != nil {
		panic(err)
	}
	z.Phone, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	z.Siblings, err = dc.ReadInt()
	if err != nil {
		panic(err)
	}
	z.Spouse, err = dc.ReadBool()
	if err != nil {
		panic(err)
	}
	z.Money, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *TestBench) fieldsNotEmpty(isempty []bool) uint32 {
	return 6
}

// EncodeMsg implements msgp.Encodable
func (z *TestBench) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Name)
	if err != nil {
		panic(err)
	}
	err = en.WriteTime(z.BirthDay)
	if err != nil {
		panic(err)
	}
	err = en.WriteString(z.Phone)
	if err != nil {
		panic(err)
	}
	err = en.WriteInt(z.Siblings)
	if err != nil {
		panic(err)
	}
	err = en.WriteBool(z.Spouse)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Money)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestBench) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendString(o, z.Name)
	o = msgp.AppendTime(o, z.BirthDay)
	o = msgp.AppendString(o, z.Phone)
	o = msgp.AppendInt(o, z.Siblings)
	o = msgp.AppendBool(o, z.Spouse)
	o = msgp.AppendFloat64(o, z.Money)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestBench) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zmps uint32
	zmps, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zmps != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zmps}
		return
	}
	z.Name, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	z.BirthDay, bts, err = nbs.ReadTimeBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Phone, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Siblings, bts, err = nbs.ReadIntBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Spouse, bts, err = nbs.ReadBoolBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Money, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestBench) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Name) + msgp.TimeSize + msgp.StringPrefixSize + len(z.Phone) + msgp.IntSize + msgp.BoolSize + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestFast) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zpox uint32
	zpox, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zpox != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zpox}
		return
	}
	z.Lat, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Long, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Alt, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Data, err = dc.ReadBytes(z.Data)
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *TestFast) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *TestFast) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Lat)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Long)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Alt)
	if err != nil {
		panic(err)
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestFast) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendFloat64(o, z.Lat)
	o = msgp.AppendFloat64(o, z.Long)
	o = msgp.AppendFloat64(o, z.Alt)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestFast) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zcae uint32
	zcae, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zcae != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zcae}
		return
	}
	z.Lat, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	z.Long, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	z.Alt, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	if nbs.AlwaysNil || msgp.IsNil(bts) {
		if !nbs.AlwaysNil {
			bts = bts[1:]
		}
		z.Data = z.Data[:0]
	} else {
		z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

		if err != nil {
			panic(err)
		}
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestFast) Msgsize() (s int) {
	s = 1 + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestHidden) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields27zzmf = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields27zzmf uint32
	totalEncodedFields27zzmf, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft27zzmf := totalEncodedFields27zzmf
	missingFieldsLeft27zzmf := maxFields27zzmf - totalEncodedFields27zzmf

	var nextMiss27zzmf int32 = -1
	var found27zzmf [maxFields27zzmf]bool
	var curField27zzmf string

doneWithStruct27zzmf:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft27zzmf > 0 || missingFieldsLeft27zzmf > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft27zzmf, missingFieldsLeft27zzmf, msgp.ShowFound(found27zzmf[:]), decodeMsgFieldOrder27zzmf)
		if encodedFieldsLeft27zzmf > 0 {
			encodedFieldsLeft27zzmf--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField27zzmf = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss27zzmf < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss27zzmf = 0
			}
			for nextMiss27zzmf < maxFields27zzmf && found27zzmf[nextMiss27zzmf] {
				nextMiss27zzmf++
			}
			if nextMiss27zzmf == maxFields27zzmf {
				// filled all the empty fields!
				break doneWithStruct27zzmf
			}
			missingFieldsLeft27zzmf--
			curField27zzmf = decodeMsgFieldOrder27zzmf[nextMiss27zzmf]
		}
		fmt.Printf("switching on curField: '%v'\n", curField27zzmf)
		switch curField27zzmf {
		// -- templateDecodeMsg ends here --

		case "A":
			found27zzmf[0] = true
			z.A, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "B":
			found27zzmf[1] = true
			var zsdo uint32
			zsdo, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.B) >= int(zsdo) {
				z.B = (z.B)[:zsdo]
			} else {
				z.B = make([]float64, zsdo)
			}
			for zsjk := range z.B {
				z.B[zsjk], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss27zzmf != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestHidden
var decodeMsgFieldOrder27zzmf = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z *TestHidden) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *TestHidden) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "A"
	err = en.Append(0x82, 0xa1, 0x41)
	if err != nil {
		return err
	}
	err = en.WriteString(z.A)
	if err != nil {
		panic(err)
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.B)))
	if err != nil {
		panic(err)
	}
	for zsjk := range z.B {
		err = en.WriteFloat64(z.B[zsjk])
		if err != nil {
			panic(err)
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestHidden) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "A"
	o = append(o, 0x82, 0xa1, 0x41)
	o = msgp.AppendString(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendArrayHeader(o, uint32(len(z.B)))
	for zsjk := range z.B {
		o = msgp.AppendFloat64(o, z.B[zsjk])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestHidden) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields28znoz = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields28znoz uint32
	if !nbs.AlwaysNil {
		totalEncodedFields28znoz, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft28znoz := totalEncodedFields28znoz
	missingFieldsLeft28znoz := maxFields28znoz - totalEncodedFields28znoz

	var nextMiss28znoz int32 = -1
	var found28znoz [maxFields28znoz]bool
	var curField28znoz string

doneWithStruct28znoz:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft28znoz > 0 || missingFieldsLeft28znoz > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft28znoz, missingFieldsLeft28znoz, msgp.ShowFound(found28znoz[:]), unmarshalMsgFieldOrder28znoz)
		if encodedFieldsLeft28znoz > 0 {
			encodedFieldsLeft28znoz--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField28znoz = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss28znoz < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss28znoz = 0
			}
			for nextMiss28znoz < maxFields28znoz && found28znoz[nextMiss28znoz] {
				nextMiss28znoz++
			}
			if nextMiss28znoz == maxFields28znoz {
				// filled all the empty fields!
				break doneWithStruct28znoz
			}
			missingFieldsLeft28znoz--
			curField28znoz = unmarshalMsgFieldOrder28znoz[nextMiss28znoz]
		}
		fmt.Printf("switching on curField: '%v'\n", curField28znoz)
		switch curField28znoz {
		// -- templateUnmarshalMsg ends here --

		case "A":
			found28znoz[0] = true
			z.A, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "B":
			found28znoz[1] = true
			if nbs.AlwaysNil {
				(z.B) = (z.B)[:0]
			} else {

				var zpmr uint32
				zpmr, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.B) >= int(zpmr) {
					z.B = (z.B)[:zpmr]
				} else {
					z.B = make([]float64, zpmr)
				}
				for zsjk := range z.B {
					z.B[zsjk], bts, err = nbs.ReadFloat64Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss28znoz != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestHidden
var unmarshalMsgFieldOrder28znoz = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestHidden) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.A) + 2 + msgp.ArrayHeaderSize + (len(z.B) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestOmitEmpty) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields29zfiq = 29

	// -- templateDecodeMsg starts here--
	var totalEncodedFields29zfiq uint32
	totalEncodedFields29zfiq, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft29zfiq := totalEncodedFields29zfiq
	missingFieldsLeft29zfiq := maxFields29zfiq - totalEncodedFields29zfiq

	var nextMiss29zfiq int32 = -1
	var found29zfiq [maxFields29zfiq]bool
	var curField29zfiq string

doneWithStruct29zfiq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft29zfiq > 0 || missingFieldsLeft29zfiq > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft29zfiq, missingFieldsLeft29zfiq, msgp.ShowFound(found29zfiq[:]), decodeMsgFieldOrder29zfiq)
		if encodedFieldsLeft29zfiq > 0 {
			encodedFieldsLeft29zfiq--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField29zfiq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss29zfiq < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss29zfiq = 0
			}
			for nextMiss29zfiq < maxFields29zfiq && found29zfiq[nextMiss29zfiq] {
				nextMiss29zfiq++
			}
			if nextMiss29zfiq == maxFields29zfiq {
				// filled all the empty fields!
				break doneWithStruct29zfiq
			}
			missingFieldsLeft29zfiq--
			curField29zfiq = decodeMsgFieldOrder29zfiq[nextMiss29zfiq]
		}
		fmt.Printf("switching on curField: '%v'\n", curField29zfiq)
		switch curField29zfiq {
		// -- templateDecodeMsg ends here --

		case "Name":
			found29zfiq[0] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "BirthDay":
			found29zfiq[1] = true
			z.BirthDay, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "Phone":
			found29zfiq[2] = true
			z.Phone, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Siblings":
			found29zfiq[3] = true
			z.Siblings, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Spouse":
			found29zfiq[4] = true
			z.Spouse, err = dc.ReadBool()
			if err != nil {
				panic(err)
			}
		case "Money":
			found29zfiq[5] = true
			z.Money, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "SliceName":
			found29zfiq[6] = true
			var zvqm uint32
			zvqm, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceName) >= int(zvqm) {
				z.SliceName = (z.SliceName)[:zvqm]
			} else {
				z.SliceName = make([]string, zvqm)
			}
			for zicx := range z.SliceName {
				z.SliceName[zicx], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SliceBirthDay":
			found29zfiq[7] = true
			var zszn uint32
			zszn, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceBirthDay) >= int(zszn) {
				z.SliceBirthDay = (z.SliceBirthDay)[:zszn]
			} else {
				z.SliceBirthDay = make([]time.Time, zszn)
			}
			for zvjm := range z.SliceBirthDay {
				z.SliceBirthDay[zvjm], err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "SlicePhone":
			found29zfiq[8] = true
			var zrvf uint32
			zrvf, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SlicePhone) >= int(zrvf) {
				z.SlicePhone = (z.SlicePhone)[:zrvf]
			} else {
				z.SlicePhone = make([]string, zrvf)
			}
			for zakp := range z.SlicePhone {
				z.SlicePhone[zakp], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SliceSiblings":
			found29zfiq[9] = true
			var zqrt uint32
			zqrt, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceSiblings) >= int(zqrt) {
				z.SliceSiblings = (z.SliceSiblings)[:zqrt]
			} else {
				z.SliceSiblings = make([]int, zqrt)
			}
			for zrmf := range z.SliceSiblings {
				z.SliceSiblings[zrmf], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "SliceSpouse":
			found29zfiq[10] = true
			var zamc uint32
			zamc, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceSpouse) >= int(zamc) {
				z.SliceSpouse = (z.SliceSpouse)[:zamc]
			} else {
				z.SliceSpouse = make([]bool, zamc)
			}
			for zgfi := range z.SliceSpouse {
				z.SliceSpouse[zgfi], err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "SliceMoney":
			found29zfiq[11] = true
			var zflz uint32
			zflz, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceMoney) >= int(zflz) {
				z.SliceMoney = (z.SliceMoney)[:zflz]
			} else {
				z.SliceMoney = make([]float64, zflz)
			}
			for zpna := range z.SliceMoney {
				z.SliceMoney[zpna], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayName":
			found29zfiq[12] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zktu uint32
				zktu, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zktu != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zktu}
					return
				}
			}
			for zjua := range z.ArrayName {
				z.ArrayName[zjua], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayBirthDay":
			found29zfiq[13] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zcnl uint32
				zcnl, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zcnl != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zcnl}
					return
				}
			}
			for zzdx := range z.ArrayBirthDay {
				z.ArrayBirthDay[zzdx], err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayPhone":
			found29zfiq[14] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zxnm uint32
				zxnm, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zxnm != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zxnm}
					return
				}
			}
			for zreb := range z.ArrayPhone {
				z.ArrayPhone[zreb], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "ArraySiblings":
			found29zfiq[15] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zgfa uint32
				zgfa, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zgfa != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zgfa}
					return
				}
			}
			for zhmc := range z.ArraySiblings {
				z.ArraySiblings[zhmc], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "ArraySpouse":
			found29zfiq[16] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var ziqd uint32
				ziqd, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && ziqd != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: ziqd}
					return
				}
			}
			for zmff := range z.ArraySpouse {
				z.ArraySpouse[zmff], err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayMoney":
			found29zfiq[17] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zzin uint32
				zzin, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zzin != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zzin}
					return
				}
			}
			for zqti := range z.ArrayMoney {
				z.ArrayMoney[zqti], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "MapStringString":
			found29zfiq[18] = true
			var zctp uint32
			zctp, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MapStringString == nil && zctp > 0 {
				z.MapStringString = make(map[string]string, zctp)
			} else if len(z.MapStringString) > 0 {
				for key, _ := range z.MapStringString {
					delete(z.MapStringString, key)
				}
			}
			for zctp > 0 {
				zctp--
				var zaxt string
				var zwua string
				zaxt, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zwua, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.MapStringString[zaxt] = zwua
			}
		case "MapStringIface":
			found29zfiq[19] = true
			var zvzh uint32
			zvzh, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MapStringIface == nil && zvzh > 0 {
				z.MapStringIface = make(map[string]interface{}, zvzh)
			} else if len(z.MapStringIface) > 0 {
				for key, _ := range z.MapStringIface {
					delete(z.MapStringIface, key)
				}
			}
			for zvzh > 0 {
				zvzh--
				var zuiu string
				var zshv interface{}
				zuiu, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zshv, err = dc.ReadIntf()
				if err != nil {
					panic(err)
				}
				z.MapStringIface[zuiu] = zshv
			}
		case "PtrName":
			found29zfiq[20] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrName == nil {
					z.PtrName = new(string)
				}
				*z.PtrName, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "PtrBirthDay":
			found29zfiq[21] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrBirthDay == nil {
					z.PtrBirthDay = new(time.Time)
				}
				*z.PtrBirthDay, err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "PtrPhone":
			found29zfiq[22] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrPhone == nil {
					z.PtrPhone = new(string)
				}
				*z.PtrPhone, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "PtrSiblings":
			found29zfiq[23] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrSiblings == nil {
					z.PtrSiblings = new(int)
				}
				*z.PtrSiblings, err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "PtrSpouse":
			found29zfiq[24] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrSpouse == nil {
					z.PtrSpouse = new(bool)
				}
				*z.PtrSpouse, err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "PtrMoney":
			found29zfiq[25] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrMoney == nil {
					z.PtrMoney = new(float64)
				}
				*z.PtrMoney, err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "Inside1":
			found29zfiq[26] = true
			err = z.Inside1.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found29zfiq[27] = true
			z.Greetings, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found29zfiq[28] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bullwinkle != nil {
					dc.PushAlwaysNil()
					err = z.Bullwinkle.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bullwinkle == nil {
					z.Bullwinkle = new(Rocky)
				}
				err = z.Bullwinkle.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss29zfiq != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestOmitEmpty
var decodeMsgFieldOrder29zfiq = []string{"Name", "BirthDay", "Phone", "Siblings", "Spouse", "Money", "SliceName", "SliceBirthDay", "SlicePhone", "SliceSiblings", "SliceSpouse", "SliceMoney", "ArrayName", "ArrayBirthDay", "ArrayPhone", "ArraySiblings", "ArraySpouse", "ArrayMoney", "MapStringString", "MapStringIface", "PtrName", "PtrBirthDay", "PtrPhone", "PtrSiblings", "PtrSpouse", "PtrMoney", "Inside1", "Greetings", "Bullwinkle"}

// fieldsNotEmpty supports omitempty tags
func (z *TestOmitEmpty) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 29
	}
	var fieldsInUse uint32 = 29
	isempty[0] = (len(z.Name) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (z.BirthDay.IsZero()) // time.Time, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (len(z.Phone) == 0) // string, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (z.Siblings == 0) // number, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (!z.Spouse) // bool, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (z.Money == 0) // number, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (len(z.SliceName) == 0) // string, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (len(z.SliceBirthDay) == 0) // string, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (len(z.SlicePhone) == 0) // string, omitempty
	if isempty[8] {
		fieldsInUse--
	}
	isempty[9] = (len(z.SliceSiblings) == 0) // string, omitempty
	if isempty[9] {
		fieldsInUse--
	}
	isempty[10] = (len(z.SliceSpouse) == 0) // string, omitempty
	if isempty[10] {
		fieldsInUse--
	}
	isempty[11] = (len(z.SliceMoney) == 0) // string, omitempty
	if isempty[11] {
		fieldsInUse--
	}
	isempty[12] = (len(z.ArrayName) == 0) // string, omitempty
	if isempty[12] {
		fieldsInUse--
	}
	isempty[13] = (len(z.ArrayBirthDay) == 0) // string, omitempty
	if isempty[13] {
		fieldsInUse--
	}
	isempty[14] = (len(z.ArrayPhone) == 0) // string, omitempty
	if isempty[14] {
		fieldsInUse--
	}
	isempty[15] = (len(z.ArraySiblings) == 0) // string, omitempty
	if isempty[15] {
		fieldsInUse--
	}
	isempty[16] = (len(z.ArraySpouse) == 0) // string, omitempty
	if isempty[16] {
		fieldsInUse--
	}
	isempty[17] = (len(z.ArrayMoney) == 0) // string, omitempty
	if isempty[17] {
		fieldsInUse--
	}
	isempty[18] = (len(z.MapStringString) == 0) // string, omitempty
	if isempty[18] {
		fieldsInUse--
	}
	isempty[19] = (len(z.MapStringIface) == 0) // string, omitempty
	if isempty[19] {
		fieldsInUse--
	}
	isempty[20] = (z.PtrName == nil) // pointer, omitempty
	if isempty[20] {
		fieldsInUse--
	}
	isempty[21] = (z.PtrBirthDay == nil) // pointer, omitempty
	if isempty[21] {
		fieldsInUse--
	}
	isempty[22] = (z.PtrPhone == nil) // pointer, omitempty
	if isempty[22] {
		fieldsInUse--
	}
	isempty[23] = (z.PtrSiblings == nil) // pointer, omitempty
	if isempty[23] {
		fieldsInUse--
	}
	isempty[24] = (z.PtrSpouse == nil) // pointer, omitempty
	if isempty[24] {
		fieldsInUse--
	}
	isempty[25] = (z.PtrMoney == nil) // pointer, omitempty
	if isempty[25] {
		fieldsInUse--
	}
	isempty[26] = false
	if isempty[26] {
		fieldsInUse--
	}
	isempty[27] = (len(z.Greetings) == 0) // string, omitempty
	if isempty[27] {
		fieldsInUse--
	}
	isempty[28] = (z.Bullwinkle == nil) // pointer, omitempty
	if isempty[28] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *TestOmitEmpty) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zdkt [29]bool
	fieldsInUse_zqbs := z.fieldsNotEmpty(empty_zdkt[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zqbs)
	if err != nil {
		return err
	}

	if !empty_zdkt[0] {
		// write "Name"
		err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Name)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[1] {
		// write "BirthDay"
		err = en.Append(0xa8, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteTime(z.BirthDay)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[2] {
		// write "Phone"
		err = en.Append(0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Phone)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[3] {
		// write "Siblings"
		err = en.Append(0xa8, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.Siblings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[4] {
		// write "Spouse"
		err = en.Append(0xa6, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Spouse)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[5] {
		// write "Money"
		err = en.Append(0xa5, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteFloat64(z.Money)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[6] {
		// write "SliceName"
		err = en.Append(0xa9, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceName)))
		if err != nil {
			panic(err)
		}
		for zicx := range z.SliceName {
			err = en.WriteString(z.SliceName[zicx])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[7] {
		// write "SliceBirthDay"
		err = en.Append(0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceBirthDay)))
		if err != nil {
			panic(err)
		}
		for zvjm := range z.SliceBirthDay {
			err = en.WriteTime(z.SliceBirthDay[zvjm])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[8] {
		// write "SlicePhone"
		err = en.Append(0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SlicePhone)))
		if err != nil {
			panic(err)
		}
		for zakp := range z.SlicePhone {
			err = en.WriteString(z.SlicePhone[zakp])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[9] {
		// write "SliceSiblings"
		err = en.Append(0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceSiblings)))
		if err != nil {
			panic(err)
		}
		for zrmf := range z.SliceSiblings {
			err = en.WriteInt(z.SliceSiblings[zrmf])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[10] {
		// write "SliceSpouse"
		err = en.Append(0xab, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceSpouse)))
		if err != nil {
			panic(err)
		}
		for zgfi := range z.SliceSpouse {
			err = en.WriteBool(z.SliceSpouse[zgfi])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[11] {
		// write "SliceMoney"
		err = en.Append(0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceMoney)))
		if err != nil {
			panic(err)
		}
		for zpna := range z.SliceMoney {
			err = en.WriteFloat64(z.SliceMoney[zpna])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[12] {
		// write "ArrayName"
		err = en.Append(0xa9, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zjua := range z.ArrayName {
			err = en.WriteString(z.ArrayName[zjua])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[13] {
		// write "ArrayBirthDay"
		err = en.Append(0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zzdx := range z.ArrayBirthDay {
			err = en.WriteTime(z.ArrayBirthDay[zzdx])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[14] {
		// write "ArrayPhone"
		err = en.Append(0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zreb := range z.ArrayPhone {
			err = en.WriteString(z.ArrayPhone[zreb])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[15] {
		// write "ArraySiblings"
		err = en.Append(0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zhmc := range z.ArraySiblings {
			err = en.WriteInt(z.ArraySiblings[zhmc])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[16] {
		// write "ArraySpouse"
		err = en.Append(0xab, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zmff := range z.ArraySpouse {
			err = en.WriteBool(z.ArraySpouse[zmff])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[17] {
		// write "ArrayMoney"
		err = en.Append(0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zqti := range z.ArrayMoney {
			err = en.WriteFloat64(z.ArrayMoney[zqti])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[18] {
		// write "MapStringString"
		err = en.Append(0xaf, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MapStringString)))
		if err != nil {
			panic(err)
		}
		for zaxt, zwua := range z.MapStringString {
			err = en.WriteString(zaxt)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zwua)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[19] {
		// write "MapStringIface"
		err = en.Append(0xae, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x66, 0x61, 0x63, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MapStringIface)))
		if err != nil {
			panic(err)
		}
		for zuiu, zshv := range z.MapStringIface {
			err = en.WriteString(zuiu)
			if err != nil {
				panic(err)
			}
			err = en.WriteIntf(zshv)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[20] {
		// write "PtrName"
		err = en.Append(0xa7, 0x50, 0x74, 0x72, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		if z.PtrName == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PtrName)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[21] {
		// write "PtrBirthDay"
		err = en.Append(0xab, 0x50, 0x74, 0x72, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		if z.PtrBirthDay == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteTime(*z.PtrBirthDay)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[22] {
		// write "PtrPhone"
		err = en.Append(0xa8, 0x50, 0x74, 0x72, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		if z.PtrPhone == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PtrPhone)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[23] {
		// write "PtrSiblings"
		err = en.Append(0xab, 0x50, 0x74, 0x72, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		if z.PtrSiblings == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.PtrSiblings)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[24] {
		// write "PtrSpouse"
		err = en.Append(0xa9, 0x50, 0x74, 0x72, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		if z.PtrSpouse == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.PtrSpouse)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[25] {
		// write "PtrMoney"
		err = en.Append(0xa8, 0x50, 0x74, 0x72, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		if z.PtrMoney == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.PtrMoney)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zdkt[26] {
		// write "Inside1"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		if err != nil {
			return err
		}
		err = z.Inside1.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[27] {
		// write "Greetings"
		err = en.Append(0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Greetings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zdkt[28] {
		// write "Bullwinkle"
		err = en.Append(0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if err != nil {
			return err
		}
		if z.Bullwinkle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullwinkle.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestOmitEmpty) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [29]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Name"
		o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
	}

	if !empty[1] {
		// string "BirthDay"
		o = append(o, 0xa8, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendTime(o, z.BirthDay)
	}

	if !empty[2] {
		// string "Phone"
		o = append(o, 0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendString(o, z.Phone)
	}

	if !empty[3] {
		// string "Siblings"
		o = append(o, 0xa8, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendInt(o, z.Siblings)
	}

	if !empty[4] {
		// string "Spouse"
		o = append(o, 0xa6, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendBool(o, z.Spouse)
	}

	if !empty[5] {
		// string "Money"
		o = append(o, 0xa5, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendFloat64(o, z.Money)
	}

	if !empty[6] {
		// string "SliceName"
		o = append(o, 0xa9, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceName)))
		for zicx := range z.SliceName {
			o = msgp.AppendString(o, z.SliceName[zicx])
		}
	}

	if !empty[7] {
		// string "SliceBirthDay"
		o = append(o, 0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceBirthDay)))
		for zvjm := range z.SliceBirthDay {
			o = msgp.AppendTime(o, z.SliceBirthDay[zvjm])
		}
	}

	if !empty[8] {
		// string "SlicePhone"
		o = append(o, 0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SlicePhone)))
		for zakp := range z.SlicePhone {
			o = msgp.AppendString(o, z.SlicePhone[zakp])
		}
	}

	if !empty[9] {
		// string "SliceSiblings"
		o = append(o, 0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceSiblings)))
		for zrmf := range z.SliceSiblings {
			o = msgp.AppendInt(o, z.SliceSiblings[zrmf])
		}
	}

	if !empty[10] {
		// string "SliceSpouse"
		o = append(o, 0xab, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceSpouse)))
		for zgfi := range z.SliceSpouse {
			o = msgp.AppendBool(o, z.SliceSpouse[zgfi])
		}
	}

	if !empty[11] {
		// string "SliceMoney"
		o = append(o, 0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceMoney)))
		for zpna := range z.SliceMoney {
			o = msgp.AppendFloat64(o, z.SliceMoney[zpna])
		}
	}

	if !empty[12] {
		// string "ArrayName"
		o = append(o, 0xa9, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zjua := range z.ArrayName {
			o = msgp.AppendString(o, z.ArrayName[zjua])
		}
	}

	if !empty[13] {
		// string "ArrayBirthDay"
		o = append(o, 0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zzdx := range z.ArrayBirthDay {
			o = msgp.AppendTime(o, z.ArrayBirthDay[zzdx])
		}
	}

	if !empty[14] {
		// string "ArrayPhone"
		o = append(o, 0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zreb := range z.ArrayPhone {
			o = msgp.AppendString(o, z.ArrayPhone[zreb])
		}
	}

	if !empty[15] {
		// string "ArraySiblings"
		o = append(o, 0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, 3)
		for zhmc := range z.ArraySiblings {
			o = msgp.AppendInt(o, z.ArraySiblings[zhmc])
		}
	}

	if !empty[16] {
		// string "ArraySpouse"
		o = append(o, 0xab, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zmff := range z.ArraySpouse {
			o = msgp.AppendBool(o, z.ArraySpouse[zmff])
		}
	}

	if !empty[17] {
		// string "ArrayMoney"
		o = append(o, 0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zqti := range z.ArrayMoney {
			o = msgp.AppendFloat64(o, z.ArrayMoney[zqti])
		}
	}

	if !empty[18] {
		// string "MapStringString"
		o = append(o, 0xaf, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
		o = msgp.AppendMapHeader(o, uint32(len(z.MapStringString)))
		for zaxt, zwua := range z.MapStringString {
			o = msgp.AppendString(o, zaxt)
			o = msgp.AppendString(o, zwua)
		}
	}

	if !empty[19] {
		// string "MapStringIface"
		o = append(o, 0xae, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x66, 0x61, 0x63, 0x65)
		o = msgp.AppendMapHeader(o, uint32(len(z.MapStringIface)))
		for zuiu, zshv := range z.MapStringIface {
			o = msgp.AppendString(o, zuiu)
			o, err = msgp.AppendIntf(o, zshv)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[20] {
		// string "PtrName"
		o = append(o, 0xa7, 0x50, 0x74, 0x72, 0x4e, 0x61, 0x6d, 0x65)
		if z.PtrName == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PtrName)
		}
	}

	if !empty[21] {
		// string "PtrBirthDay"
		o = append(o, 0xab, 0x50, 0x74, 0x72, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if z.PtrBirthDay == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendTime(o, *z.PtrBirthDay)
		}
	}

	if !empty[22] {
		// string "PtrPhone"
		o = append(o, 0xa8, 0x50, 0x74, 0x72, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if z.PtrPhone == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PtrPhone)
		}
	}

	if !empty[23] {
		// string "PtrSiblings"
		o = append(o, 0xab, 0x50, 0x74, 0x72, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if z.PtrSiblings == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.PtrSiblings)
		}
	}

	if !empty[24] {
		// string "PtrSpouse"
		o = append(o, 0xa9, 0x50, 0x74, 0x72, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if z.PtrSpouse == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.PtrSpouse)
		}
	}

	if !empty[25] {
		// string "PtrMoney"
		o = append(o, 0xa8, 0x50, 0x74, 0x72, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if z.PtrMoney == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.PtrMoney)
		}
	}

	if !empty[26] {
		// string "Inside1"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		o, err = z.Inside1.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}

	if !empty[27] {
		// string "Greetings"
		o = append(o, 0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendString(o, z.Greetings)
	}

	if !empty[28] {
		// string "Bullwinkle"
		o = append(o, 0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if z.Bullwinkle == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullwinkle.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestOmitEmpty) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields30zaba = 29

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields30zaba uint32
	if !nbs.AlwaysNil {
		totalEncodedFields30zaba, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft30zaba := totalEncodedFields30zaba
	missingFieldsLeft30zaba := maxFields30zaba - totalEncodedFields30zaba

	var nextMiss30zaba int32 = -1
	var found30zaba [maxFields30zaba]bool
	var curField30zaba string

doneWithStruct30zaba:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft30zaba > 0 || missingFieldsLeft30zaba > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft30zaba, missingFieldsLeft30zaba, msgp.ShowFound(found30zaba[:]), unmarshalMsgFieldOrder30zaba)
		if encodedFieldsLeft30zaba > 0 {
			encodedFieldsLeft30zaba--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField30zaba = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss30zaba < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss30zaba = 0
			}
			for nextMiss30zaba < maxFields30zaba && found30zaba[nextMiss30zaba] {
				nextMiss30zaba++
			}
			if nextMiss30zaba == maxFields30zaba {
				// filled all the empty fields!
				break doneWithStruct30zaba
			}
			missingFieldsLeft30zaba--
			curField30zaba = unmarshalMsgFieldOrder30zaba[nextMiss30zaba]
		}
		fmt.Printf("switching on curField: '%v'\n", curField30zaba)
		switch curField30zaba {
		// -- templateUnmarshalMsg ends here --

		case "Name":
			found30zaba[0] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "BirthDay":
			found30zaba[1] = true
			z.BirthDay, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Phone":
			found30zaba[2] = true
			z.Phone, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Siblings":
			found30zaba[3] = true
			z.Siblings, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Spouse":
			found30zaba[4] = true
			z.Spouse, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Money":
			found30zaba[5] = true
			z.Money, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "SliceName":
			found30zaba[6] = true
			if nbs.AlwaysNil {
				(z.SliceName) = (z.SliceName)[:0]
			} else {

				var zdjc uint32
				zdjc, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceName) >= int(zdjc) {
					z.SliceName = (z.SliceName)[:zdjc]
				} else {
					z.SliceName = make([]string, zdjc)
				}
				for zicx := range z.SliceName {
					z.SliceName[zicx], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceBirthDay":
			found30zaba[7] = true
			if nbs.AlwaysNil {
				(z.SliceBirthDay) = (z.SliceBirthDay)[:0]
			} else {

				var znem uint32
				znem, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceBirthDay) >= int(znem) {
					z.SliceBirthDay = (z.SliceBirthDay)[:znem]
				} else {
					z.SliceBirthDay = make([]time.Time, znem)
				}
				for zvjm := range z.SliceBirthDay {
					z.SliceBirthDay[zvjm], bts, err = nbs.ReadTimeBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SlicePhone":
			found30zaba[8] = true
			if nbs.AlwaysNil {
				(z.SlicePhone) = (z.SlicePhone)[:0]
			} else {

				var zhbx uint32
				zhbx, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SlicePhone) >= int(zhbx) {
					z.SlicePhone = (z.SlicePhone)[:zhbx]
				} else {
					z.SlicePhone = make([]string, zhbx)
				}
				for zakp := range z.SlicePhone {
					z.SlicePhone[zakp], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceSiblings":
			found30zaba[9] = true
			if nbs.AlwaysNil {
				(z.SliceSiblings) = (z.SliceSiblings)[:0]
			} else {

				var zfhj uint32
				zfhj, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceSiblings) >= int(zfhj) {
					z.SliceSiblings = (z.SliceSiblings)[:zfhj]
				} else {
					z.SliceSiblings = make([]int, zfhj)
				}
				for zrmf := range z.SliceSiblings {
					z.SliceSiblings[zrmf], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceSpouse":
			found30zaba[10] = true
			if nbs.AlwaysNil {
				(z.SliceSpouse) = (z.SliceSpouse)[:0]
			} else {

				var zffd uint32
				zffd, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceSpouse) >= int(zffd) {
					z.SliceSpouse = (z.SliceSpouse)[:zffd]
				} else {
					z.SliceSpouse = make([]bool, zffd)
				}
				for zgfi := range z.SliceSpouse {
					z.SliceSpouse[zgfi], bts, err = nbs.ReadBoolBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceMoney":
			found30zaba[11] = true
			if nbs.AlwaysNil {
				(z.SliceMoney) = (z.SliceMoney)[:0]
			} else {

				var znmz uint32
				znmz, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceMoney) >= int(znmz) {
					z.SliceMoney = (z.SliceMoney)[:znmz]
				} else {
					z.SliceMoney = make([]float64, znmz)
				}
				for zpna := range z.SliceMoney {
					z.SliceMoney[zpna], bts, err = nbs.ReadFloat64Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "ArrayName":
			found30zaba[12] = true
			var zjkd uint32
			zjkd, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zjkd != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zjkd}
				return
			}
			for zjua := range z.ArrayName {
				z.ArrayName[zjua], bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayBirthDay":
			found30zaba[13] = true
			var zlzd uint32
			zlzd, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zlzd != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zlzd}
				return
			}
			for zzdx := range z.ArrayBirthDay {
				z.ArrayBirthDay[zzdx], bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayPhone":
			found30zaba[14] = true
			var zzrw uint32
			zzrw, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zzrw != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zzrw}
				return
			}
			for zreb := range z.ArrayPhone {
				z.ArrayPhone[zreb], bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArraySiblings":
			found30zaba[15] = true
			var zqfw uint32
			zqfw, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zqfw != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zqfw}
				return
			}
			for zhmc := range z.ArraySiblings {
				z.ArraySiblings[zhmc], bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArraySpouse":
			found30zaba[16] = true
			var zaqs uint32
			zaqs, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zaqs != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zaqs}
				return
			}
			for zmff := range z.ArraySpouse {
				z.ArraySpouse[zmff], bts, err = nbs.ReadBoolBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayMoney":
			found30zaba[17] = true
			var zsvt uint32
			zsvt, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zsvt != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zsvt}
				return
			}
			for zqti := range z.ArrayMoney {
				z.ArrayMoney[zqti], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "MapStringString":
			found30zaba[18] = true
			if nbs.AlwaysNil {
				if len(z.MapStringString) > 0 {
					for key, _ := range z.MapStringString {
						delete(z.MapStringString, key)
					}
				}

			} else {

				var znsn uint32
				znsn, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MapStringString == nil && znsn > 0 {
					z.MapStringString = make(map[string]string, znsn)
				} else if len(z.MapStringString) > 0 {
					for key, _ := range z.MapStringString {
						delete(z.MapStringString, key)
					}
				}
				for znsn > 0 {
					var zaxt string
					var zwua string
					znsn--
					zaxt, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zwua, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MapStringString[zaxt] = zwua
				}
			}
		case "MapStringIface":
			found30zaba[19] = true
			if nbs.AlwaysNil {
				if len(z.MapStringIface) > 0 {
					for key, _ := range z.MapStringIface {
						delete(z.MapStringIface, key)
					}
				}

			} else {

				var zgkr uint32
				zgkr, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MapStringIface == nil && zgkr > 0 {
					z.MapStringIface = make(map[string]interface{}, zgkr)
				} else if len(z.MapStringIface) > 0 {
					for key, _ := range z.MapStringIface {
						delete(z.MapStringIface, key)
					}
				}
				for zgkr > 0 {
					var zuiu string
					var zshv interface{}
					zgkr--
					zuiu, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zshv, bts, err = nbs.ReadIntfBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MapStringIface[zuiu] = zshv
				}
			}
		case "PtrName":
			found30zaba[20] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrName == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrName == nil {
					z.PtrName = new(string)
				}
				*z.PtrName, bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrBirthDay":
			found30zaba[21] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrBirthDay == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrBirthDay == nil {
					z.PtrBirthDay = new(time.Time)
				}
				*z.PtrBirthDay, bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrPhone":
			found30zaba[22] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrPhone == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrPhone == nil {
					z.PtrPhone = new(string)
				}
				*z.PtrPhone, bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrSiblings":
			found30zaba[23] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrSiblings == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrSiblings == nil {
					z.PtrSiblings = new(int)
				}
				*z.PtrSiblings, bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrSpouse":
			found30zaba[24] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrSpouse == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrSpouse == nil {
					z.PtrSpouse = new(bool)
				}
				*z.PtrSpouse, bts, err = nbs.ReadBoolBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrMoney":
			found30zaba[25] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrMoney == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrMoney == nil {
					z.PtrMoney = new(float64)
				}
				*z.PtrMoney, bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "Inside1":
			found30zaba[26] = true
			bts, err = z.Inside1.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found30zaba[27] = true
			z.Greetings, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found30zaba[28] = true
			if nbs.AlwaysNil {
				if z.Bullwinkle != nil {
					z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bullwinkle {
						z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bullwinkle == nil {
						z.Bullwinkle = new(Rocky)
					}
					bts, err = z.Bullwinkle.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss30zaba != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestOmitEmpty
var unmarshalMsgFieldOrder30zaba = []string{"Name", "BirthDay", "Phone", "Siblings", "Spouse", "Money", "SliceName", "SliceBirthDay", "SlicePhone", "SliceSiblings", "SliceSpouse", "SliceMoney", "ArrayName", "ArrayBirthDay", "ArrayPhone", "ArraySiblings", "ArraySpouse", "ArrayMoney", "MapStringString", "MapStringIface", "PtrName", "PtrBirthDay", "PtrPhone", "PtrSiblings", "PtrSpouse", "PtrMoney", "Inside1", "Greetings", "Bullwinkle"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestOmitEmpty) Msgsize() (s int) {
	s = 3 + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.TimeSize + 6 + msgp.StringPrefixSize + len(z.Phone) + 9 + msgp.IntSize + 7 + msgp.BoolSize + 6 + msgp.Float64Size + 10 + msgp.ArrayHeaderSize
	for zicx := range z.SliceName {
		s += msgp.StringPrefixSize + len(z.SliceName[zicx])
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.SliceBirthDay) * (msgp.TimeSize)) + 11 + msgp.ArrayHeaderSize
	for zakp := range z.SlicePhone {
		s += msgp.StringPrefixSize + len(z.SlicePhone[zakp])
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.SliceSiblings) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.SliceSpouse) * (msgp.BoolSize)) + 11 + msgp.ArrayHeaderSize + (len(z.SliceMoney) * (msgp.Float64Size)) + 10 + msgp.ArrayHeaderSize
	for zjua := range z.ArrayName {
		s += msgp.StringPrefixSize + len(z.ArrayName[zjua])
	}
	s += 14 + msgp.ArrayHeaderSize + (3 * (msgp.TimeSize)) + 11 + msgp.ArrayHeaderSize
	for zreb := range z.ArrayPhone {
		s += msgp.StringPrefixSize + len(z.ArrayPhone[zreb])
	}
	s += 14 + msgp.ArrayHeaderSize + (3 * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (3 * (msgp.BoolSize)) + 11 + msgp.ArrayHeaderSize + (3 * (msgp.Float64Size)) + 16 + msgp.MapHeaderSize
	if z.MapStringString != nil {
		for zaxt, zwua := range z.MapStringString {
			_ = zwua
			s += msgp.StringPrefixSize + len(zaxt) + msgp.StringPrefixSize + len(zwua)
		}
	}
	s += 15 + msgp.MapHeaderSize
	if z.MapStringIface != nil {
		for zuiu, zshv := range z.MapStringIface {
			_ = zshv
			s += msgp.StringPrefixSize + len(zuiu) + msgp.GuessSize(zshv)
		}
	}
	s += 8
	if z.PtrName == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PtrName)
	}
	s += 12
	if z.PtrBirthDay == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 9
	if z.PtrPhone == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PtrPhone)
	}
	s += 12
	if z.PtrSiblings == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.PtrSpouse == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 9
	if z.PtrMoney == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 8 + z.Inside1.Msgsize() + 10 + msgp.StringPrefixSize + len(z.Greetings) + 11
	if z.Bullwinkle == nil {
		s += msgp.NilSize
	} else {
		s += z.Bullwinkle.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestType) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields31zozd = 11

	// -- templateDecodeMsg starts here--
	var totalEncodedFields31zozd uint32
	totalEncodedFields31zozd, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft31zozd := totalEncodedFields31zozd
	missingFieldsLeft31zozd := maxFields31zozd - totalEncodedFields31zozd

	var nextMiss31zozd int32 = -1
	var found31zozd [maxFields31zozd]bool
	var curField31zozd string

doneWithStruct31zozd:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft31zozd > 0 || missingFieldsLeft31zozd > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft31zozd, missingFieldsLeft31zozd, msgp.ShowFound(found31zozd[:]), decodeMsgFieldOrder31zozd)
		if encodedFieldsLeft31zozd > 0 {
			encodedFieldsLeft31zozd--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField31zozd = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss31zozd < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss31zozd = 0
			}
			for nextMiss31zozd < maxFields31zozd && found31zozd[nextMiss31zozd] {
				nextMiss31zozd++
			}
			if nextMiss31zozd == maxFields31zozd {
				// filled all the empty fields!
				break doneWithStruct31zozd
			}
			missingFieldsLeft31zozd--
			curField31zozd = decodeMsgFieldOrder31zozd[nextMiss31zozd]
		}
		fmt.Printf("switching on curField: '%v'\n", curField31zozd)
		switch curField31zozd {
		// -- templateDecodeMsg ends here --

		case "float":
			found31zozd[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.F == nil {
					z.F = new(float64)
				}
				*z.F, err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "elements":
			found31zozd[1] = true
			var zfvk uint32
			zfvk, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Els == nil && zfvk > 0 {
				z.Els = make(map[string]string, zfvk)
			} else if len(z.Els) > 0 {
				for key, _ := range z.Els {
					delete(z.Els, key)
				}
			}
			for zfvk > 0 {
				zfvk--
				var zcet string
				var zrrz string
				zcet, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zrrz, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Els[zcet] = zrrz
			}
		case "object":
			found31zozd[2] = true
			const maxFields32zoev = 2

			// -- templateDecodeMsg starts here--
			var totalEncodedFields32zoev uint32
			totalEncodedFields32zoev, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft32zoev := totalEncodedFields32zoev
			missingFieldsLeft32zoev := maxFields32zoev - totalEncodedFields32zoev

			var nextMiss32zoev int32 = -1
			var found32zoev [maxFields32zoev]bool
			var curField32zoev string

		doneWithStruct32zoev:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft32zoev > 0 || missingFieldsLeft32zoev > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft32zoev, missingFieldsLeft32zoev, msgp.ShowFound(found32zoev[:]), decodeMsgFieldOrder32zoev)
				if encodedFieldsLeft32zoev > 0 {
					encodedFieldsLeft32zoev--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField32zoev = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss32zoev < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss32zoev = 0
					}
					for nextMiss32zoev < maxFields32zoev && found32zoev[nextMiss32zoev] {
						nextMiss32zoev++
					}
					if nextMiss32zoev == maxFields32zoev {
						// filled all the empty fields!
						break doneWithStruct32zoev
					}
					missingFieldsLeft32zoev--
					curField32zoev = decodeMsgFieldOrder32zoev[nextMiss32zoev]
				}
				fmt.Printf("switching on curField: '%v'\n", curField32zoev)
				switch curField32zoev {
				// -- templateDecodeMsg ends here --

				case "value_a":
					found32zoev[0] = true
					z.Obj.ValueA, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				case "value_b":
					found32zoev[1] = true
					z.Obj.ValueB, err = dc.ReadBytes(z.Obj.ValueB)
					if err != nil {
						panic(err)
					}
				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss32zoev != -1 {
				dc.PopAlwaysNil()
			}

		case "child":
			found31zozd[3] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Child != nil {
					dc.PushAlwaysNil()
					err = z.Child.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Child == nil {
					z.Child = new(TestType)
				}
				err = z.Child.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "time":
			found31zozd[4] = true
			z.Time, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "any":
			found31zozd[5] = true
			z.Any, err = dc.ReadIntf()
			if err != nil {
				panic(err)
			}
		case "appended":
			found31zozd[6] = true
			err = z.Appended.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "num":
			found31zozd[7] = true
			err = z.Num.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "Slice1":
			found31zozd[8] = true
			var zftp uint32
			zftp, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Slice1) >= int(zftp) {
				z.Slice1 = (z.Slice1)[:zftp]
			} else {
				z.Slice1 = make([]string, zftp)
			}
			for znnb := range z.Slice1 {
				z.Slice1[znnb], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "Slice2":
			found31zozd[9] = true
			var zaiw uint32
			zaiw, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Slice2) >= int(zaiw) {
				z.Slice2 = (z.Slice2)[:zaiw]
			} else {
				z.Slice2 = make([]string, zaiw)
			}
			for zncs := range z.Slice2 {
				z.Slice2[zncs], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SlicePtr":
			found31zozd[10] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				z.SlicePtr = nil
			} else {
				if z.SlicePtr == nil {
					z.SlicePtr = new([]string)
				}
				var zrba uint32
				zrba, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if cap(*z.SlicePtr) >= int(zrba) {
					*z.SlicePtr = (*z.SlicePtr)[:zrba]
				} else {
					*z.SlicePtr = make([]string, zrba)
				}
				for zfbl := range *z.SlicePtr {
					(*z.SlicePtr)[zfbl], err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss31zozd != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestType
var decodeMsgFieldOrder31zozd = []string{"float", "elements", "object", "child", "time", "any", "appended", "num", "Slice1", "Slice2", "SlicePtr"}

// fields of struct{;ValueA string;;ValueB []byte;;}
var decodeMsgFieldOrder32zoev = []string{"value_a", "value_b"}

// fieldsNotEmpty supports omitempty tags
func (z *TestType) fieldsNotEmpty(isempty []bool) uint32 {
	return 11
}

// EncodeMsg implements msgp.Encodable
func (z *TestType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "float"
	err = en.Append(0x8b, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74)
	if err != nil {
		return err
	}
	if z.F == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteFloat64(*z.F)
		if err != nil {
			panic(err)
		}
	}
	// write "elements"
	err = en.Append(0xa8, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Els)))
	if err != nil {
		panic(err)
	}
	for zcet, zrrz := range z.Els {
		err = en.WriteString(zcet)
		if err != nil {
			panic(err)
		}
		err = en.WriteString(zrrz)
		if err != nil {
			panic(err)
		}
	}
	// write "object"
	// map header, size 2
	// write "value_a"
	err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x82, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Obj.ValueA)
	if err != nil {
		panic(err)
	}
	// write "value_b"
	err = en.Append(0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Obj.ValueB)
	if err != nil {
		panic(err)
	}
	// write "child"
	err = en.Append(0xa5, 0x63, 0x68, 0x69, 0x6c, 0x64)
	if err != nil {
		return err
	}
	if z.Child == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Child.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "time"
	err = en.Append(0xa4, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteTime(z.Time)
	if err != nil {
		panic(err)
	}
	// write "any"
	err = en.Append(0xa3, 0x61, 0x6e, 0x79)
	if err != nil {
		return err
	}
	err = en.WriteIntf(z.Any)
	if err != nil {
		panic(err)
	}
	// write "appended"
	err = en.Append(0xa8, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x65, 0x64)
	if err != nil {
		return err
	}
	err = z.Appended.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	// write "num"
	err = en.Append(0xa3, 0x6e, 0x75, 0x6d)
	if err != nil {
		return err
	}
	err = z.Num.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	// write "Slice1"
	err = en.Append(0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x31)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice1)))
	if err != nil {
		panic(err)
	}
	for znnb := range z.Slice1 {
		err = en.WriteString(z.Slice1[znnb])
		if err != nil {
			panic(err)
		}
	}
	// write "Slice2"
	err = en.Append(0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x32)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice2)))
	if err != nil {
		panic(err)
	}
	for zncs := range z.Slice2 {
		err = en.WriteString(z.Slice2[zncs])
		if err != nil {
			panic(err)
		}
	}
	// write "SlicePtr"
	err = en.Append(0xa8, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x74, 0x72)
	if err != nil {
		return err
	}
	if z.SlicePtr == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteArrayHeader(uint32(len(*z.SlicePtr)))
		if err != nil {
			panic(err)
		}
		for zfbl := range *z.SlicePtr {
			err = en.WriteString((*z.SlicePtr)[zfbl])
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "float"
	o = append(o, 0x8b, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74)
	if z.F == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendFloat64(o, *z.F)
	}
	// string "elements"
	o = append(o, 0xa8, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Els)))
	for zcet, zrrz := range z.Els {
		o = msgp.AppendString(o, zcet)
		o = msgp.AppendString(o, zrrz)
	}
	// string "object"
	// map header, size 2
	// string "value_a"
	o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x82, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x61)
	o = msgp.AppendString(o, z.Obj.ValueA)
	// string "value_b"
	o = append(o, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62)
	o = msgp.AppendBytes(o, z.Obj.ValueB)
	// string "child"
	o = append(o, 0xa5, 0x63, 0x68, 0x69, 0x6c, 0x64)
	if z.Child == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Child.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "time"
	o = append(o, 0xa4, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Time)
	// string "any"
	o = append(o, 0xa3, 0x61, 0x6e, 0x79)
	o, err = msgp.AppendIntf(o, z.Any)
	if err != nil {
		panic(err)
	}
	// string "appended"
	o = append(o, 0xa8, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x65, 0x64)
	o, err = z.Appended.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	// string "num"
	o = append(o, 0xa3, 0x6e, 0x75, 0x6d)
	o, err = z.Num.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	// string "Slice1"
	o = append(o, 0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice1)))
	for znnb := range z.Slice1 {
		o = msgp.AppendString(o, z.Slice1[znnb])
	}
	// string "Slice2"
	o = append(o, 0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice2)))
	for zncs := range z.Slice2 {
		o = msgp.AppendString(o, z.Slice2[zncs])
	}
	// string "SlicePtr"
	o = append(o, 0xa8, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x74, 0x72)
	if z.SlicePtr == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.SlicePtr)))
		for zfbl := range *z.SlicePtr {
			o = msgp.AppendString(o, (*z.SlicePtr)[zfbl])
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	fmt.Printf("\n TestType.UnmarshalMsg() STARTING \n")
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		fmt.Printf("\n TestType.UnmarshalMsg setting sawTopNil  \n")
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields33zxvf = 11

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields33zxvf uint32
	if !nbs.AlwaysNil {
		totalEncodedFields33zxvf, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft33zxvf := totalEncodedFields33zxvf
	missingFieldsLeft33zxvf := maxFields33zxvf - totalEncodedFields33zxvf

	var nextMiss33zxvf int32 = -1
	var found33zxvf [maxFields33zxvf]bool
	var curField33zxvf string

doneWithStruct33zxvf:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft33zxvf > 0 || missingFieldsLeft33zxvf > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft33zxvf, missingFieldsLeft33zxvf, msgp.ShowFound(found33zxvf[:]), unmarshalMsgFieldOrder33zxvf)
		if encodedFieldsLeft33zxvf > 0 {
			encodedFieldsLeft33zxvf--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			fmt.Printf("\n just prior to curField33zxvf = msgp.UnsafeString(field='%v')\n", string(field))
			curField33zxvf = msgp.UnsafeString(field)
			fmt.Printf("\n just after to curField33zxvf = msgp.UnsafeString(field)\n")
		} else {
			//missing fields need handling
			if nextMiss33zxvf < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss33zxvf = 0
			}
			for nextMiss33zxvf < maxFields33zxvf && found33zxvf[nextMiss33zxvf] {
				nextMiss33zxvf++
			}
			if nextMiss33zxvf == maxFields33zxvf {
				// filled all the empty fields!
				break doneWithStruct33zxvf
			}
			missingFieldsLeft33zxvf--
			curField33zxvf = unmarshalMsgFieldOrder33zxvf[nextMiss33zxvf]
		}
		fmt.Printf("switching on curField: '%v'\n", curField33zxvf)
		switch curField33zxvf {
		// -- templateUnmarshalMsg ends here --

		case "float":
			found33zxvf[0] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.F == nil {
				// nothing more to do
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
				fmt.Printf("\n 'float' handling: nothing more to do... bts = '%#v'\n", bts)
			} else {
				// wire has bytes
				fmt.Printf("\n 'float' handling: wire has bytes... bts = '%#v'\n", bts)
				if z.F == nil {
					z.F = new(float64)
				}
				fmt.Printf("\n calling 'float' nbs.ReadFloat64Bytes(bts)\n")
				*z.F, bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "elements":
			found33zxvf[1] = true
			if nbs.AlwaysNil {
				if len(z.Els) > 0 {
					for key, _ := range z.Els {
						delete(z.Els, key)
					}
				}

			} else {

				var zixc uint32
				zixc, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Els == nil && zixc > 0 {
					z.Els = make(map[string]string, zixc)
				} else if len(z.Els) > 0 {
					for key, _ := range z.Els {
						delete(z.Els, key)
					}
				}
				for zixc > 0 {
					var zcet string
					var zrrz string
					zixc--
					zcet, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zrrz, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Els[zcet] = zrrz
				}
			}
		case "object":
			found33zxvf[2] = true
			const maxFields34zkkq = 2

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields34zkkq uint32
			if !nbs.AlwaysNil {
				totalEncodedFields34zkkq, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft34zkkq := totalEncodedFields34zkkq
			missingFieldsLeft34zkkq := maxFields34zkkq - totalEncodedFields34zkkq

			var nextMiss34zkkq int32 = -1
			var found34zkkq [maxFields34zkkq]bool
			var curField34zkkq string

		doneWithStruct34zkkq:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft34zkkq > 0 || missingFieldsLeft34zkkq > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft34zkkq, missingFieldsLeft34zkkq, msgp.ShowFound(found34zkkq[:]), unmarshalMsgFieldOrder34zkkq)
				if encodedFieldsLeft34zkkq > 0 {
					encodedFieldsLeft34zkkq--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField34zkkq = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss34zkkq < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss34zkkq = 0
					}
					for nextMiss34zkkq < maxFields34zkkq && found34zkkq[nextMiss34zkkq] {
						nextMiss34zkkq++
					}
					if nextMiss34zkkq == maxFields34zkkq {
						// filled all the empty fields!
						break doneWithStruct34zkkq
					}
					missingFieldsLeft34zkkq--
					curField34zkkq = unmarshalMsgFieldOrder34zkkq[nextMiss34zkkq]
				}
				fmt.Printf("switching on curField: '%v'\n", curField34zkkq)
				switch curField34zkkq {
				// -- templateUnmarshalMsg ends here --

				case "value_a":
					found34zkkq[0] = true
					z.Obj.ValueA, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				case "value_b":
					found34zkkq[1] = true
					if nbs.AlwaysNil || msgp.IsNil(bts) {
						if !nbs.AlwaysNil {
							bts = bts[1:]
						}
						z.Obj.ValueB = z.Obj.ValueB[:0]
					} else {
						z.Obj.ValueB, bts, err = nbs.ReadBytesBytes(bts, z.Obj.ValueB)

						if err != nil {
							panic(err)
						}
					}
					if err != nil {
						panic(err)
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss34zkkq != -1 {
				bts = nbs.PopAlwaysNil()
			}

		case "child":
			found33zxvf[3] = true
			if nbs.AlwaysNil {
				if z.Child != nil {
					z.Child.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Child {
						z.Child.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Child == nil {
						z.Child = new(TestType)
					}
					bts, err = z.Child.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "time":
			found33zxvf[4] = true
			z.Time, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "any":
			found33zxvf[5] = true
			z.Any, bts, err = nbs.ReadIntfBytes(bts)

			if err != nil {
				panic(err)
			}
		case "appended":
			found33zxvf[6] = true
			bts, err = z.Appended.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "num":
			found33zxvf[7] = true
			bts, err = z.Num.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "Slice1":
			found33zxvf[8] = true
			if nbs.AlwaysNil {
				(z.Slice1) = (z.Slice1)[:0]
			} else {

				var znmk uint32
				znmk, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Slice1) >= int(znmk) {
					z.Slice1 = (z.Slice1)[:znmk]
				} else {
					z.Slice1 = make([]string, znmk)
				}
				for znnb := range z.Slice1 {
					z.Slice1[znnb], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Slice2":
			found33zxvf[9] = true
			if nbs.AlwaysNil {
				(z.Slice2) = (z.Slice2)[:0]
			} else {

				var zmjr uint32
				zmjr, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Slice2) >= int(zmjr) {
					z.Slice2 = (z.Slice2)[:zmjr]
				} else {
					z.Slice2 = make([]string, zmjr)
				}
				for zncs := range z.Slice2 {
					z.Slice2[zncs], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SlicePtr":
			found33zxvf[10] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.SlicePtr == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.SlicePtr == nil {
					z.SlicePtr = new([]string)
				}
				if nbs.AlwaysNil {
					(*z.SlicePtr) = (*z.SlicePtr)[:0]
				} else {

					var zkpn uint32
					zkpn, bts, err = nbs.ReadArrayHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if cap(*z.SlicePtr) >= int(zkpn) {
						*z.SlicePtr = (*z.SlicePtr)[:zkpn]
					} else {
						*z.SlicePtr = make([]string, zkpn)
					}
					for zfbl := range *z.SlicePtr {
						(*z.SlicePtr)[zfbl], bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss33zxvf != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestType
var unmarshalMsgFieldOrder33zxvf = []string{"float", "elements", "object", "child", "time", "any", "appended", "num", "Slice1", "Slice2", "SlicePtr"}

// fields of struct{;ValueA string;;ValueB []byte;;}
var unmarshalMsgFieldOrder34zkkq = []string{"value_a", "value_b"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestType) Msgsize() (s int) {
	s = 1 + 6
	if z.F == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 9 + msgp.MapHeaderSize
	if z.Els != nil {
		for zcet, zrrz := range z.Els {
			_ = zrrz
			s += msgp.StringPrefixSize + len(zcet) + msgp.StringPrefixSize + len(zrrz)
		}
	}
	s += 7 + 1 + 8 + msgp.StringPrefixSize + len(z.Obj.ValueA) + 8 + msgp.BytesPrefixSize + len(z.Obj.ValueB) + 6
	if z.Child == nil {
		s += msgp.NilSize
	} else {
		s += z.Child.Msgsize()
	}
	s += 5 + msgp.TimeSize + 4 + msgp.GuessSize(z.Any) + 9 + z.Appended.Msgsize() + 4 + z.Num.Msgsize() + 7 + msgp.ArrayHeaderSize
	for znnb := range z.Slice1 {
		s += msgp.StringPrefixSize + len(z.Slice1[znnb])
	}
	s += 7 + msgp.ArrayHeaderSize
	for zncs := range z.Slice2 {
		s += msgp.StringPrefixSize + len(z.Slice2[zncs])
	}
	s += 9
	if z.SlicePtr == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for zfbl := range *z.SlicePtr {
			s += msgp.StringPrefixSize + len((*z.SlicePtr)[zfbl])
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Things) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields35znqi = 6

	// -- templateDecodeMsg starts here--
	var totalEncodedFields35znqi uint32
	totalEncodedFields35znqi, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft35znqi := totalEncodedFields35znqi
	missingFieldsLeft35znqi := maxFields35znqi - totalEncodedFields35znqi

	var nextMiss35znqi int32 = -1
	var found35znqi [maxFields35znqi]bool
	var curField35znqi string

doneWithStruct35znqi:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft35znqi > 0 || missingFieldsLeft35znqi > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft35znqi, missingFieldsLeft35znqi, msgp.ShowFound(found35znqi[:]), decodeMsgFieldOrder35znqi)
		if encodedFieldsLeft35znqi > 0 {
			encodedFieldsLeft35znqi--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField35znqi = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss35znqi < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss35znqi = 0
			}
			for nextMiss35znqi < maxFields35znqi && found35znqi[nextMiss35znqi] {
				nextMiss35znqi++
			}
			if nextMiss35znqi == maxFields35znqi {
				// filled all the empty fields!
				break doneWithStruct35znqi
			}
			missingFieldsLeft35znqi--
			curField35znqi = decodeMsgFieldOrder35znqi[nextMiss35znqi]
		}
		fmt.Printf("switching on curField: '%v'\n", curField35znqi)
		switch curField35znqi {
		// -- templateDecodeMsg ends here --

		case "complex":
			found35znqi[0] = true
			z.Cmplx, err = dc.ReadComplex64()
			if err != nil {
				panic(err)
			}
		case "values":
			found35znqi[1] = true
			var zarc uint32
			zarc, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Vals) >= int(zarc) {
				z.Vals = (z.Vals)[:zarc]
			} else {
				z.Vals = make([]int32, zarc)
			}
			for ztkv := range z.Vals {
				z.Vals[ztkv], err = dc.ReadInt32()
				if err != nil {
					panic(err)
				}
			}
		case "arr":
			found35znqi[2] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zban uint32
				zban, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zban != msgp.ExtensionPrefixSize {
					err = msgp.ArrayError{Wanted: msgp.ExtensionPrefixSize, Got: zban}
					return
				}
			}
			for zzfz := range z.Arr {
				z.Arr[zzfz], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "arr2":
			found35znqi[3] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zfxb uint32
				zfxb, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zfxb != 4 {
					err = msgp.ArrayError{Wanted: 4, Got: zfxb}
					return
				}
			}
			for zotr := range z.Arr2 {
				z.Arr2[zotr], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "ext":
			found35znqi[4] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				// we have an base.Value of Ext: replace the Ext iff already allocated

				if z.Ext != nil {
					z.Ext = new(msgp.RawExtension)
				}
			} else {
				// we have bytes in dc to read

				if z.Ext == nil {
					z.Ext = new(msgp.RawExtension)
				}
				if !dc.IsNil() {
					err = dc.ReadExtension(z.Ext)
				} else {
					err = dc.ReadNil()
				}

				if err != nil {
					panic(err)
				}
			}
		case "oext":
			found35znqi[5] = true
			if !dc.IsNil() {
				err = dc.ReadExtension(&z.Oext)
			} else {
				err = dc.ReadNil()
			}

			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss35znqi != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Things
var decodeMsgFieldOrder35znqi = []string{"complex", "values", "arr", "arr2", "ext", "oext"}

// fieldsNotEmpty supports omitempty tags
func (z *Things) fieldsNotEmpty(isempty []bool) uint32 {
	return 6
}

// EncodeMsg implements msgp.Encodable
func (z *Things) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "complex"
	err = en.Append(0x86, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78)
	if err != nil {
		return err
	}
	err = en.WriteComplex64(z.Cmplx)
	if err != nil {
		panic(err)
	}
	// write "values"
	err = en.Append(0xa6, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Vals)))
	if err != nil {
		panic(err)
	}
	for ztkv := range z.Vals {
		err = en.WriteInt32(z.Vals[ztkv])
		if err != nil {
			panic(err)
		}
	}
	// write "arr"
	err = en.Append(0xa3, 0x61, 0x72, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(msgp.ExtensionPrefixSize)
	if err != nil {
		panic(err)
	}
	for zzfz := range z.Arr {
		err = en.WriteFloat64(z.Arr[zzfz])
		if err != nil {
			panic(err)
		}
	}
	// write "arr2"
	err = en.Append(0xa4, 0x61, 0x72, 0x72, 0x32)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(4)
	if err != nil {
		panic(err)
	}
	for zotr := range z.Arr2 {
		err = en.WriteFloat64(z.Arr2[zotr])
		if err != nil {
			panic(err)
		}
	}
	// write "ext"
	err = en.Append(0xa3, 0x65, 0x78, 0x74)
	if err != nil {
		return err
	}
	if z.Ext == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteExtension(z.Ext)
		if err != nil {
			panic(err)
		}
	}
	// write "oext"
	err = en.Append(0xa4, 0x6f, 0x65, 0x78, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteExtension(&z.Oext)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Things) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "complex"
	o = append(o, 0x86, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78)
	o = msgp.AppendComplex64(o, z.Cmplx)
	// string "values"
	o = append(o, 0xa6, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Vals)))
	for ztkv := range z.Vals {
		o = msgp.AppendInt32(o, z.Vals[ztkv])
	}
	// string "arr"
	o = append(o, 0xa3, 0x61, 0x72, 0x72)
	o = msgp.AppendArrayHeader(o, msgp.ExtensionPrefixSize)
	for zzfz := range z.Arr {
		o = msgp.AppendFloat64(o, z.Arr[zzfz])
	}
	// string "arr2"
	o = append(o, 0xa4, 0x61, 0x72, 0x72, 0x32)
	o = msgp.AppendArrayHeader(o, 4)
	for zotr := range z.Arr2 {
		o = msgp.AppendFloat64(o, z.Arr2[zotr])
	}
	// string "ext"
	o = append(o, 0xa3, 0x65, 0x78, 0x74)
	if z.Ext == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = msgp.AppendExtension(o, z.Ext)
		if err != nil {
			panic(err)
		}
	}
	// string "oext"
	o = append(o, 0xa4, 0x6f, 0x65, 0x78, 0x74)
	o, err = msgp.AppendExtension(o, &z.Oext)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Things) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields36zxlj = 6

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields36zxlj uint32
	if !nbs.AlwaysNil {
		totalEncodedFields36zxlj, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft36zxlj := totalEncodedFields36zxlj
	missingFieldsLeft36zxlj := maxFields36zxlj - totalEncodedFields36zxlj

	var nextMiss36zxlj int32 = -1
	var found36zxlj [maxFields36zxlj]bool
	var curField36zxlj string

doneWithStruct36zxlj:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft36zxlj > 0 || missingFieldsLeft36zxlj > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft36zxlj, missingFieldsLeft36zxlj, msgp.ShowFound(found36zxlj[:]), unmarshalMsgFieldOrder36zxlj)
		if encodedFieldsLeft36zxlj > 0 {
			encodedFieldsLeft36zxlj--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField36zxlj = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss36zxlj < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss36zxlj = 0
			}
			for nextMiss36zxlj < maxFields36zxlj && found36zxlj[nextMiss36zxlj] {
				nextMiss36zxlj++
			}
			if nextMiss36zxlj == maxFields36zxlj {
				// filled all the empty fields!
				break doneWithStruct36zxlj
			}
			missingFieldsLeft36zxlj--
			curField36zxlj = unmarshalMsgFieldOrder36zxlj[nextMiss36zxlj]
		}
		fmt.Printf("switching on curField: '%v'\n", curField36zxlj)
		switch curField36zxlj {
		// -- templateUnmarshalMsg ends here --

		case "complex":
			found36zxlj[0] = true
			z.Cmplx, bts, err = nbs.ReadComplex64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "values":
			found36zxlj[1] = true
			if nbs.AlwaysNil {
				(z.Vals) = (z.Vals)[:0]
			} else {

				var zbux uint32
				zbux, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Vals) >= int(zbux) {
					z.Vals = (z.Vals)[:zbux]
				} else {
					z.Vals = make([]int32, zbux)
				}
				for ztkv := range z.Vals {
					z.Vals[ztkv], bts, err = nbs.ReadInt32Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "arr":
			found36zxlj[2] = true
			var zyvz uint32
			zyvz, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zyvz != msgp.ExtensionPrefixSize {
				err = msgp.ArrayError{Wanted: msgp.ExtensionPrefixSize, Got: zyvz}
				return
			}
			for zzfz := range z.Arr {
				z.Arr[zzfz], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "arr2":
			found36zxlj[3] = true
			var zxvh uint32
			zxvh, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zxvh != 4 {
				err = msgp.ArrayError{Wanted: 4, Got: zxvh}
				return
			}
			for zotr := range z.Arr2 {
				z.Arr2[zotr], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ext":
			found36zxlj[4] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				// don't try to re-use extension pointers
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Ext = nil
			} else {
				// we have data

				if z.Ext == nil {
					z.Ext = new(msgp.RawExtension)
				}
				bts, err = nbs.ReadExtensionBytes(bts, z.Ext)

				if err != nil {
					panic(err)
				}
			}
		case "oext":
			found36zxlj[5] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Oext = msgp.RawExtension{}
			} else {
				bts, err = nbs.ReadExtensionBytes(bts, &z.Oext)

				if err != nil {
					panic(err)
				}
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss36zxlj != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Things
var unmarshalMsgFieldOrder36zxlj = []string{"complex", "values", "arr", "arr2", "ext", "oext"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Things) Msgsize() (s int) {
	s = 1 + 8 + msgp.Complex64Size + 7 + msgp.ArrayHeaderSize + (len(z.Vals) * (msgp.Int32Size)) + 4 + msgp.ArrayHeaderSize + (msgp.ExtensionPrefixSize * (msgp.Float64Size)) + 5 + msgp.ArrayHeaderSize + (4 * (msgp.Float64Size)) + 4
	if z.Ext == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ExtensionPrefixSize + z.Ext.Len()
	}
	s += 5 + msgp.ExtensionPrefixSize + z.Oext.Len()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TopNester) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields37zsqv = 9

	// -- templateDecodeMsg starts here--
	var totalEncodedFields37zsqv uint32
	totalEncodedFields37zsqv, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft37zsqv := totalEncodedFields37zsqv
	missingFieldsLeft37zsqv := maxFields37zsqv - totalEncodedFields37zsqv

	var nextMiss37zsqv int32 = -1
	var found37zsqv [maxFields37zsqv]bool
	var curField37zsqv string

doneWithStruct37zsqv:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft37zsqv > 0 || missingFieldsLeft37zsqv > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft37zsqv, missingFieldsLeft37zsqv, msgp.ShowFound(found37zsqv[:]), decodeMsgFieldOrder37zsqv)
		if encodedFieldsLeft37zsqv > 0 {
			encodedFieldsLeft37zsqv--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField37zsqv = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss37zsqv < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss37zsqv = 0
			}
			for nextMiss37zsqv < maxFields37zsqv && found37zsqv[nextMiss37zsqv] {
				nextMiss37zsqv++
			}
			if nextMiss37zsqv == maxFields37zsqv {
				// filled all the empty fields!
				break doneWithStruct37zsqv
			}
			missingFieldsLeft37zsqv--
			curField37zsqv = decodeMsgFieldOrder37zsqv[nextMiss37zsqv]
		}
		fmt.Printf("switching on curField: '%v'\n", curField37zsqv)
		switch curField37zsqv {
		// -- templateDecodeMsg ends here --

		case "TopId":
			found37zsqv[0] = true
			z.TopId, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found37zsqv[1] = true
			z.Greetings, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found37zsqv[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bullwinkle != nil {
					dc.PushAlwaysNil()
					err = z.Bullwinkle.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bullwinkle == nil {
					z.Bullwinkle = new(Rocky)
				}
				err = z.Bullwinkle.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "MyIntArray":
			found37zsqv[3] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zjmy uint32
				zjmy, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zjmy != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zjmy}
					return
				}
			}
			for zehw := range z.MyIntArray {
				z.MyIntArray[zehw], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "MyByteArray":
			found37zsqv[4] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.MyByteArray[:])
			if err != nil {
				panic(err)
			}
		case "MyMap":
			found37zsqv[5] = true
			var zdgq uint32
			zdgq, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MyMap == nil && zdgq > 0 {
				z.MyMap = make(map[string]string, zdgq)
			} else if len(z.MyMap) > 0 {
				for key, _ := range z.MyMap {
					delete(z.MyMap, key)
				}
			}
			for zdgq > 0 {
				zdgq--
				var zqnk string
				var zkmx string
				zqnk, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zkmx, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.MyMap[zqnk] = zkmx
			}
		case "MyArrayMap":
			found37zsqv[6] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zekt uint32
				zekt, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zekt != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zekt}
					return
				}
			}
			for ztyg := range z.MyArrayMap {
				var zozq uint32
				zozq, err = dc.ReadMapHeader()
				if err != nil {
					panic(err)
				}
				if z.MyArrayMap[ztyg] == nil && zozq > 0 {
					z.MyArrayMap[ztyg] = make(map[string]string, zozq)
				} else if len(z.MyArrayMap[ztyg]) > 0 {
					for key, _ := range z.MyArrayMap[ztyg] {
						delete(z.MyArrayMap[ztyg], key)
					}
				}
				for zozq > 0 {
					zozq--
					var zpyt string
					var zzgy string
					zpyt, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
					zzgy, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
					z.MyArrayMap[ztyg][zpyt] = zzgy
				}
			}
		case "TopTime":
			found37zsqv[7] = true
			z.TopTime, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "PtrTime":
			found37zsqv[8] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrTime == nil {
					z.PtrTime = new(time.Time)
				}
				*z.PtrTime, err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss37zsqv != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TopNester
var decodeMsgFieldOrder37zsqv = []string{"TopId", "Greetings", "Bullwinkle", "MyIntArray", "MyByteArray", "MyMap", "MyArrayMap", "TopTime", "PtrTime"}

// fieldsNotEmpty supports omitempty tags
func (z *TopNester) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 9
	}
	var fieldsInUse uint32 = 9
	isempty[1] = (len(z.Greetings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Bullwinkle == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.MyIntArray) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (len(z.MyByteArray) == 0) // string, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (len(z.MyMap) == 0) // string, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (len(z.MyArrayMap) == 0) // string, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (z.TopTime.IsZero()) // time.Time, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (z.PtrTime == nil) // pointer, omitempty
	if isempty[8] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *TopNester) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zejf [9]bool
	fieldsInUse_zcvp := z.fieldsNotEmpty(empty_zejf[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zcvp)
	if err != nil {
		return err
	}

	// write "TopId"
	err = en.Append(0xa5, 0x54, 0x6f, 0x70, 0x49, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.TopId)
	if err != nil {
		panic(err)
	}
	if !empty_zejf[1] {
		// write "Greetings"
		err = en.Append(0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Greetings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zejf[2] {
		// write "Bullwinkle"
		err = en.Append(0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if err != nil {
			return err
		}
		if z.Bullwinkle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullwinkle.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zejf[3] {
		// write "MyIntArray"
		err = en.Append(0xaa, 0x4d, 0x79, 0x49, 0x6e, 0x74, 0x41, 0x72, 0x72, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zehw := range z.MyIntArray {
			err = en.WriteInt(z.MyIntArray[zehw])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zejf[4] {
		// write "MyByteArray"
		err = en.Append(0xab, 0x4d, 0x79, 0x42, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteBytes(z.MyByteArray[:])
		if err != nil {
			panic(err)
		}
	}

	if !empty_zejf[5] {
		// write "MyMap"
		err = en.Append(0xa5, 0x4d, 0x79, 0x4d, 0x61, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MyMap)))
		if err != nil {
			panic(err)
		}
		for zqnk, zkmx := range z.MyMap {
			err = en.WriteString(zqnk)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zkmx)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zejf[6] {
		// write "MyArrayMap"
		err = en.Append(0xaa, 0x4d, 0x79, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x61, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for ztyg := range z.MyArrayMap {
			err = en.WriteMapHeader(uint32(len(z.MyArrayMap[ztyg])))
			if err != nil {
				panic(err)
			}
			for zpyt, zzgy := range z.MyArrayMap[ztyg] {
				err = en.WriteString(zpyt)
				if err != nil {
					panic(err)
				}
				err = en.WriteString(zzgy)
				if err != nil {
					panic(err)
				}
			}
		}
	}

	if !empty_zejf[7] {
		// write "TopTime"
		err = en.Append(0xa7, 0x54, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteTime(z.TopTime)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zejf[8] {
		// write "PtrTime"
		err = en.Append(0xa7, 0x50, 0x74, 0x72, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return err
		}
		if z.PtrTime == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteTime(*z.PtrTime)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TopNester) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [9]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "TopId"
	o = append(o, 0xa5, 0x54, 0x6f, 0x70, 0x49, 0x64)
	o = msgp.AppendInt(o, z.TopId)
	if !empty[1] {
		// string "Greetings"
		o = append(o, 0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendString(o, z.Greetings)
	}

	if !empty[2] {
		// string "Bullwinkle"
		o = append(o, 0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if z.Bullwinkle == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullwinkle.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[3] {
		// string "MyIntArray"
		o = append(o, 0xaa, 0x4d, 0x79, 0x49, 0x6e, 0x74, 0x41, 0x72, 0x72, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zehw := range z.MyIntArray {
			o = msgp.AppendInt(o, z.MyIntArray[zehw])
		}
	}

	if !empty[4] {
		// string "MyByteArray"
		o = append(o, 0xab, 0x4d, 0x79, 0x42, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79)
		o = msgp.AppendBytes(o, z.MyByteArray[:])
	}

	if !empty[5] {
		// string "MyMap"
		o = append(o, 0xa5, 0x4d, 0x79, 0x4d, 0x61, 0x70)
		o = msgp.AppendMapHeader(o, uint32(len(z.MyMap)))
		for zqnk, zkmx := range z.MyMap {
			o = msgp.AppendString(o, zqnk)
			o = msgp.AppendString(o, zkmx)
		}
	}

	if !empty[6] {
		// string "MyArrayMap"
		o = append(o, 0xaa, 0x4d, 0x79, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x61, 0x70)
		o = msgp.AppendArrayHeader(o, 3)
		for ztyg := range z.MyArrayMap {
			o = msgp.AppendMapHeader(o, uint32(len(z.MyArrayMap[ztyg])))
			for zpyt, zzgy := range z.MyArrayMap[ztyg] {
				o = msgp.AppendString(o, zpyt)
				o = msgp.AppendString(o, zzgy)
			}
		}
	}

	if !empty[7] {
		// string "TopTime"
		o = append(o, 0xa7, 0x54, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.TopTime)
	}

	if !empty[8] {
		// string "PtrTime"
		o = append(o, 0xa7, 0x50, 0x74, 0x72, 0x54, 0x69, 0x6d, 0x65)
		if z.PtrTime == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendTime(o, *z.PtrTime)
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TopNester) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields38ztfw = 9

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields38ztfw uint32
	if !nbs.AlwaysNil {
		totalEncodedFields38ztfw, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft38ztfw := totalEncodedFields38ztfw
	missingFieldsLeft38ztfw := maxFields38ztfw - totalEncodedFields38ztfw

	var nextMiss38ztfw int32 = -1
	var found38ztfw [maxFields38ztfw]bool
	var curField38ztfw string

doneWithStruct38ztfw:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft38ztfw > 0 || missingFieldsLeft38ztfw > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft38ztfw, missingFieldsLeft38ztfw, msgp.ShowFound(found38ztfw[:]), unmarshalMsgFieldOrder38ztfw)
		if encodedFieldsLeft38ztfw > 0 {
			encodedFieldsLeft38ztfw--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField38ztfw = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss38ztfw < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss38ztfw = 0
			}
			for nextMiss38ztfw < maxFields38ztfw && found38ztfw[nextMiss38ztfw] {
				nextMiss38ztfw++
			}
			if nextMiss38ztfw == maxFields38ztfw {
				// filled all the empty fields!
				break doneWithStruct38ztfw
			}
			missingFieldsLeft38ztfw--
			curField38ztfw = unmarshalMsgFieldOrder38ztfw[nextMiss38ztfw]
		}
		fmt.Printf("switching on curField: '%v'\n", curField38ztfw)
		switch curField38ztfw {
		// -- templateUnmarshalMsg ends here --

		case "TopId":
			found38ztfw[0] = true
			z.TopId, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Greetings":
			found38ztfw[1] = true
			z.Greetings, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found38ztfw[2] = true
			if nbs.AlwaysNil {
				if z.Bullwinkle != nil {
					z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bullwinkle {
						z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bullwinkle == nil {
						z.Bullwinkle = new(Rocky)
					}
					bts, err = z.Bullwinkle.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "MyIntArray":
			found38ztfw[3] = true
			var zlyg uint32
			zlyg, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zlyg != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zlyg}
				return
			}
			for zehw := range z.MyIntArray {
				z.MyIntArray[zehw], bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "MyByteArray":
			found38ztfw[4] = true
			bts, err = nbs.ReadExactBytes(bts, z.MyByteArray[:])
			if err != nil {
				panic(err)
			}
		case "MyMap":
			found38ztfw[5] = true
			if nbs.AlwaysNil {
				if len(z.MyMap) > 0 {
					for key, _ := range z.MyMap {
						delete(z.MyMap, key)
					}
				}

			} else {

				var zejg uint32
				zejg, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MyMap == nil && zejg > 0 {
					z.MyMap = make(map[string]string, zejg)
				} else if len(z.MyMap) > 0 {
					for key, _ := range z.MyMap {
						delete(z.MyMap, key)
					}
				}
				for zejg > 0 {
					var zqnk string
					var zkmx string
					zejg--
					zqnk, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zkmx, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MyMap[zqnk] = zkmx
				}
			}
		case "MyArrayMap":
			found38ztfw[6] = true
			var ztub uint32
			ztub, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && ztub != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: ztub}
				return
			}
			for ztyg := range z.MyArrayMap {
				if nbs.AlwaysNil {
					if len(z.MyArrayMap[ztyg]) > 0 {
						for key, _ := range z.MyArrayMap[ztyg] {
							delete(z.MyArrayMap[ztyg], key)
						}
					}

				} else {

					var zehs uint32
					zehs, bts, err = nbs.ReadMapHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if z.MyArrayMap[ztyg] == nil && zehs > 0 {
						z.MyArrayMap[ztyg] = make(map[string]string, zehs)
					} else if len(z.MyArrayMap[ztyg]) > 0 {
						for key, _ := range z.MyArrayMap[ztyg] {
							delete(z.MyArrayMap[ztyg], key)
						}
					}
					for zehs > 0 {
						var zpyt string
						var zzgy string
						zehs--
						zpyt, bts, err = nbs.ReadStringBytes(bts)
						if err != nil {
							panic(err)
						}
						zzgy, bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
						z.MyArrayMap[ztyg][zpyt] = zzgy
					}
				}
			}
		case "TopTime":
			found38ztfw[7] = true
			z.TopTime, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "PtrTime":
			found38ztfw[8] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrTime == nil {
				// nothing more to do
			} else {
				// wire has bytes

				if z.PtrTime == nil {
					z.PtrTime = new(time.Time)
				}
				*z.PtrTime, bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss38ztfw != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TopNester
var unmarshalMsgFieldOrder38ztfw = []string{"TopId", "Greetings", "Bullwinkle", "MyIntArray", "MyByteArray", "MyMap", "MyArrayMap", "TopTime", "PtrTime"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TopNester) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 10 + msgp.StringPrefixSize + len(z.Greetings) + 11
	if z.Bullwinkle == nil {
		s += msgp.NilSize
	} else {
		s += z.Bullwinkle.Msgsize()
	}
	s += 11 + msgp.ArrayHeaderSize + (3 * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (3 * (msgp.ByteSize)) + 6 + msgp.MapHeaderSize
	if z.MyMap != nil {
		for zqnk, zkmx := range z.MyMap {
			_ = zkmx
			s += msgp.StringPrefixSize + len(zqnk) + msgp.StringPrefixSize + len(zkmx)
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for ztyg := range z.MyArrayMap {
		s += msgp.MapHeaderSize
		if z.MyArrayMap[ztyg] != nil {
			for zpyt, zzgy := range z.MyArrayMap[ztyg] {
				_ = zzgy
				s += msgp.StringPrefixSize + len(zpyt) + msgp.StringPrefixSize + len(zzgy)
			}
		}
	}
	s += 8 + msgp.TimeSize + 8
	if z.PtrTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *X) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields39zxdb = 5

	// -- templateDecodeMsg starts here--
	var totalEncodedFields39zxdb uint32
	totalEncodedFields39zxdb, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft39zxdb := totalEncodedFields39zxdb
	missingFieldsLeft39zxdb := maxFields39zxdb - totalEncodedFields39zxdb

	var nextMiss39zxdb int32 = -1
	var found39zxdb [maxFields39zxdb]bool
	var curField39zxdb string

doneWithStruct39zxdb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft39zxdb > 0 || missingFieldsLeft39zxdb > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft39zxdb, missingFieldsLeft39zxdb, msgp.ShowFound(found39zxdb[:]), decodeMsgFieldOrder39zxdb)
		if encodedFieldsLeft39zxdb > 0 {
			encodedFieldsLeft39zxdb--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField39zxdb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss39zxdb < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss39zxdb = 0
			}
			for nextMiss39zxdb < maxFields39zxdb && found39zxdb[nextMiss39zxdb] {
				nextMiss39zxdb++
			}
			if nextMiss39zxdb == maxFields39zxdb {
				// filled all the empty fields!
				break doneWithStruct39zxdb
			}
			missingFieldsLeft39zxdb--
			curField39zxdb = decodeMsgFieldOrder39zxdb[nextMiss39zxdb]
		}
		fmt.Printf("switching on curField: '%v'\n", curField39zxdb)
		switch curField39zxdb {
		// -- templateDecodeMsg ends here --

		case "Values":
			found39zxdb[0] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.Values[:])
			if err != nil {
				panic(err)
			}
		case "More":
			found39zxdb[1] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.More[:])
			if err != nil {
				panic(err)
			}
		case "Others":
			found39zxdb[2] = true
			var zdhg uint32
			zdhg, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Others) >= int(zdhg) {
				z.Others = (z.Others)[:zdhg]
			} else {
				z.Others = make([][32]int32, zdhg)
			}
			for zmzn := range z.Others {
				if dc.AlwaysNil {
					// nothing more here
				} else if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}
				} else {

					var zrkt uint32
					zrkt, err = dc.ReadArrayHeader()
					if err != nil {
						panic(err)
					}
					if !dc.IsNil() && zrkt != 32 {
						err = msgp.ArrayError{Wanted: 32, Got: zrkt}
						return
					}
				}
				for zspl := range z.Others[zmzn] {
					z.Others[zmzn][zspl], err = dc.ReadInt32()
					if err != nil {
						panic(err)
					}
				}
			}
		case "Matrix":
			found39zxdb[3] = true
			var ztwk uint32
			ztwk, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Matrix) >= int(ztwk) {
				z.Matrix = (z.Matrix)[:ztwk]
			} else {
				z.Matrix = make([][]int32, ztwk)
			}
			for zksy := range z.Matrix {
				var zbmn uint32
				zbmn, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if cap(z.Matrix[zksy]) >= int(zbmn) {
					z.Matrix[zksy] = (z.Matrix[zksy])[:zbmn]
				} else {
					z.Matrix[zksy] = make([]int32, zbmn)
				}
				for zqct := range z.Matrix[zksy] {
					z.Matrix[zksy][zqct], err = dc.ReadInt32()
					if err != nil {
						panic(err)
					}
				}
			}
		case "ManyFixed":
			found39zxdb[4] = true
			var zrww uint32
			zrww, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.ManyFixed) >= int(zrww) {
				z.ManyFixed = (z.ManyFixed)[:zrww]
			} else {
				z.ManyFixed = make([]Fixed, zrww)
			}
			for zsvy := range z.ManyFixed {
				const maxFields40zmgv = 2

				// -- templateDecodeMsg starts here--
				var totalEncodedFields40zmgv uint32
				totalEncodedFields40zmgv, err = dc.ReadMapHeader()
				if err != nil {
					return
				}
				encodedFieldsLeft40zmgv := totalEncodedFields40zmgv
				missingFieldsLeft40zmgv := maxFields40zmgv - totalEncodedFields40zmgv

				var nextMiss40zmgv int32 = -1
				var found40zmgv [maxFields40zmgv]bool
				var curField40zmgv string

			doneWithStruct40zmgv:
				// First fill all the encoded fields, then
				// treat the remaining, missing fields, as Nil.
				for encodedFieldsLeft40zmgv > 0 || missingFieldsLeft40zmgv > 0 {
					fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft40zmgv, missingFieldsLeft40zmgv, msgp.ShowFound(found40zmgv[:]), decodeMsgFieldOrder40zmgv)
					if encodedFieldsLeft40zmgv > 0 {
						encodedFieldsLeft40zmgv--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							return
						}
						curField40zmgv = msgp.UnsafeString(field)
					} else {
						//missing fields need handling
						if nextMiss40zmgv < 0 {
							// tell the reader to only give us Nils
							// until further notice.
							dc.PushAlwaysNil()
							nextMiss40zmgv = 0
						}
						for nextMiss40zmgv < maxFields40zmgv && found40zmgv[nextMiss40zmgv] {
							nextMiss40zmgv++
						}
						if nextMiss40zmgv == maxFields40zmgv {
							// filled all the empty fields!
							break doneWithStruct40zmgv
						}
						missingFieldsLeft40zmgv--
						curField40zmgv = decodeMsgFieldOrder40zmgv[nextMiss40zmgv]
					}
					fmt.Printf("switching on curField: '%v'\n", curField40zmgv)
					switch curField40zmgv {
					// -- templateDecodeMsg ends here --

					case "A":
						found40zmgv[0] = true
						z.ManyFixed[zsvy].A, err = dc.ReadFloat64()
						if err != nil {
							panic(err)
						}
					case "B":
						found40zmgv[1] = true
						z.ManyFixed[zsvy].B, err = dc.ReadBool()
						if err != nil {
							panic(err)
						}
					default:
						err = dc.Skip()
						if err != nil {
							panic(err)
						}
					}
				}
				if nextMiss40zmgv != -1 {
					dc.PopAlwaysNil()
				}

			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss39zxdb != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of X
var decodeMsgFieldOrder39zxdb = []string{"Values", "More", "Others", "Matrix", "ManyFixed"}

// fields of Fixed
var decodeMsgFieldOrder40zmgv = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z *X) fieldsNotEmpty(isempty []bool) uint32 {
	return 5
}

// EncodeMsg implements msgp.Encodable
func (z *X) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "Values"
	err = en.Append(0x85, 0xa6, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Values[:])
	if err != nil {
		panic(err)
	}
	// write "More"
	err = en.Append(0xa4, 0x4d, 0x6f, 0x72, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.More[:])
	if err != nil {
		panic(err)
	}
	// write "Others"
	err = en.Append(0xa6, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Others)))
	if err != nil {
		panic(err)
	}
	for zmzn := range z.Others {
		err = en.WriteArrayHeader(32)
		if err != nil {
			panic(err)
		}
		for zspl := range z.Others[zmzn] {
			err = en.WriteInt32(z.Others[zmzn][zspl])
			if err != nil {
				panic(err)
			}
		}
	}
	// write "Matrix"
	err = en.Append(0xa6, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Matrix)))
	if err != nil {
		panic(err)
	}
	for zksy := range z.Matrix {
		err = en.WriteArrayHeader(uint32(len(z.Matrix[zksy])))
		if err != nil {
			panic(err)
		}
		for zqct := range z.Matrix[zksy] {
			err = en.WriteInt32(z.Matrix[zksy][zqct])
			if err != nil {
				panic(err)
			}
		}
	}
	// write "ManyFixed"
	err = en.Append(0xa9, 0x4d, 0x61, 0x6e, 0x79, 0x46, 0x69, 0x78, 0x65, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.ManyFixed)))
	if err != nil {
		panic(err)
	}
	for zsvy := range z.ManyFixed {
		// map header, size 2
		// write "A"
		err = en.Append(0x82, 0xa1, 0x41)
		if err != nil {
			return err
		}
		err = en.WriteFloat64(z.ManyFixed[zsvy].A)
		if err != nil {
			panic(err)
		}
		// write "B"
		err = en.Append(0xa1, 0x42)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.ManyFixed[zsvy].B)
		if err != nil {
			panic(err)
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *X) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "Values"
	o = append(o, 0x85, 0xa6, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendBytes(o, z.Values[:])
	// string "More"
	o = append(o, 0xa4, 0x4d, 0x6f, 0x72, 0x65)
	o = msgp.AppendBytes(o, z.More[:])
	// string "Others"
	o = append(o, 0xa6, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Others)))
	for zmzn := range z.Others {
		o = msgp.AppendArrayHeader(o, 32)
		for zspl := range z.Others[zmzn] {
			o = msgp.AppendInt32(o, z.Others[zmzn][zspl])
		}
	}
	// string "Matrix"
	o = append(o, 0xa6, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Matrix)))
	for zksy := range z.Matrix {
		o = msgp.AppendArrayHeader(o, uint32(len(z.Matrix[zksy])))
		for zqct := range z.Matrix[zksy] {
			o = msgp.AppendInt32(o, z.Matrix[zksy][zqct])
		}
	}
	// string "ManyFixed"
	o = append(o, 0xa9, 0x4d, 0x61, 0x6e, 0x79, 0x46, 0x69, 0x78, 0x65, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ManyFixed)))
	for zsvy := range z.ManyFixed {
		// map header, size 2
		// string "A"
		o = append(o, 0x82, 0xa1, 0x41)
		o = msgp.AppendFloat64(o, z.ManyFixed[zsvy].A)
		// string "B"
		o = append(o, 0xa1, 0x42)
		o = msgp.AppendBool(o, z.ManyFixed[zsvy].B)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *X) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields41zszz = 5

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields41zszz uint32
	if !nbs.AlwaysNil {
		totalEncodedFields41zszz, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft41zszz := totalEncodedFields41zszz
	missingFieldsLeft41zszz := maxFields41zszz - totalEncodedFields41zszz

	var nextMiss41zszz int32 = -1
	var found41zszz [maxFields41zszz]bool
	var curField41zszz string

doneWithStruct41zszz:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft41zszz > 0 || missingFieldsLeft41zszz > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft41zszz, missingFieldsLeft41zszz, msgp.ShowFound(found41zszz[:]), unmarshalMsgFieldOrder41zszz)
		if encodedFieldsLeft41zszz > 0 {
			encodedFieldsLeft41zszz--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField41zszz = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss41zszz < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss41zszz = 0
			}
			for nextMiss41zszz < maxFields41zszz && found41zszz[nextMiss41zszz] {
				nextMiss41zszz++
			}
			if nextMiss41zszz == maxFields41zszz {
				// filled all the empty fields!
				break doneWithStruct41zszz
			}
			missingFieldsLeft41zszz--
			curField41zszz = unmarshalMsgFieldOrder41zszz[nextMiss41zszz]
		}
		fmt.Printf("switching on curField: '%v'\n", curField41zszz)
		switch curField41zszz {
		// -- templateUnmarshalMsg ends here --

		case "Values":
			found41zszz[0] = true
			bts, err = nbs.ReadExactBytes(bts, z.Values[:])
			if err != nil {
				panic(err)
			}
		case "More":
			found41zszz[1] = true
			bts, err = nbs.ReadExactBytes(bts, z.More[:])
			if err != nil {
				panic(err)
			}
		case "Others":
			found41zszz[2] = true
			if nbs.AlwaysNil {
				(z.Others) = (z.Others)[:0]
			} else {

				var zxei uint32
				zxei, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Others) >= int(zxei) {
					z.Others = (z.Others)[:zxei]
				} else {
					z.Others = make([][32]int32, zxei)
				}
				for zmzn := range z.Others {
					var zofv uint32
					zofv, bts, err = nbs.ReadArrayHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if !nbs.IsNil(bts) && zofv != 32 {
						err = msgp.ArrayError{Wanted: 32, Got: zofv}
						return
					}
					for zspl := range z.Others[zmzn] {
						z.Others[zmzn][zspl], bts, err = nbs.ReadInt32Bytes(bts)

						if err != nil {
							panic(err)
						}
					}
				}
			}
		case "Matrix":
			found41zszz[3] = true
			if nbs.AlwaysNil {
				(z.Matrix) = (z.Matrix)[:0]
			} else {

				var znin uint32
				znin, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Matrix) >= int(znin) {
					z.Matrix = (z.Matrix)[:znin]
				} else {
					z.Matrix = make([][]int32, znin)
				}
				for zksy := range z.Matrix {
					if nbs.AlwaysNil {
						(z.Matrix[zksy]) = (z.Matrix[zksy])[:0]
					} else {

						var znta uint32
						znta, bts, err = nbs.ReadArrayHeaderBytes(bts)
						if err != nil {
							panic(err)
						}
						if cap(z.Matrix[zksy]) >= int(znta) {
							z.Matrix[zksy] = (z.Matrix[zksy])[:znta]
						} else {
							z.Matrix[zksy] = make([]int32, znta)
						}
						for zqct := range z.Matrix[zksy] {
							z.Matrix[zksy][zqct], bts, err = nbs.ReadInt32Bytes(bts)

							if err != nil {
								panic(err)
							}
						}
					}
				}
			}
		case "ManyFixed":
			found41zszz[4] = true
			if nbs.AlwaysNil {
				(z.ManyFixed) = (z.ManyFixed)[:0]
			} else {

				var zecw uint32
				zecw, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.ManyFixed) >= int(zecw) {
					z.ManyFixed = (z.ManyFixed)[:zecw]
				} else {
					z.ManyFixed = make([]Fixed, zecw)
				}
				for zsvy := range z.ManyFixed {
					const maxFields42zgbw = 2

					// -- templateUnmarshalMsg starts here--
					var totalEncodedFields42zgbw uint32
					if !nbs.AlwaysNil {
						totalEncodedFields42zgbw, bts, err = nbs.ReadMapHeaderBytes(bts)
						if err != nil {
							panic(err)
							return
						}
					}
					encodedFieldsLeft42zgbw := totalEncodedFields42zgbw
					missingFieldsLeft42zgbw := maxFields42zgbw - totalEncodedFields42zgbw

					var nextMiss42zgbw int32 = -1
					var found42zgbw [maxFields42zgbw]bool
					var curField42zgbw string

				doneWithStruct42zgbw:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft42zgbw > 0 || missingFieldsLeft42zgbw > 0 {
						fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft42zgbw, missingFieldsLeft42zgbw, msgp.ShowFound(found42zgbw[:]), unmarshalMsgFieldOrder42zgbw)
						if encodedFieldsLeft42zgbw > 0 {
							encodedFieldsLeft42zgbw--
							field, bts, err = nbs.ReadMapKeyZC(bts)
							if err != nil {
								panic(err)
								return
							}
							curField42zgbw = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss42zgbw < 0 {
								// set bts to contain just mnil (0xc0)
								bts = nbs.PushAlwaysNil(bts)
								nextMiss42zgbw = 0
							}
							for nextMiss42zgbw < maxFields42zgbw && found42zgbw[nextMiss42zgbw] {
								nextMiss42zgbw++
							}
							if nextMiss42zgbw == maxFields42zgbw {
								// filled all the empty fields!
								break doneWithStruct42zgbw
							}
							missingFieldsLeft42zgbw--
							curField42zgbw = unmarshalMsgFieldOrder42zgbw[nextMiss42zgbw]
						}
						fmt.Printf("switching on curField: '%v'\n", curField42zgbw)
						switch curField42zgbw {
						// -- templateUnmarshalMsg ends here --

						case "A":
							found42zgbw[0] = true
							z.ManyFixed[zsvy].A, bts, err = nbs.ReadFloat64Bytes(bts)

							if err != nil {
								panic(err)
							}
						case "B":
							found42zgbw[1] = true
							z.ManyFixed[zsvy].B, bts, err = nbs.ReadBoolBytes(bts)

							if err != nil {
								panic(err)
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								panic(err)
							}
						}
					}
					if nextMiss42zgbw != -1 {
						bts = nbs.PopAlwaysNil()
					}

				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss41zszz != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of X
var unmarshalMsgFieldOrder41zszz = []string{"Values", "More", "Others", "Matrix", "ManyFixed"}

// fields of Fixed
var unmarshalMsgFieldOrder42zgbw = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *X) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 5 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 7 + msgp.ArrayHeaderSize + (len(z.Others) * (32 * (msgp.Int32Size))) + 7 + msgp.ArrayHeaderSize
	for zksy := range z.Matrix {
		s += msgp.ArrayHeaderSize + (len(z.Matrix[zksy]) * (msgp.Int32Size))
	}
	s += 10 + msgp.ArrayHeaderSize + (len(z.ManyFixed) * (5 + msgp.Float64Size + msgp.BoolSize))
	return
}
