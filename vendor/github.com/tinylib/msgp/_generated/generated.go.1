package _generated

// NOTE: THIS FILE WAS PRODUCED BY THE
// MSGP CODE GENERATION TOOL (github.com/tinylib/msgp)
// DO NOT EDIT

import (
	"fmt"
	"time"

	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *AliasContainer) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields0zrom = 1

	// -- templateDecodeMsg starts here--
	var totalEncodedFields0zrom uint32
	totalEncodedFields0zrom, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft0zrom := totalEncodedFields0zrom
	missingFieldsLeft0zrom := maxFields0zrom - totalEncodedFields0zrom

	var nextMiss0zrom int32 = -1
	var found0zrom [maxFields0zrom]bool
	var curField0zrom string

doneWithStruct0zrom:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft0zrom > 0 || missingFieldsLeft0zrom > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft0zrom, missingFieldsLeft0zrom, msgp.ShowFound(found0zrom[:]), decodeMsgFieldOrder0zrom)
		if encodedFieldsLeft0zrom > 0 {
			encodedFieldsLeft0zrom--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField0zrom = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss0zrom < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss0zrom = 0
			}
			for nextMiss0zrom < maxFields0zrom && found0zrom[nextMiss0zrom] {
				nextMiss0zrom++
			}
			if nextMiss0zrom == maxFields0zrom {
				// filled all the empty fields!
				break doneWithStruct0zrom
			}
			missingFieldsLeft0zrom--
			curField0zrom = decodeMsgFieldOrder0zrom[nextMiss0zrom]
		}
		fmt.Printf("switching on curField: '%v'\n", curField0zrom)
		switch curField0zrom {
		// -- templateDecodeMsg ends here --

		case "Fast":
			found0zrom[0] = true
			err = z.Fast.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss0zrom != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of AliasContainer
var decodeMsgFieldOrder0zrom = []string{"Fast"}

// fieldsNotEmpty supports omitempty tags
func (z *AliasContainer) fieldsNotEmpty(isempty []bool) uint32 {
	return 1
}

// EncodeMsg implements msgp.Encodable
func (z *AliasContainer) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Fast"
	err = en.Append(0x81, 0xa4, 0x46, 0x61, 0x73, 0x74)
	if err != nil {
		return err
	}
	err = z.Fast.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AliasContainer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Fast"
	o = append(o, 0x81, 0xa4, 0x46, 0x61, 0x73, 0x74)
	o, err = z.Fast.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AliasContainer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields1zdbm = 1

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields1zdbm uint32
	if !nbs.AlwaysNil {
		totalEncodedFields1zdbm, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft1zdbm := totalEncodedFields1zdbm
	missingFieldsLeft1zdbm := maxFields1zdbm - totalEncodedFields1zdbm

	var nextMiss1zdbm int32 = -1
	var found1zdbm [maxFields1zdbm]bool
	var curField1zdbm string

doneWithStruct1zdbm:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft1zdbm > 0 || missingFieldsLeft1zdbm > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft1zdbm, missingFieldsLeft1zdbm, msgp.ShowFound(found1zdbm[:]), unmarshalMsgFieldOrder1zdbm)
		if encodedFieldsLeft1zdbm > 0 {
			encodedFieldsLeft1zdbm--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField1zdbm = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss1zdbm < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss1zdbm = 0
			}
			for nextMiss1zdbm < maxFields1zdbm && found1zdbm[nextMiss1zdbm] {
				nextMiss1zdbm++
			}
			if nextMiss1zdbm == maxFields1zdbm {
				// filled all the empty fields!
				break doneWithStruct1zdbm
			}
			missingFieldsLeft1zdbm--
			curField1zdbm = unmarshalMsgFieldOrder1zdbm[nextMiss1zdbm]
		}
		fmt.Printf("switching on curField: '%v'\n", curField1zdbm)
		switch curField1zdbm {
		// -- templateUnmarshalMsg ends here --

		case "Fast":
			found1zdbm[0] = true
			bts, err = z.Fast.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss1zdbm != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of AliasContainer
var unmarshalMsgFieldOrder1zdbm = []string{"Fast"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AliasContainer) Msgsize() (s int) {
	s = 1 + 5 + z.Fast.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Block) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	if dc.AlwaysNil {
		// nothing more here
	} else if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			return
		}
	}
	err = dc.ReadExactBytes(z[:])
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *Block) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes(z[:])
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Block) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, z[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Block) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	bts, err = nbs.ReadExactBytes(bts, z[:])
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Block) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Bunny) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields2zxhx = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields2zxhx uint32
	totalEncodedFields2zxhx, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft2zxhx := totalEncodedFields2zxhx
	missingFieldsLeft2zxhx := maxFields2zxhx - totalEncodedFields2zxhx

	var nextMiss2zxhx int32 = -1
	var found2zxhx [maxFields2zxhx]bool
	var curField2zxhx string

doneWithStruct2zxhx:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft2zxhx > 0 || missingFieldsLeft2zxhx > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft2zxhx, missingFieldsLeft2zxhx, msgp.ShowFound(found2zxhx[:]), decodeMsgFieldOrder2zxhx)
		if encodedFieldsLeft2zxhx > 0 {
			encodedFieldsLeft2zxhx--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField2zxhx = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss2zxhx < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss2zxhx = 0
			}
			for nextMiss2zxhx < maxFields2zxhx && found2zxhx[nextMiss2zxhx] {
				nextMiss2zxhx++
			}
			if nextMiss2zxhx == maxFields2zxhx {
				// filled all the empty fields!
				break doneWithStruct2zxhx
			}
			missingFieldsLeft2zxhx--
			curField2zxhx = decodeMsgFieldOrder2zxhx[nextMiss2zxhx]
		}
		fmt.Printf("switching on curField: '%v'\n", curField2zxhx)
		switch curField2zxhx {
		// -- templateDecodeMsg ends here --

		case "Carrots":
			found2zxhx[0] = true
			var zsnf uint32
			zsnf, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Carrots) >= int(zsnf) {
				z.Carrots = (z.Carrots)[:zsnf]
			} else {
				z.Carrots = make([]int, zsnf)
			}
			for ztgf := range z.Carrots {
				z.Carrots[ztgf], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "Sayings":
			found2zxhx[1] = true
			var zcfb uint32
			zcfb, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Sayings == nil && zcfb > 0 {
				z.Sayings = make(map[string]string, zcfb)
			} else if len(z.Sayings) > 0 {
				for key, _ := range z.Sayings {
					delete(z.Sayings, key)
				}
			}
			for zcfb > 0 {
				zcfb--
				var zwcv string
				var ztem string
				zwcv, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				ztem, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Sayings[zwcv] = ztem
			}
		case "BunnyId":
			found2zxhx[2] = true
			z.BunnyId, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss2zxhx != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Bunny
var decodeMsgFieldOrder2zxhx = []string{"Carrots", "Sayings", "BunnyId"}

// fieldsNotEmpty supports omitempty tags
func (z *Bunny) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (len(z.Carrots) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Sayings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.BunnyId == 0) // number, omitempty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Bunny) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zwvw [3]bool
	fieldsInUse_zspc := z.fieldsNotEmpty(empty_zwvw[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zspc)
	if err != nil {
		return err
	}

	if !empty_zwvw[0] {
		// write "Carrots"
		err = en.Append(0xa7, 0x43, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Carrots)))
		if err != nil {
			panic(err)
		}
		for ztgf := range z.Carrots {
			err = en.WriteInt(z.Carrots[ztgf])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zwvw[1] {
		// write "Sayings"
		err = en.Append(0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Sayings)))
		if err != nil {
			panic(err)
		}
		for zwcv, ztem := range z.Sayings {
			err = en.WriteString(zwcv)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(ztem)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zwvw[2] {
		// write "BunnyId"
		err = en.Append(0xa7, 0x42, 0x75, 0x6e, 0x6e, 0x79, 0x49, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.BunnyId)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Bunny) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Carrots"
		o = append(o, 0xa7, 0x43, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Carrots)))
		for ztgf := range z.Carrots {
			o = msgp.AppendInt(o, z.Carrots[ztgf])
		}
	}

	if !empty[1] {
		// string "Sayings"
		o = append(o, 0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Sayings)))
		for zwcv, ztem := range z.Sayings {
			o = msgp.AppendString(o, zwcv)
			o = msgp.AppendString(o, ztem)
		}
	}

	if !empty[2] {
		// string "BunnyId"
		o = append(o, 0xa7, 0x42, 0x75, 0x6e, 0x6e, 0x79, 0x49, 0x64)
		o = msgp.AppendInt(o, z.BunnyId)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bunny) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields3zatc = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields3zatc uint32
	if !nbs.AlwaysNil {
		totalEncodedFields3zatc, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft3zatc := totalEncodedFields3zatc
	missingFieldsLeft3zatc := maxFields3zatc - totalEncodedFields3zatc

	var nextMiss3zatc int32 = -1
	var found3zatc [maxFields3zatc]bool
	var curField3zatc string

doneWithStruct3zatc:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft3zatc > 0 || missingFieldsLeft3zatc > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft3zatc, missingFieldsLeft3zatc, msgp.ShowFound(found3zatc[:]), unmarshalMsgFieldOrder3zatc)
		if encodedFieldsLeft3zatc > 0 {
			encodedFieldsLeft3zatc--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField3zatc = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss3zatc < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss3zatc = 0
			}
			for nextMiss3zatc < maxFields3zatc && found3zatc[nextMiss3zatc] {
				nextMiss3zatc++
			}
			if nextMiss3zatc == maxFields3zatc {
				// filled all the empty fields!
				break doneWithStruct3zatc
			}
			missingFieldsLeft3zatc--
			curField3zatc = unmarshalMsgFieldOrder3zatc[nextMiss3zatc]
		}
		fmt.Printf("switching on curField: '%v'\n", curField3zatc)
		switch curField3zatc {
		// -- templateUnmarshalMsg ends here --

		case "Carrots":
			found3zatc[0] = true
			if nbs.AlwaysNil {
				(z.Carrots) = (z.Carrots)[:0]
			} else {

				var ziwl uint32
				ziwl, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Carrots) >= int(ziwl) {
					z.Carrots = (z.Carrots)[:ziwl]
				} else {
					z.Carrots = make([]int, ziwl)
				}
				for ztgf := range z.Carrots {
					z.Carrots[ztgf], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Sayings":
			found3zatc[1] = true
			if nbs.AlwaysNil {
				if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}

			} else {

				var zaeg uint32
				zaeg, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Sayings == nil && zaeg > 0 {
					z.Sayings = make(map[string]string, zaeg)
				} else if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}
				for zaeg > 0 {
					var zwcv string
					var ztem string
					zaeg--
					zwcv, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					ztem, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Sayings[zwcv] = ztem
				}
			}
		case "BunnyId":
			found3zatc[2] = true
			z.BunnyId, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss3zatc != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Bunny
var unmarshalMsgFieldOrder3zatc = []string{"Carrots", "Sayings", "BunnyId"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bunny) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize + (len(z.Carrots) * (msgp.IntSize)) + 8 + msgp.MapHeaderSize
	if z.Sayings != nil {
		for zwcv, ztem := range z.Sayings {
			_ = ztem
			s += msgp.StringPrefixSize + len(zwcv) + msgp.StringPrefixSize + len(ztem)
		}
	}
	s += 8 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Custom) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields4zsmr = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields4zsmr uint32
	totalEncodedFields4zsmr, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft4zsmr := totalEncodedFields4zsmr
	missingFieldsLeft4zsmr := maxFields4zsmr - totalEncodedFields4zsmr

	var nextMiss4zsmr int32 = -1
	var found4zsmr [maxFields4zsmr]bool
	var curField4zsmr string

doneWithStruct4zsmr:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft4zsmr > 0 || missingFieldsLeft4zsmr > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft4zsmr, missingFieldsLeft4zsmr, msgp.ShowFound(found4zsmr[:]), decodeMsgFieldOrder4zsmr)
		if encodedFieldsLeft4zsmr > 0 {
			encodedFieldsLeft4zsmr--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField4zsmr = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss4zsmr < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss4zsmr = 0
			}
			for nextMiss4zsmr < maxFields4zsmr && found4zsmr[nextMiss4zsmr] {
				nextMiss4zsmr++
			}
			if nextMiss4zsmr == maxFields4zsmr {
				// filled all the empty fields!
				break doneWithStruct4zsmr
			}
			missingFieldsLeft4zsmr--
			curField4zsmr = decodeMsgFieldOrder4zsmr[nextMiss4zsmr]
		}
		fmt.Printf("switching on curField: '%v'\n", curField4zsmr)
		switch curField4zsmr {
		// -- templateDecodeMsg ends here --

		case "bts":
			found4zsmr[0] = true
			{
				var zwtu []byte
				zwtu, err = dc.ReadBytes([]byte(z.Bts))
				z.Bts = CustomBytes(zwtu)
			}
			if err != nil {
				panic(err)
			}
		case "mp":
			found4zsmr[1] = true
			var zhmu uint32
			zhmu, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Mp == nil && zhmu > 0 {
				z.Mp = make(map[string]*Embedded, zhmu)
			} else if len(z.Mp) > 0 {
				for key, _ := range z.Mp {
					delete(z.Mp, key)
				}
			}
			for zhmu > 0 {
				zhmu--
				var ziza string
				var znff *Embedded
				ziza, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					if znff != nil {
						dc.PushAlwaysNil()
						err = znff.DecodeMsg(dc)
						if err != nil {
							return
						}
						dc.PopAlwaysNil()
					}
				} else {
					// not Nil, we have something to read

					if znff == nil {
						znff = new(Embedded)
					}
					err = znff.DecodeMsg(dc)
					if err != nil {
						panic(err)
					}
				}
				z.Mp[ziza] = znff
			}
		case "enums":
			found4zsmr[2] = true
			var zfpc uint32
			zfpc, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Enums) >= int(zfpc) {
				z.Enums = (z.Enums)[:zfpc]
			} else {
				z.Enums = make([]MyEnum, zfpc)
			}
			for zgju := range z.Enums {
				{
					var zfsy string
					zfsy, err = dc.ReadString()
					z.Enums[zgju] = myenumStr(zfsy)
				}
				if err != nil {
					panic(err)
				}
			}
		case "Some":
			found4zsmr[3] = true
			err = z.Some.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss4zsmr != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Custom
var decodeMsgFieldOrder4zsmr = []string{"bts", "mp", "enums", "Some"}

// fieldsNotEmpty supports omitempty tags
func (z *Custom) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Custom) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "bts"
	err = en.Append(0x84, 0xa3, 0x62, 0x74, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteBytes([]byte(z.Bts))
	if err != nil {
		panic(err)
	}
	// write "mp"
	err = en.Append(0xa2, 0x6d, 0x70)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Mp)))
	if err != nil {
		panic(err)
	}
	for ziza, znff := range z.Mp {
		err = en.WriteString(ziza)
		if err != nil {
			panic(err)
		}
		if znff == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = znff.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}
	// write "enums"
	err = en.Append(0xa5, 0x65, 0x6e, 0x75, 0x6d, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Enums)))
	if err != nil {
		panic(err)
	}
	for zgju := range z.Enums {
		err = en.WriteString((MyEnum).String(z.Enums[zgju]))
		if err != nil {
			panic(err)
		}
	}
	// write "Some"
	err = en.Append(0xa4, 0x53, 0x6f, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = z.Some.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Custom) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "bts"
	o = append(o, 0x84, 0xa3, 0x62, 0x74, 0x73)
	o = msgp.AppendBytes(o, []byte(z.Bts))
	// string "mp"
	o = append(o, 0xa2, 0x6d, 0x70)
	o = msgp.AppendMapHeader(o, uint32(len(z.Mp)))
	for ziza, znff := range z.Mp {
		o = msgp.AppendString(o, ziza)
		if znff == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = znff.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}
	// string "enums"
	o = append(o, 0xa5, 0x65, 0x6e, 0x75, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Enums)))
	for zgju := range z.Enums {
		o = msgp.AppendString(o, (MyEnum).String(z.Enums[zgju]))
	}
	// string "Some"
	o = append(o, 0xa4, 0x53, 0x6f, 0x6d, 0x65)
	o, err = z.Some.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Custom) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields5zuav = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields5zuav uint32
	if !nbs.AlwaysNil {
		totalEncodedFields5zuav, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft5zuav := totalEncodedFields5zuav
	missingFieldsLeft5zuav := maxFields5zuav - totalEncodedFields5zuav

	var nextMiss5zuav int32 = -1
	var found5zuav [maxFields5zuav]bool
	var curField5zuav string

doneWithStruct5zuav:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft5zuav > 0 || missingFieldsLeft5zuav > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft5zuav, missingFieldsLeft5zuav, msgp.ShowFound(found5zuav[:]), unmarshalMsgFieldOrder5zuav)
		if encodedFieldsLeft5zuav > 0 {
			encodedFieldsLeft5zuav--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField5zuav = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss5zuav < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss5zuav = 0
			}
			for nextMiss5zuav < maxFields5zuav && found5zuav[nextMiss5zuav] {
				nextMiss5zuav++
			}
			if nextMiss5zuav == maxFields5zuav {
				// filled all the empty fields!
				break doneWithStruct5zuav
			}
			missingFieldsLeft5zuav--
			curField5zuav = unmarshalMsgFieldOrder5zuav[nextMiss5zuav]
		}
		fmt.Printf("switching on curField: '%v'\n", curField5zuav)
		switch curField5zuav {
		// -- templateUnmarshalMsg ends here --

		case "bts":
			found5zuav[0] = true
			{
				var zzgl []byte
				if nbs.AlwaysNil || msgp.IsNil(bts) {
					if !nbs.AlwaysNil {
						bts = bts[1:]
					}
					zzgl = zzgl[:0]
				} else {
					zzgl, bts, err = nbs.ReadBytesBytes(bts, []byte(z.Bts))

					if err != nil {
						panic(err)
					}
				}
				if err != nil {
					panic(err)
				}
				z.Bts = CustomBytes(zzgl)
			}
		case "mp":
			found5zuav[1] = true
			if nbs.AlwaysNil {
				if len(z.Mp) > 0 {
					for key, _ := range z.Mp {
						delete(z.Mp, key)
					}
				}

			} else {

				var zrqv uint32
				zrqv, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Mp == nil && zrqv > 0 {
					z.Mp = make(map[string]*Embedded, zrqv)
				} else if len(z.Mp) > 0 {
					for key, _ := range z.Mp {
						delete(z.Mp, key)
					}
				}
				for zrqv > 0 {
					var ziza string
					var znff *Embedded
					zrqv--
					ziza, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					if nbs.AlwaysNil {
						if znff != nil {
							znff.UnmarshalMsg(msgp.OnlyNilSlice)
						}
					} else {
						// not nbs.AlwaysNil
						if msgp.IsNil(bts) {
							bts = bts[1:]
							if nil != znff {
								znff.UnmarshalMsg(msgp.OnlyNilSlice)
							}
						} else {
							// not nbs.AlwaysNil and not IsNil(bts): have something to read

							if znff == nil {
								znff = new(Embedded)
							}
							bts, err = znff.UnmarshalMsg(bts)
							if err != nil {
								panic(err)
							}
							if err != nil {
								panic(err)
							}
						}
					}
					z.Mp[ziza] = znff
				}
			}
		case "enums":
			found5zuav[2] = true
			if nbs.AlwaysNil {
				(z.Enums) = (z.Enums)[:0]
			} else {

				var zxnv uint32
				zxnv, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Enums) >= int(zxnv) {
					z.Enums = (z.Enums)[:zxnv]
				} else {
					z.Enums = make([]MyEnum, zxnv)
				}
				for zgju := range z.Enums {
					{
						var zjtx string
						zjtx, bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
						z.Enums[zgju] = myenumStr(zjtx)
					}
				}
			}
		case "Some":
			found5zuav[3] = true
			bts, err = z.Some.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss5zuav != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Custom
var unmarshalMsgFieldOrder5zuav = []string{"bts", "mp", "enums", "Some"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Custom) Msgsize() (s int) {
	s = 1 + 4 + msgp.BytesPrefixSize + len([]byte(z.Bts)) + 3 + msgp.MapHeaderSize
	if z.Mp != nil {
		for ziza, znff := range z.Mp {
			_ = znff
			s += msgp.StringPrefixSize + len(ziza)
			if znff == nil {
				s += msgp.NilSize
			} else {
				s += znff.Msgsize()
			}
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for zgju := range z.Enums {
		s += msgp.StringPrefixSize + len((MyEnum).String(z.Enums[zgju]))
	}
	s += 5 + z.Some.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *CustomBytes) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zudn []byte
		zudn, err = dc.ReadBytes([]byte((*z)))
		(*z) = CustomBytes(zudn)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z CustomBytes) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes([]byte(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CustomBytes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CustomBytes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zexf []byte
		if nbs.AlwaysNil || msgp.IsNil(bts) {
			if !nbs.AlwaysNil {
				bts = bts[1:]
			}
			zexf = zexf[:0]
		} else {
			zexf, bts, err = nbs.ReadBytesBytes(bts, []byte((*z)))

			if err != nil {
				panic(err)
			}
		}
		if err != nil {
			panic(err)
		}
		(*z) = CustomBytes(zexf)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CustomBytes) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *CustomInt) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zsun int
		zsun, err = dc.ReadInt()
		(*z) = CustomInt(zsun)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z CustomInt) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CustomInt) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CustomInt) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zmhu int
		zmhu, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = CustomInt(zmhu)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CustomInt) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Embedded) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields6zyuk = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields6zyuk uint32
	totalEncodedFields6zyuk, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft6zyuk := totalEncodedFields6zyuk
	missingFieldsLeft6zyuk := maxFields6zyuk - totalEncodedFields6zyuk

	var nextMiss6zyuk int32 = -1
	var found6zyuk [maxFields6zyuk]bool
	var curField6zyuk string

doneWithStruct6zyuk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft6zyuk > 0 || missingFieldsLeft6zyuk > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft6zyuk, missingFieldsLeft6zyuk, msgp.ShowFound(found6zyuk[:]), decodeMsgFieldOrder6zyuk)
		if encodedFieldsLeft6zyuk > 0 {
			encodedFieldsLeft6zyuk--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField6zyuk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss6zyuk < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss6zyuk = 0
			}
			for nextMiss6zyuk < maxFields6zyuk && found6zyuk[nextMiss6zyuk] {
				nextMiss6zyuk++
			}
			if nextMiss6zyuk == maxFields6zyuk {
				// filled all the empty fields!
				break doneWithStruct6zyuk
			}
			missingFieldsLeft6zyuk--
			curField6zyuk = decodeMsgFieldOrder6zyuk[nextMiss6zyuk]
		}
		fmt.Printf("switching on curField: '%v'\n", curField6zyuk)
		switch curField6zyuk {
		// -- templateDecodeMsg ends here --

		case "Embedded":
			found6zyuk[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Embedded != nil {
					dc.PushAlwaysNil()
					err = z.Embedded.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Embedded == nil {
					z.Embedded = new(Embedded)
				}
				err = z.Embedded.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "Children":
			found6zyuk[1] = true
			var zqot uint32
			zqot, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Children) >= int(zqot) {
				z.Children = (z.Children)[:zqot]
			} else {
				z.Children = make([]Embedded, zqot)
			}
			for zups := range z.Children {
				err = z.Children[zups].DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "PtrChildren":
			found6zyuk[2] = true
			var zrnc uint32
			zrnc, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.PtrChildren) >= int(zrnc) {
				z.PtrChildren = (z.PtrChildren)[:zrnc]
			} else {
				z.PtrChildren = make([]*Embedded, zrnc)
			}
			for zlsn := range z.PtrChildren {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					if z.PtrChildren[zlsn] != nil {
						dc.PushAlwaysNil()
						err = z.PtrChildren[zlsn].DecodeMsg(dc)
						if err != nil {
							return
						}
						dc.PopAlwaysNil()
					}
				} else {
					// not Nil, we have something to read

					if z.PtrChildren[zlsn] == nil {
						z.PtrChildren[zlsn] = new(Embedded)
					}
					err = z.PtrChildren[zlsn].DecodeMsg(dc)
					if err != nil {
						panic(err)
					}
				}
			}
		case "Other":
			found6zyuk[3] = true
			z.Other, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss6zyuk != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Embedded
var decodeMsgFieldOrder6zyuk = []string{"Embedded", "Children", "PtrChildren", "Other"}

// fieldsNotEmpty supports omitempty tags
func (z *Embedded) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Embedded) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Embedded"
	err = en.Append(0x84, 0xa8, 0x45, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64)
	if err != nil {
		return err
	}
	if z.Embedded == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Embedded.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "Children"
	err = en.Append(0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Children)))
	if err != nil {
		panic(err)
	}
	for zups := range z.Children {
		err = z.Children[zups].EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "PtrChildren"
	err = en.Append(0xab, 0x50, 0x74, 0x72, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.PtrChildren)))
	if err != nil {
		panic(err)
	}
	for zlsn := range z.PtrChildren {
		if z.PtrChildren[zlsn] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.PtrChildren[zlsn].EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}
	// write "Other"
	err = en.Append(0xa5, 0x4f, 0x74, 0x68, 0x65, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Other)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Embedded) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Embedded"
	o = append(o, 0x84, 0xa8, 0x45, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64)
	if z.Embedded == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Embedded.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "Children"
	o = append(o, 0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Children)))
	for zups := range z.Children {
		o, err = z.Children[zups].MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "PtrChildren"
	o = append(o, 0xab, 0x50, 0x74, 0x72, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PtrChildren)))
	for zlsn := range z.PtrChildren {
		if z.PtrChildren[zlsn] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.PtrChildren[zlsn].MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}
	// string "Other"
	o = append(o, 0xa5, 0x4f, 0x74, 0x68, 0x65, 0x72)
	o = msgp.AppendString(o, z.Other)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Embedded) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields7zsmo = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields7zsmo uint32
	if !nbs.AlwaysNil {
		totalEncodedFields7zsmo, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft7zsmo := totalEncodedFields7zsmo
	missingFieldsLeft7zsmo := maxFields7zsmo - totalEncodedFields7zsmo

	var nextMiss7zsmo int32 = -1
	var found7zsmo [maxFields7zsmo]bool
	var curField7zsmo string

doneWithStruct7zsmo:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft7zsmo > 0 || missingFieldsLeft7zsmo > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft7zsmo, missingFieldsLeft7zsmo, msgp.ShowFound(found7zsmo[:]), unmarshalMsgFieldOrder7zsmo)
		if encodedFieldsLeft7zsmo > 0 {
			encodedFieldsLeft7zsmo--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField7zsmo = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss7zsmo < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss7zsmo = 0
			}
			for nextMiss7zsmo < maxFields7zsmo && found7zsmo[nextMiss7zsmo] {
				nextMiss7zsmo++
			}
			if nextMiss7zsmo == maxFields7zsmo {
				// filled all the empty fields!
				break doneWithStruct7zsmo
			}
			missingFieldsLeft7zsmo--
			curField7zsmo = unmarshalMsgFieldOrder7zsmo[nextMiss7zsmo]
		}
		fmt.Printf("switching on curField: '%v'\n", curField7zsmo)
		switch curField7zsmo {
		// -- templateUnmarshalMsg ends here --

		case "Embedded":
			found7zsmo[0] = true
			if nbs.AlwaysNil {
				if z.Embedded != nil {
					z.Embedded.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Embedded {
						z.Embedded.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Embedded == nil {
						z.Embedded = new(Embedded)
					}
					bts, err = z.Embedded.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "Children":
			found7zsmo[1] = true
			if nbs.AlwaysNil {
				(z.Children) = (z.Children)[:0]
			} else {

				var zech uint32
				zech, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Children) >= int(zech) {
					z.Children = (z.Children)[:zech]
				} else {
					z.Children = make([]Embedded, zech)
				}
				for zups := range z.Children {
					bts, err = z.Children[zups].UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "PtrChildren":
			found7zsmo[2] = true
			if nbs.AlwaysNil {
				(z.PtrChildren) = (z.PtrChildren)[:0]
			} else {

				var zgao uint32
				zgao, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.PtrChildren) >= int(zgao) {
					z.PtrChildren = (z.PtrChildren)[:zgao]
				} else {
					z.PtrChildren = make([]*Embedded, zgao)
				}
				for zlsn := range z.PtrChildren {
					if nbs.AlwaysNil {
						if z.PtrChildren[zlsn] != nil {
							z.PtrChildren[zlsn].UnmarshalMsg(msgp.OnlyNilSlice)
						}
					} else {
						// not nbs.AlwaysNil
						if msgp.IsNil(bts) {
							bts = bts[1:]
							if nil != z.PtrChildren[zlsn] {
								z.PtrChildren[zlsn].UnmarshalMsg(msgp.OnlyNilSlice)
							}
						} else {
							// not nbs.AlwaysNil and not IsNil(bts): have something to read

							if z.PtrChildren[zlsn] == nil {
								z.PtrChildren[zlsn] = new(Embedded)
							}
							bts, err = z.PtrChildren[zlsn].UnmarshalMsg(bts)
							if err != nil {
								panic(err)
							}
							if err != nil {
								panic(err)
							}
						}
					}
				}
			}
		case "Other":
			found7zsmo[3] = true
			z.Other, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss7zsmo != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Embedded
var unmarshalMsgFieldOrder7zsmo = []string{"Embedded", "Children", "PtrChildren", "Other"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Embedded) Msgsize() (s int) {
	s = 1 + 9
	if z.Embedded == nil {
		s += msgp.NilSize
	} else {
		s += z.Embedded.Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for zups := range z.Children {
		s += z.Children[zups].Msgsize()
	}
	s += 12 + msgp.ArrayHeaderSize
	for zlsn := range z.PtrChildren {
		if z.PtrChildren[zlsn] == nil {
			s += msgp.NilSize
		} else {
			s += z.PtrChildren[zlsn].Msgsize()
		}
	}
	s += 6 + msgp.StringPrefixSize + len(z.Other)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *FastAlias) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields8zqvr = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields8zqvr uint32
	totalEncodedFields8zqvr, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft8zqvr := totalEncodedFields8zqvr
	missingFieldsLeft8zqvr := maxFields8zqvr - totalEncodedFields8zqvr

	var nextMiss8zqvr int32 = -1
	var found8zqvr [maxFields8zqvr]bool
	var curField8zqvr string

doneWithStruct8zqvr:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft8zqvr > 0 || missingFieldsLeft8zqvr > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft8zqvr, missingFieldsLeft8zqvr, msgp.ShowFound(found8zqvr[:]), decodeMsgFieldOrder8zqvr)
		if encodedFieldsLeft8zqvr > 0 {
			encodedFieldsLeft8zqvr--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField8zqvr = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss8zqvr < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss8zqvr = 0
			}
			for nextMiss8zqvr < maxFields8zqvr && found8zqvr[nextMiss8zqvr] {
				nextMiss8zqvr++
			}
			if nextMiss8zqvr == maxFields8zqvr {
				// filled all the empty fields!
				break doneWithStruct8zqvr
			}
			missingFieldsLeft8zqvr--
			curField8zqvr = decodeMsgFieldOrder8zqvr[nextMiss8zqvr]
		}
		fmt.Printf("switching on curField: '%v'\n", curField8zqvr)
		switch curField8zqvr {
		// -- templateDecodeMsg ends here --

		case "Lat":
			found8zqvr[0] = true
			z.Lat, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Long":
			found8zqvr[1] = true
			z.Long, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Alt":
			found8zqvr[2] = true
			z.Alt, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Data":
			found8zqvr[3] = true
			z.Data, err = dc.ReadBytes(z.Data)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss8zqvr != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of FastAlias
var decodeMsgFieldOrder8zqvr = []string{"Lat", "Long", "Alt", "Data"}

// fieldsNotEmpty supports omitempty tags
func (z *FastAlias) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *FastAlias) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Lat"
	err = en.Append(0x84, 0xa3, 0x4c, 0x61, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Lat)
	if err != nil {
		panic(err)
	}
	// write "Long"
	err = en.Append(0xa4, 0x4c, 0x6f, 0x6e, 0x67)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Long)
	if err != nil {
		panic(err)
	}
	// write "Alt"
	err = en.Append(0xa3, 0x41, 0x6c, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Alt)
	if err != nil {
		panic(err)
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FastAlias) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Lat"
	o = append(o, 0x84, 0xa3, 0x4c, 0x61, 0x74)
	o = msgp.AppendFloat64(o, z.Lat)
	// string "Long"
	o = append(o, 0xa4, 0x4c, 0x6f, 0x6e, 0x67)
	o = msgp.AppendFloat64(o, z.Long)
	// string "Alt"
	o = append(o, 0xa3, 0x41, 0x6c, 0x74)
	o = msgp.AppendFloat64(o, z.Alt)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FastAlias) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields9zpcz = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields9zpcz uint32
	if !nbs.AlwaysNil {
		totalEncodedFields9zpcz, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft9zpcz := totalEncodedFields9zpcz
	missingFieldsLeft9zpcz := maxFields9zpcz - totalEncodedFields9zpcz

	var nextMiss9zpcz int32 = -1
	var found9zpcz [maxFields9zpcz]bool
	var curField9zpcz string

doneWithStruct9zpcz:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft9zpcz > 0 || missingFieldsLeft9zpcz > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft9zpcz, missingFieldsLeft9zpcz, msgp.ShowFound(found9zpcz[:]), unmarshalMsgFieldOrder9zpcz)
		if encodedFieldsLeft9zpcz > 0 {
			encodedFieldsLeft9zpcz--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField9zpcz = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss9zpcz < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss9zpcz = 0
			}
			for nextMiss9zpcz < maxFields9zpcz && found9zpcz[nextMiss9zpcz] {
				nextMiss9zpcz++
			}
			if nextMiss9zpcz == maxFields9zpcz {
				// filled all the empty fields!
				break doneWithStruct9zpcz
			}
			missingFieldsLeft9zpcz--
			curField9zpcz = unmarshalMsgFieldOrder9zpcz[nextMiss9zpcz]
		}
		fmt.Printf("switching on curField: '%v'\n", curField9zpcz)
		switch curField9zpcz {
		// -- templateUnmarshalMsg ends here --

		case "Lat":
			found9zpcz[0] = true
			z.Lat, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Long":
			found9zpcz[1] = true
			z.Long, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Alt":
			found9zpcz[2] = true
			z.Alt, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Data":
			found9zpcz[3] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Data = z.Data[:0]
			} else {
				z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

				if err != nil {
					panic(err)
				}
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss9zpcz != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of FastAlias
var unmarshalMsgFieldOrder9zpcz = []string{"Lat", "Long", "Alt", "Data"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FastAlias) Msgsize() (s int) {
	s = 1 + 4 + msgp.Float64Size + 5 + msgp.Float64Size + 4 + msgp.Float64Size + 5 + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *FileHandle) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields10zkcn = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields10zkcn uint32
	totalEncodedFields10zkcn, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft10zkcn := totalEncodedFields10zkcn
	missingFieldsLeft10zkcn := maxFields10zkcn - totalEncodedFields10zkcn

	var nextMiss10zkcn int32 = -1
	var found10zkcn [maxFields10zkcn]bool
	var curField10zkcn string

doneWithStruct10zkcn:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft10zkcn > 0 || missingFieldsLeft10zkcn > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft10zkcn, missingFieldsLeft10zkcn, msgp.ShowFound(found10zkcn[:]), decodeMsgFieldOrder10zkcn)
		if encodedFieldsLeft10zkcn > 0 {
			encodedFieldsLeft10zkcn--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField10zkcn = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss10zkcn < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss10zkcn = 0
			}
			for nextMiss10zkcn < maxFields10zkcn && found10zkcn[nextMiss10zkcn] {
				nextMiss10zkcn++
			}
			if nextMiss10zkcn == maxFields10zkcn {
				// filled all the empty fields!
				break doneWithStruct10zkcn
			}
			missingFieldsLeft10zkcn--
			curField10zkcn = decodeMsgFieldOrder10zkcn[nextMiss10zkcn]
		}
		fmt.Printf("switching on curField: '%v'\n", curField10zkcn)
		switch curField10zkcn {
		// -- templateDecodeMsg ends here --

		case "files":
			found10zkcn[0] = true
			var ztor uint32
			ztor, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Relevent) >= int(ztor) {
				z.Relevent = (z.Relevent)[:ztor]
			} else {
				z.Relevent = make(Files, ztor)
			}
			for zwri := range z.Relevent {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

				} else {

					{
						var zhpl string
						zhpl, err = dc.ReadString()
						z.Relevent[zwri] = filefromstr(zhpl)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "name":
			found10zkcn[1] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss10zkcn != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of FileHandle
var decodeMsgFieldOrder10zkcn = []string{"files", "name"}

// fieldsNotEmpty supports omitempty tags
func (z *FileHandle) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *FileHandle) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "files"
	err = en.Append(0x82, 0xa5, 0x66, 0x69, 0x6c, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Relevent)))
	if err != nil {
		panic(err)
	}
	for zwri := range z.Relevent {
		if z.Relevent[zwri] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(filetostr(z.Relevent[zwri]))
			if err != nil {
				panic(err)
			}
		}
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Name)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileHandle) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "files"
	o = append(o, 0x82, 0xa5, 0x66, 0x69, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Relevent)))
	for zwri := range z.Relevent {
		if z.Relevent[zwri] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, filetostr(z.Relevent[zwri]))
		}
	}
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileHandle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields11zdmu = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields11zdmu uint32
	if !nbs.AlwaysNil {
		totalEncodedFields11zdmu, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft11zdmu := totalEncodedFields11zdmu
	missingFieldsLeft11zdmu := maxFields11zdmu - totalEncodedFields11zdmu

	var nextMiss11zdmu int32 = -1
	var found11zdmu [maxFields11zdmu]bool
	var curField11zdmu string

doneWithStruct11zdmu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft11zdmu > 0 || missingFieldsLeft11zdmu > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft11zdmu, missingFieldsLeft11zdmu, msgp.ShowFound(found11zdmu[:]), unmarshalMsgFieldOrder11zdmu)
		if encodedFieldsLeft11zdmu > 0 {
			encodedFieldsLeft11zdmu--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField11zdmu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss11zdmu < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss11zdmu = 0
			}
			for nextMiss11zdmu < maxFields11zdmu && found11zdmu[nextMiss11zdmu] {
				nextMiss11zdmu++
			}
			if nextMiss11zdmu == maxFields11zdmu {
				// filled all the empty fields!
				break doneWithStruct11zdmu
			}
			missingFieldsLeft11zdmu--
			curField11zdmu = unmarshalMsgFieldOrder11zdmu[nextMiss11zdmu]
		}
		fmt.Printf("switching on curField: '%v'\n", curField11zdmu)
		switch curField11zdmu {
		// -- templateUnmarshalMsg ends here --

		case "files":
			found11zdmu[0] = true
			if nbs.AlwaysNil {
				(z.Relevent) = (z.Relevent)[:0]
			} else {

				var zpwu uint32
				zpwu, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Relevent) >= int(zpwu) {
					z.Relevent = (z.Relevent)[:zpwu]
				} else {
					z.Relevent = make(Files, zpwu)
				}
				for zwri := range z.Relevent {
					// default gPtr logic.
					if nbs.PeekNil(bts) {
						if z.Relevent[zwri] != nil {
							// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.Relevent[zwri]", alias:"*os.File"}, Value:(*gen.BaseElem)(0xc4202707d0)}
							(z.Relevent[zwri]) = nil
						}
					} else { // wire has bytes

						{
							var zjkj string
							zjkj, bts, err = nbs.ReadStringBytes(bts)

							if err != nil {
								panic(err)
							}
							z.Relevent[zwri] = filefromstr(zjkj)
						}
					}
				}
			}
		case "name":
			found11zdmu[1] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss11zdmu != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of FileHandle
var unmarshalMsgFieldOrder11zdmu = []string{"files", "name"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileHandle) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for zwri := range z.Relevent {
		if z.Relevent[zwri] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(filetostr(z.Relevent[zwri]))
		}
	}
	s += 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Files) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zsre uint32
	zsre, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap((*z)) >= int(zsre) {
		(*z) = (*z)[:zsre]
	} else {
		(*z) = make(Files, zsre)
	}
	for zjgu := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				return
			}

		} else {

			{
				var zxfn string
				zxfn, err = dc.ReadString()
				(*z)[zjgu] = filefromstr(zxfn)
			}
			if err != nil {
				panic(err)
			}
		}
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z Files) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		panic(err)
	}
	for zxaq := range z {
		if z[zxaq] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(filetostr(z[zxaq]))
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Files) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zxaq := range z {
		if z[zxaq] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, filetostr(z[zxaq]))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Files) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zqhe uint32
		zqhe, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap((*z)) >= int(zqhe) {
			(*z) = (*z)[:zqhe]
		} else {
			(*z) = make(Files, zqhe)
		}
		for zdwg := range *z {
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if (*z)[zdwg] != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"(*z)[zdwg]", alias:"*os.File"}, Value:(*gen.BaseElem)(0xc4202705f0)}
					((*z)[zdwg]) = nil
				}
			} else { // wire has bytes

				{
					var zrvc string
					zrvc, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					(*z)[zdwg] = filefromstr(zrvc)
				}
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Files) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zjcw := range z {
		if z[zjcw] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(filetostr(z[zjcw]))
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Fixed) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields12zmup = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields12zmup uint32
	totalEncodedFields12zmup, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft12zmup := totalEncodedFields12zmup
	missingFieldsLeft12zmup := maxFields12zmup - totalEncodedFields12zmup

	var nextMiss12zmup int32 = -1
	var found12zmup [maxFields12zmup]bool
	var curField12zmup string

doneWithStruct12zmup:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft12zmup > 0 || missingFieldsLeft12zmup > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft12zmup, missingFieldsLeft12zmup, msgp.ShowFound(found12zmup[:]), decodeMsgFieldOrder12zmup)
		if encodedFieldsLeft12zmup > 0 {
			encodedFieldsLeft12zmup--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField12zmup = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss12zmup < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss12zmup = 0
			}
			for nextMiss12zmup < maxFields12zmup && found12zmup[nextMiss12zmup] {
				nextMiss12zmup++
			}
			if nextMiss12zmup == maxFields12zmup {
				// filled all the empty fields!
				break doneWithStruct12zmup
			}
			missingFieldsLeft12zmup--
			curField12zmup = decodeMsgFieldOrder12zmup[nextMiss12zmup]
		}
		fmt.Printf("switching on curField: '%v'\n", curField12zmup)
		switch curField12zmup {
		// -- templateDecodeMsg ends here --

		case "A":
			found12zmup[0] = true
			z.A, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "B":
			found12zmup[1] = true
			z.B, err = dc.ReadBool()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss12zmup != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Fixed
var decodeMsgFieldOrder12zmup = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z Fixed) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z Fixed) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "A"
	err = en.Append(0x82, 0xa1, 0x41)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.A)
	if err != nil {
		panic(err)
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return err
	}
	err = en.WriteBool(z.B)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Fixed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "A"
	o = append(o, 0x82, 0xa1, 0x41)
	o = msgp.AppendFloat64(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendBool(o, z.B)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Fixed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields13zeof = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields13zeof uint32
	if !nbs.AlwaysNil {
		totalEncodedFields13zeof, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft13zeof := totalEncodedFields13zeof
	missingFieldsLeft13zeof := maxFields13zeof - totalEncodedFields13zeof

	var nextMiss13zeof int32 = -1
	var found13zeof [maxFields13zeof]bool
	var curField13zeof string

doneWithStruct13zeof:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft13zeof > 0 || missingFieldsLeft13zeof > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft13zeof, missingFieldsLeft13zeof, msgp.ShowFound(found13zeof[:]), unmarshalMsgFieldOrder13zeof)
		if encodedFieldsLeft13zeof > 0 {
			encodedFieldsLeft13zeof--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField13zeof = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss13zeof < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss13zeof = 0
			}
			for nextMiss13zeof < maxFields13zeof && found13zeof[nextMiss13zeof] {
				nextMiss13zeof++
			}
			if nextMiss13zeof == maxFields13zeof {
				// filled all the empty fields!
				break doneWithStruct13zeof
			}
			missingFieldsLeft13zeof--
			curField13zeof = unmarshalMsgFieldOrder13zeof[nextMiss13zeof]
		}
		fmt.Printf("switching on curField: '%v'\n", curField13zeof)
		switch curField13zeof {
		// -- templateUnmarshalMsg ends here --

		case "A":
			found13zeof[0] = true
			z.A, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "B":
			found13zeof[1] = true
			z.B, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss13zeof != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Fixed
var unmarshalMsgFieldOrder13zeof = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Fixed) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.BoolSize
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Insane) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(3)
	if err != nil {
		panic(err)
	}
	for zlzi := range z {
		err = en.WriteMapHeader(uint32(len(z[zlzi])))
		if err != nil {
			panic(err)
		}
		for zrrt, zsdi := range z[zlzi] {
			err = en.WriteString(zrrt)
			if err != nil {
				panic(err)
			}
			// map header, size 2
			// write "A"
			err = en.Append(0x82, 0xa1, 0x41)
			if err != nil {
				return err
			}
			err = en.WriteInt(int(zsdi.A))
			if err != nil {
				panic(err)
			}
			// write "B"
			err = en.Append(0xa1, 0x42)
			if err != nil {
				return err
			}
			err = en.WriteInt(int(zsdi.B))
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Insane) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, 3)
	for zlzi := range z {
		o = msgp.AppendMapHeader(o, uint32(len(z[zlzi])))
		for zrrt, zsdi := range z[zlzi] {
			o = msgp.AppendString(o, zrrt)
			// map header, size 2
			// string "A"
			o = append(o, 0x82, 0xa1, 0x41)
			o = msgp.AppendInt(o, int(zsdi.A))
			// string "B"
			o = append(o, 0xa1, 0x42)
			o = msgp.AppendInt(o, int(zsdi.B))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Insane) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zxbr uint32
	zxbr, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if !nbs.IsNil(bts) && zxbr != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zxbr}
		return
	}
	for zlzi := range z {
		if nbs.AlwaysNil {
			if len(z[zlzi]) > 0 {
				for key, _ := range z[zlzi] {
					delete(z[zlzi], key)
				}
			}

		} else {

			var zsct uint32
			zsct, bts, err = nbs.ReadMapHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if z[zlzi] == nil && zsct > 0 {
				z[zlzi] = make(map[string]struct {
					A CustomInt
					B CustomInt
				}, zsct)
			} else if len(z[zlzi]) > 0 {
				for key, _ := range z[zlzi] {
					delete(z[zlzi], key)
				}
			}
			for zsct > 0 {
				var zrrt string
				var zsdi struct {
					A CustomInt
					B CustomInt
				}
				zsct--
				zrrt, bts, err = nbs.ReadStringBytes(bts)
				if err != nil {
					panic(err)
				}
				var field []byte
				_ = field
				const maxFields14zxyv = 2

				// -- templateUnmarshalMsg starts here--
				var totalEncodedFields14zxyv uint32
				if !nbs.AlwaysNil {
					totalEncodedFields14zxyv, bts, err = nbs.ReadMapHeaderBytes(bts)
					if err != nil {
						panic(err)
						return
					}
				}
				encodedFieldsLeft14zxyv := totalEncodedFields14zxyv
				missingFieldsLeft14zxyv := maxFields14zxyv - totalEncodedFields14zxyv

				var nextMiss14zxyv int32 = -1
				var found14zxyv [maxFields14zxyv]bool
				var curField14zxyv string

			doneWithStruct14zxyv:
				// First fill all the encoded fields, then
				// treat the remaining, missing fields, as Nil.
				for encodedFieldsLeft14zxyv > 0 || missingFieldsLeft14zxyv > 0 {
					fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft14zxyv, missingFieldsLeft14zxyv, msgp.ShowFound(found14zxyv[:]), unmarshalMsgFieldOrder14zxyv)
					if encodedFieldsLeft14zxyv > 0 {
						encodedFieldsLeft14zxyv--
						field, bts, err = nbs.ReadMapKeyZC(bts)
						if err != nil {
							panic(err)
							return
						}
						curField14zxyv = msgp.UnsafeString(field)
					} else {
						//missing fields need handling
						if nextMiss14zxyv < 0 {
							// set bts to contain just mnil (0xc0)
							bts = nbs.PushAlwaysNil(bts)
							nextMiss14zxyv = 0
						}
						for nextMiss14zxyv < maxFields14zxyv && found14zxyv[nextMiss14zxyv] {
							nextMiss14zxyv++
						}
						if nextMiss14zxyv == maxFields14zxyv {
							// filled all the empty fields!
							break doneWithStruct14zxyv
						}
						missingFieldsLeft14zxyv--
						curField14zxyv = unmarshalMsgFieldOrder14zxyv[nextMiss14zxyv]
					}
					fmt.Printf("switching on curField: '%v'\n", curField14zxyv)
					switch curField14zxyv {
					// -- templateUnmarshalMsg ends here --

					case "A":
						found14zxyv[0] = true
						{
							var zbpo int
							zbpo, bts, err = nbs.ReadIntBytes(bts)

							if err != nil {
								panic(err)
							}
							zsdi.A = CustomInt(zbpo)
						}
					case "B":
						found14zxyv[1] = true
						{
							var zjcw int
							zjcw, bts, err = nbs.ReadIntBytes(bts)

							if err != nil {
								panic(err)
							}
							zsdi.B = CustomInt(zjcw)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							panic(err)
						}
					}
				}
				if nextMiss14zxyv != -1 {
					bts = nbs.PopAlwaysNil()
				}

				z[zlzi][zrrt] = zsdi
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of struct{;A CustomInt;;B CustomInt;;}
var unmarshalMsgFieldOrder14zxyv = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Insane) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zlzi := range z {
		s += msgp.MapHeaderSize
		if z[zlzi] != nil {
			for zrrt, zsdi := range z[zlzi] {
				_ = zsdi
				s += msgp.StringPrefixSize + len(zrrt) + 1 + 2 + msgp.IntSize + 2 + msgp.IntSize
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntA) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zjcq int
		zjcq, err = dc.ReadInt()
		(*z) = IntA(zjcq)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntA) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntA) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntA) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zczz int
		zczz, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntA(zczz)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntA) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntB) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zhvw int
		zhvw, err = dc.ReadInt()
		(*z) = IntB(zhvw)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntB) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntB) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntB) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zaal int
		zaal, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntB(zaal)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntB) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntC) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zhsh int
		zhsh, err = dc.ReadInt()
		(*z) = IntC(zhsh)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntC) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntC) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntC) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zvea int
		zvea, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntC(zvea)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntC) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Moose) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields15zfje = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields15zfje uint32
	totalEncodedFields15zfje, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft15zfje := totalEncodedFields15zfje
	missingFieldsLeft15zfje := maxFields15zfje - totalEncodedFields15zfje

	var nextMiss15zfje int32 = -1
	var found15zfje [maxFields15zfje]bool
	var curField15zfje string

doneWithStruct15zfje:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft15zfje > 0 || missingFieldsLeft15zfje > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft15zfje, missingFieldsLeft15zfje, msgp.ShowFound(found15zfje[:]), decodeMsgFieldOrder15zfje)
		if encodedFieldsLeft15zfje > 0 {
			encodedFieldsLeft15zfje--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField15zfje = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss15zfje < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss15zfje = 0
			}
			for nextMiss15zfje < maxFields15zfje && found15zfje[nextMiss15zfje] {
				nextMiss15zfje++
			}
			if nextMiss15zfje == maxFields15zfje {
				// filled all the empty fields!
				break doneWithStruct15zfje
			}
			missingFieldsLeft15zfje--
			curField15zfje = decodeMsgFieldOrder15zfje[nextMiss15zfje]
		}
		fmt.Printf("switching on curField: '%v'\n", curField15zfje)
		switch curField15zfje {
		// -- templateDecodeMsg ends here --

		case "Trees":
			found15zfje[0] = true
			var zwil uint32
			zwil, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Trees) >= int(zwil) {
				z.Trees = (z.Trees)[:zwil]
			} else {
				z.Trees = make([]int, zwil)
			}
			for zozo := range z.Trees {
				z.Trees[zozo], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "Sayings":
			found15zfje[1] = true
			var zptz uint32
			zptz, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Sayings == nil && zptz > 0 {
				z.Sayings = make(map[string]string, zptz)
			} else if len(z.Sayings) > 0 {
				for key, _ := range z.Sayings {
					delete(z.Sayings, key)
				}
			}
			for zptz > 0 {
				zptz--
				var zyhz string
				var zxzn string
				zyhz, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zxzn, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Sayings[zyhz] = zxzn
			}
		case "Id":
			found15zfje[2] = true
			z.Id, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss15zfje != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Moose
var decodeMsgFieldOrder15zfje = []string{"Trees", "Sayings", "Id"}

// fieldsNotEmpty supports omitempty tags
func (z *Moose) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (len(z.Trees) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Sayings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Moose) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zuzq [3]bool
	fieldsInUse_zdaq := z.fieldsNotEmpty(empty_zuzq[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zdaq)
	if err != nil {
		return err
	}

	if !empty_zuzq[0] {
		// write "Trees"
		err = en.Append(0xa5, 0x54, 0x72, 0x65, 0x65, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Trees)))
		if err != nil {
			panic(err)
		}
		for zozo := range z.Trees {
			err = en.WriteInt(z.Trees[zozo])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuzq[1] {
		// write "Sayings"
		err = en.Append(0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Sayings)))
		if err != nil {
			panic(err)
		}
		for zyhz, zxzn := range z.Sayings {
			err = en.WriteString(zyhz)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zxzn)
			if err != nil {
				panic(err)
			}
		}
	}

	// write "Id"
	err = en.Append(0xa2, 0x49, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.Id)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Moose) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Trees"
		o = append(o, 0xa5, 0x54, 0x72, 0x65, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Trees)))
		for zozo := range z.Trees {
			o = msgp.AppendInt(o, z.Trees[zozo])
		}
	}

	if !empty[1] {
		// string "Sayings"
		o = append(o, 0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Sayings)))
		for zyhz, zxzn := range z.Sayings {
			o = msgp.AppendString(o, zyhz)
			o = msgp.AppendString(o, zxzn)
		}
	}

	// string "Id"
	o = append(o, 0xa2, 0x49, 0x64)
	o = msgp.AppendInt(o, z.Id)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Moose) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields16zypa = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields16zypa uint32
	if !nbs.AlwaysNil {
		totalEncodedFields16zypa, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft16zypa := totalEncodedFields16zypa
	missingFieldsLeft16zypa := maxFields16zypa - totalEncodedFields16zypa

	var nextMiss16zypa int32 = -1
	var found16zypa [maxFields16zypa]bool
	var curField16zypa string

doneWithStruct16zypa:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft16zypa > 0 || missingFieldsLeft16zypa > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft16zypa, missingFieldsLeft16zypa, msgp.ShowFound(found16zypa[:]), unmarshalMsgFieldOrder16zypa)
		if encodedFieldsLeft16zypa > 0 {
			encodedFieldsLeft16zypa--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField16zypa = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss16zypa < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss16zypa = 0
			}
			for nextMiss16zypa < maxFields16zypa && found16zypa[nextMiss16zypa] {
				nextMiss16zypa++
			}
			if nextMiss16zypa == maxFields16zypa {
				// filled all the empty fields!
				break doneWithStruct16zypa
			}
			missingFieldsLeft16zypa--
			curField16zypa = unmarshalMsgFieldOrder16zypa[nextMiss16zypa]
		}
		fmt.Printf("switching on curField: '%v'\n", curField16zypa)
		switch curField16zypa {
		// -- templateUnmarshalMsg ends here --

		case "Trees":
			found16zypa[0] = true
			if nbs.AlwaysNil {
				(z.Trees) = (z.Trees)[:0]
			} else {

				var zbrj uint32
				zbrj, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Trees) >= int(zbrj) {
					z.Trees = (z.Trees)[:zbrj]
				} else {
					z.Trees = make([]int, zbrj)
				}
				for zozo := range z.Trees {
					z.Trees[zozo], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Sayings":
			found16zypa[1] = true
			if nbs.AlwaysNil {
				if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}

			} else {

				var zpic uint32
				zpic, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Sayings == nil && zpic > 0 {
					z.Sayings = make(map[string]string, zpic)
				} else if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}
				for zpic > 0 {
					var zyhz string
					var zxzn string
					zpic--
					zyhz, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zxzn, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Sayings[zyhz] = zxzn
				}
			}
		case "Id":
			found16zypa[2] = true
			z.Id, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss16zypa != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Moose
var unmarshalMsgFieldOrder16zypa = []string{"Trees", "Sayings", "Id"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Moose) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize + (len(z.Trees) * (msgp.IntSize)) + 8 + msgp.MapHeaderSize
	if z.Sayings != nil {
		for zyhz, zxzn := range z.Sayings {
			_ = zxzn
			s += msgp.StringPrefixSize + len(zyhz) + msgp.StringPrefixSize + len(zxzn)
		}
	}
	s += 3 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *MyEnum) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zhaj string
		zhaj, err = dc.ReadString()
		(*z) = myenumStr(zhaj)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z MyEnum) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString((MyEnum).String(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MyEnum) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, (MyEnum).String(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MyEnum) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zdqs string
		zdqs, bts, err = nbs.ReadStringBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = myenumStr(zdqs)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MyEnum) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len((MyEnum).String(z))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Object) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zfqb uint32
	zfqb, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zfqb != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zfqb}
		return
	}
	z.ObjectNo, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	var zmyc uint32
	zmyc, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap(z.Slice1) >= int(zmyc) {
		z.Slice1 = (z.Slice1)[:zmyc]
	} else {
		z.Slice1 = make([]string, zmyc)
	}
	for zdah := range z.Slice1 {
		z.Slice1[zdah], err = dc.ReadString()
		if err != nil {
			panic(err)
		}
	}
	var zqnc uint32
	zqnc, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap(z.Slice2) >= int(zqnc) {
		z.Slice2 = (z.Slice2)[:zqnc]
	} else {
		z.Slice2 = make([]string, zqnc)
	}
	for zbbp := range z.Slice2 {
		z.Slice2[zbbp], err = dc.ReadString()
		if err != nil {
			panic(err)
		}
	}
	var zxkd uint32
	zxkd, err = dc.ReadMapHeader()
	if err != nil {
		panic(err)
	}
	if z.MapMap == nil && zxkd > 0 {
		z.MapMap = make(map[string]map[string]string, zxkd)
	} else if len(z.MapMap) > 0 {
		for key, _ := range z.MapMap {
			delete(z.MapMap, key)
		}
	}
	for zxkd > 0 {
		zxkd--
		var zisr string
		var zqvd map[string]string
		zisr, err = dc.ReadString()
		if err != nil {
			panic(err)
		}
		var zbfy uint32
		zbfy, err = dc.ReadMapHeader()
		if err != nil {
			panic(err)
		}
		if zqvd == nil && zbfy > 0 {
			zqvd = make(map[string]string, zbfy)
		} else if len(zqvd) > 0 {
			for key, _ := range zqvd {
				delete(zqvd, key)
			}
		}
		for zbfy > 0 {
			zbfy--
			var zezi string
			var zwgx string
			zezi, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
			zwgx, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
			zqvd[zezi] = zwgx
		}
		z.MapMap[zisr] = zqvd
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *Object) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Object) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return err
	}
	err = en.WriteString(z.ObjectNo)
	if err != nil {
		panic(err)
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice1)))
	if err != nil {
		panic(err)
	}
	for zdah := range z.Slice1 {
		err = en.WriteString(z.Slice1[zdah])
		if err != nil {
			panic(err)
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice2)))
	if err != nil {
		panic(err)
	}
	for zbbp := range z.Slice2 {
		err = en.WriteString(z.Slice2[zbbp])
		if err != nil {
			panic(err)
		}
	}
	err = en.WriteMapHeader(uint32(len(z.MapMap)))
	if err != nil {
		panic(err)
	}
	for zisr, zqvd := range z.MapMap {
		err = en.WriteString(zisr)
		if err != nil {
			panic(err)
		}
		err = en.WriteMapHeader(uint32(len(zqvd)))
		if err != nil {
			panic(err)
		}
		for zezi, zwgx := range zqvd {
			err = en.WriteString(zezi)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zwgx)
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Object) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendString(o, z.ObjectNo)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice1)))
	for zdah := range z.Slice1 {
		o = msgp.AppendString(o, z.Slice1[zdah])
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice2)))
	for zbbp := range z.Slice2 {
		o = msgp.AppendString(o, z.Slice2[zbbp])
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.MapMap)))
	for zisr, zqvd := range z.MapMap {
		o = msgp.AppendString(o, zisr)
		o = msgp.AppendMapHeader(o, uint32(len(zqvd)))
		for zezi, zwgx := range zqvd {
			o = msgp.AppendString(o, zezi)
			o = msgp.AppendString(o, zwgx)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Object) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var ziwk uint32
	ziwk, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if ziwk != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: ziwk}
		return
	}
	z.ObjectNo, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	if nbs.AlwaysNil {
		(z.Slice1) = (z.Slice1)[:0]
	} else {

		var zhzg uint32
		zhzg, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap(z.Slice1) >= int(zhzg) {
			z.Slice1 = (z.Slice1)[:zhzg]
		} else {
			z.Slice1 = make([]string, zhzg)
		}
		for zdah := range z.Slice1 {
			z.Slice1[zdah], bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		}
	}
	if nbs.AlwaysNil {
		(z.Slice2) = (z.Slice2)[:0]
	} else {

		var zpnj uint32
		zpnj, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap(z.Slice2) >= int(zpnj) {
			z.Slice2 = (z.Slice2)[:zpnj]
		} else {
			z.Slice2 = make([]string, zpnj)
		}
		for zbbp := range z.Slice2 {
			z.Slice2[zbbp], bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		}
	}
	if nbs.AlwaysNil {
		if len(z.MapMap) > 0 {
			for key, _ := range z.MapMap {
				delete(z.MapMap, key)
			}
		}

	} else {

		var znsa uint32
		znsa, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if z.MapMap == nil && znsa > 0 {
			z.MapMap = make(map[string]map[string]string, znsa)
		} else if len(z.MapMap) > 0 {
			for key, _ := range z.MapMap {
				delete(z.MapMap, key)
			}
		}
		for znsa > 0 {
			var zisr string
			var zqvd map[string]string
			znsa--
			zisr, bts, err = nbs.ReadStringBytes(bts)
			if err != nil {
				panic(err)
			}
			if nbs.AlwaysNil {
				if len(zqvd) > 0 {
					for key, _ := range zqvd {
						delete(zqvd, key)
					}
				}

			} else {

				var zgwc uint32
				zgwc, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if zqvd == nil && zgwc > 0 {
					zqvd = make(map[string]string, zgwc)
				} else if len(zqvd) > 0 {
					for key, _ := range zqvd {
						delete(zqvd, key)
					}
				}
				for zgwc > 0 {
					var zezi string
					var zwgx string
					zgwc--
					zezi, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zwgx, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					zqvd[zezi] = zwgx
				}
			}
			z.MapMap[zisr] = zqvd
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Object) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.ObjectNo) + msgp.ArrayHeaderSize
	for zdah := range z.Slice1 {
		s += msgp.StringPrefixSize + len(z.Slice1[zdah])
	}
	s += msgp.ArrayHeaderSize
	for zbbp := range z.Slice2 {
		s += msgp.StringPrefixSize + len(z.Slice2[zbbp])
	}
	s += msgp.MapHeaderSize
	if z.MapMap != nil {
		for zisr, zqvd := range z.MapMap {
			_ = zqvd
			s += msgp.StringPrefixSize + len(zisr) + msgp.MapHeaderSize
			if zqvd != nil {
				for zezi, zwgx := range zqvd {
					_ = zwgx
					s += msgp.StringPrefixSize + len(zezi) + msgp.StringPrefixSize + len(zwgx)
				}
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitEmptyInside1) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields17zaix = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields17zaix uint32
	totalEncodedFields17zaix, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft17zaix := totalEncodedFields17zaix
	missingFieldsLeft17zaix := maxFields17zaix - totalEncodedFields17zaix

	var nextMiss17zaix int32 = -1
	var found17zaix [maxFields17zaix]bool
	var curField17zaix string

doneWithStruct17zaix:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft17zaix > 0 || missingFieldsLeft17zaix > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft17zaix, missingFieldsLeft17zaix, msgp.ShowFound(found17zaix[:]), decodeMsgFieldOrder17zaix)
		if encodedFieldsLeft17zaix > 0 {
			encodedFieldsLeft17zaix--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField17zaix = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss17zaix < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss17zaix = 0
			}
			for nextMiss17zaix < maxFields17zaix && found17zaix[nextMiss17zaix] {
				nextMiss17zaix++
			}
			if nextMiss17zaix == maxFields17zaix {
				// filled all the empty fields!
				break doneWithStruct17zaix
			}
			missingFieldsLeft17zaix--
			curField17zaix = decodeMsgFieldOrder17zaix[nextMiss17zaix]
		}
		fmt.Printf("switching on curField: '%v'\n", curField17zaix)
		switch curField17zaix {
		// -- templateDecodeMsg ends here --

		case "CountOfMonteCrisco":
			found17zaix[0] = true
			z.CountOfMonteCrisco, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "name":
			found17zaix[1] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Inside2":
			found17zaix[2] = true
			const maxFields18zncd = 1

			// -- templateDecodeMsg starts here--
			var totalEncodedFields18zncd uint32
			totalEncodedFields18zncd, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft18zncd := totalEncodedFields18zncd
			missingFieldsLeft18zncd := maxFields18zncd - totalEncodedFields18zncd

			var nextMiss18zncd int32 = -1
			var found18zncd [maxFields18zncd]bool
			var curField18zncd string

		doneWithStruct18zncd:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft18zncd > 0 || missingFieldsLeft18zncd > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft18zncd, missingFieldsLeft18zncd, msgp.ShowFound(found18zncd[:]), decodeMsgFieldOrder18zncd)
				if encodedFieldsLeft18zncd > 0 {
					encodedFieldsLeft18zncd--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField18zncd = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss18zncd < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss18zncd = 0
					}
					for nextMiss18zncd < maxFields18zncd && found18zncd[nextMiss18zncd] {
						nextMiss18zncd++
					}
					if nextMiss18zncd == maxFields18zncd {
						// filled all the empty fields!
						break doneWithStruct18zncd
					}
					missingFieldsLeft18zncd--
					curField18zncd = decodeMsgFieldOrder18zncd[nextMiss18zncd]
				}
				fmt.Printf("switching on curField: '%v'\n", curField18zncd)
				switch curField18zncd {
				// -- templateDecodeMsg ends here --

				case "NameSuey":
					found18zncd[0] = true
					z.Inside2.NameSuey, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss18zncd != -1 {
				dc.PopAlwaysNil()
			}

		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss17zaix != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitEmptyInside1
var decodeMsgFieldOrder17zaix = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder18zncd = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z *OmitEmptyInside1) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[1] = (len(z.Name) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = false // struct values are never empty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *OmitEmptyInside1) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zwcv [3]bool
	fieldsInUse_zmkf := z.fieldsNotEmpty(empty_zwcv[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zmkf)
	if err != nil {
		return err
	}

	// write "CountOfMonteCrisco"
	err = en.Append(0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.CountOfMonteCrisco)
	if err != nil {
		panic(err)
	}
	if !empty_zwcv[1] {
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Name)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zwcv[2] {
		// write "Inside2"
		// map header, size 1
		// write "NameSuey"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Inside2.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OmitEmptyInside1) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "CountOfMonteCrisco"
	o = append(o, 0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
	o = msgp.AppendInt(o, z.CountOfMonteCrisco)
	if !empty[1] {
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
	}

	if !empty[2] {
		// string "Inside2"
		// map header, size 1
		// string "NameSuey"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.Inside2.NameSuey)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitEmptyInside1) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields19zcyq = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields19zcyq uint32
	if !nbs.AlwaysNil {
		totalEncodedFields19zcyq, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft19zcyq := totalEncodedFields19zcyq
	missingFieldsLeft19zcyq := maxFields19zcyq - totalEncodedFields19zcyq

	var nextMiss19zcyq int32 = -1
	var found19zcyq [maxFields19zcyq]bool
	var curField19zcyq string

doneWithStruct19zcyq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft19zcyq > 0 || missingFieldsLeft19zcyq > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft19zcyq, missingFieldsLeft19zcyq, msgp.ShowFound(found19zcyq[:]), unmarshalMsgFieldOrder19zcyq)
		if encodedFieldsLeft19zcyq > 0 {
			encodedFieldsLeft19zcyq--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField19zcyq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss19zcyq < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss19zcyq = 0
			}
			for nextMiss19zcyq < maxFields19zcyq && found19zcyq[nextMiss19zcyq] {
				nextMiss19zcyq++
			}
			if nextMiss19zcyq == maxFields19zcyq {
				// filled all the empty fields!
				break doneWithStruct19zcyq
			}
			missingFieldsLeft19zcyq--
			curField19zcyq = unmarshalMsgFieldOrder19zcyq[nextMiss19zcyq]
		}
		fmt.Printf("switching on curField: '%v'\n", curField19zcyq)
		switch curField19zcyq {
		// -- templateUnmarshalMsg ends here --

		case "CountOfMonteCrisco":
			found19zcyq[0] = true
			z.CountOfMonteCrisco, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "name":
			found19zcyq[1] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Inside2":
			found19zcyq[2] = true
			const maxFields20zxup = 1

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields20zxup uint32
			if !nbs.AlwaysNil {
				totalEncodedFields20zxup, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft20zxup := totalEncodedFields20zxup
			missingFieldsLeft20zxup := maxFields20zxup - totalEncodedFields20zxup

			var nextMiss20zxup int32 = -1
			var found20zxup [maxFields20zxup]bool
			var curField20zxup string

		doneWithStruct20zxup:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft20zxup > 0 || missingFieldsLeft20zxup > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft20zxup, missingFieldsLeft20zxup, msgp.ShowFound(found20zxup[:]), unmarshalMsgFieldOrder20zxup)
				if encodedFieldsLeft20zxup > 0 {
					encodedFieldsLeft20zxup--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField20zxup = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss20zxup < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss20zxup = 0
					}
					for nextMiss20zxup < maxFields20zxup && found20zxup[nextMiss20zxup] {
						nextMiss20zxup++
					}
					if nextMiss20zxup == maxFields20zxup {
						// filled all the empty fields!
						break doneWithStruct20zxup
					}
					missingFieldsLeft20zxup--
					curField20zxup = unmarshalMsgFieldOrder20zxup[nextMiss20zxup]
				}
				fmt.Printf("switching on curField: '%v'\n", curField20zxup)
				switch curField20zxup {
				// -- templateUnmarshalMsg ends here --

				case "NameSuey":
					found20zxup[0] = true
					z.Inside2.NameSuey, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss20zxup != -1 {
				bts = nbs.PopAlwaysNil()
			}

		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss19zcyq != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitEmptyInside1
var unmarshalMsgFieldOrder19zcyq = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder20zxup = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OmitEmptyInside1) Msgsize() (s int) {
	s = 1 + 19 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 8 + 1 + 9 + msgp.StringPrefixSize + len(z.Inside2.NameSuey)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitEmptyInside2) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields21zddk = 1

	// -- templateDecodeMsg starts here--
	var totalEncodedFields21zddk uint32
	totalEncodedFields21zddk, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft21zddk := totalEncodedFields21zddk
	missingFieldsLeft21zddk := maxFields21zddk - totalEncodedFields21zddk

	var nextMiss21zddk int32 = -1
	var found21zddk [maxFields21zddk]bool
	var curField21zddk string

doneWithStruct21zddk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft21zddk > 0 || missingFieldsLeft21zddk > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft21zddk, missingFieldsLeft21zddk, msgp.ShowFound(found21zddk[:]), decodeMsgFieldOrder21zddk)
		if encodedFieldsLeft21zddk > 0 {
			encodedFieldsLeft21zddk--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField21zddk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss21zddk < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss21zddk = 0
			}
			for nextMiss21zddk < maxFields21zddk && found21zddk[nextMiss21zddk] {
				nextMiss21zddk++
			}
			if nextMiss21zddk == maxFields21zddk {
				// filled all the empty fields!
				break doneWithStruct21zddk
			}
			missingFieldsLeft21zddk--
			curField21zddk = decodeMsgFieldOrder21zddk[nextMiss21zddk]
		}
		fmt.Printf("switching on curField: '%v'\n", curField21zddk)
		switch curField21zddk {
		// -- templateDecodeMsg ends here --

		case "NameSuey":
			found21zddk[0] = true
			z.NameSuey, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss21zddk != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder21zddk = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z OmitEmptyInside2) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 1
	}
	var fieldsInUse uint32 = 1
	isempty[0] = (len(z.NameSuey) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z OmitEmptyInside2) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zntl [1]bool
	fieldsInUse_zgbf := z.fieldsNotEmpty(empty_zntl[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zgbf)
	if err != nil {
		return err
	}

	if !empty_zntl[0] {
		// write "NameSuey"
		err = en.Append(0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z OmitEmptyInside2) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [1]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "NameSuey"
		o = append(o, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.NameSuey)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitEmptyInside2) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields22zsnk = 1

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields22zsnk uint32
	if !nbs.AlwaysNil {
		totalEncodedFields22zsnk, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft22zsnk := totalEncodedFields22zsnk
	missingFieldsLeft22zsnk := maxFields22zsnk - totalEncodedFields22zsnk

	var nextMiss22zsnk int32 = -1
	var found22zsnk [maxFields22zsnk]bool
	var curField22zsnk string

doneWithStruct22zsnk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft22zsnk > 0 || missingFieldsLeft22zsnk > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft22zsnk, missingFieldsLeft22zsnk, msgp.ShowFound(found22zsnk[:]), unmarshalMsgFieldOrder22zsnk)
		if encodedFieldsLeft22zsnk > 0 {
			encodedFieldsLeft22zsnk--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField22zsnk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss22zsnk < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss22zsnk = 0
			}
			for nextMiss22zsnk < maxFields22zsnk && found22zsnk[nextMiss22zsnk] {
				nextMiss22zsnk++
			}
			if nextMiss22zsnk == maxFields22zsnk {
				// filled all the empty fields!
				break doneWithStruct22zsnk
			}
			missingFieldsLeft22zsnk--
			curField22zsnk = unmarshalMsgFieldOrder22zsnk[nextMiss22zsnk]
		}
		fmt.Printf("switching on curField: '%v'\n", curField22zsnk)
		switch curField22zsnk {
		// -- templateUnmarshalMsg ends here --

		case "NameSuey":
			found22zsnk[0] = true
			z.NameSuey, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss22zsnk != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder22zsnk = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OmitEmptyInside2) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.NameSuey)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitSimple) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields23znwl = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields23znwl uint32
	totalEncodedFields23znwl, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft23znwl := totalEncodedFields23znwl
	missingFieldsLeft23znwl := maxFields23znwl - totalEncodedFields23znwl

	var nextMiss23znwl int32 = -1
	var found23znwl [maxFields23znwl]bool
	var curField23znwl string

doneWithStruct23znwl:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft23znwl > 0 || missingFieldsLeft23znwl > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft23znwl, missingFieldsLeft23znwl, msgp.ShowFound(found23znwl[:]), decodeMsgFieldOrder23znwl)
		if encodedFieldsLeft23znwl > 0 {
			encodedFieldsLeft23znwl--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField23znwl = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss23znwl < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss23znwl = 0
			}
			for nextMiss23znwl < maxFields23znwl && found23znwl[nextMiss23znwl] {
				nextMiss23znwl++
			}
			if nextMiss23znwl == maxFields23znwl {
				// filled all the empty fields!
				break doneWithStruct23znwl
			}
			missingFieldsLeft23znwl--
			curField23znwl = decodeMsgFieldOrder23znwl[nextMiss23znwl]
		}
		fmt.Printf("switching on curField: '%v'\n", curField23znwl)
		switch curField23znwl {
		// -- templateDecodeMsg ends here --

		case "CountDrocula":
			found23znwl[0] = true
			z.CountDrocula, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Inside1":
			found23znwl[1] = true
			err = z.Inside1.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss23znwl != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitSimple
var decodeMsgFieldOrder23znwl = []string{"CountDrocula", "Inside1"}

// fieldsNotEmpty supports omitempty tags
func (z *OmitSimple) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 2
	}
	var fieldsInUse uint32 = 2
	isempty[1] = false
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *OmitSimple) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zpvu [2]bool
	fieldsInUse_zsil := z.fieldsNotEmpty(empty_zpvu[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zsil)
	if err != nil {
		return err
	}

	// write "CountDrocula"
	err = en.Append(0xac, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x72, 0x6f, 0x63, 0x75, 0x6c, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.CountDrocula)
	if err != nil {
		panic(err)
	}
	if !empty_zpvu[1] {
		// write "Inside1"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		if err != nil {
			return err
		}
		err = z.Inside1.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OmitSimple) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [2]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "CountDrocula"
	o = append(o, 0xac, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x72, 0x6f, 0x63, 0x75, 0x6c, 0x61)
	o = msgp.AppendInt(o, z.CountDrocula)
	if !empty[1] {
		// string "Inside1"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		o, err = z.Inside1.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitSimple) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields24zihe = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields24zihe uint32
	if !nbs.AlwaysNil {
		totalEncodedFields24zihe, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft24zihe := totalEncodedFields24zihe
	missingFieldsLeft24zihe := maxFields24zihe - totalEncodedFields24zihe

	var nextMiss24zihe int32 = -1
	var found24zihe [maxFields24zihe]bool
	var curField24zihe string

doneWithStruct24zihe:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft24zihe > 0 || missingFieldsLeft24zihe > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft24zihe, missingFieldsLeft24zihe, msgp.ShowFound(found24zihe[:]), unmarshalMsgFieldOrder24zihe)
		if encodedFieldsLeft24zihe > 0 {
			encodedFieldsLeft24zihe--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField24zihe = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss24zihe < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss24zihe = 0
			}
			for nextMiss24zihe < maxFields24zihe && found24zihe[nextMiss24zihe] {
				nextMiss24zihe++
			}
			if nextMiss24zihe == maxFields24zihe {
				// filled all the empty fields!
				break doneWithStruct24zihe
			}
			missingFieldsLeft24zihe--
			curField24zihe = unmarshalMsgFieldOrder24zihe[nextMiss24zihe]
		}
		fmt.Printf("switching on curField: '%v'\n", curField24zihe)
		switch curField24zihe {
		// -- templateUnmarshalMsg ends here --

		case "CountDrocula":
			found24zihe[0] = true
			z.CountDrocula, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Inside1":
			found24zihe[1] = true
			bts, err = z.Inside1.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss24zihe != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitSimple
var unmarshalMsgFieldOrder24zihe = []string{"CountDrocula", "Inside1"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OmitSimple) Msgsize() (s int) {
	s = 1 + 13 + msgp.IntSize + 8 + z.Inside1.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Rocky) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields25zoyr = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields25zoyr uint32
	totalEncodedFields25zoyr, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft25zoyr := totalEncodedFields25zoyr
	missingFieldsLeft25zoyr := maxFields25zoyr - totalEncodedFields25zoyr

	var nextMiss25zoyr int32 = -1
	var found25zoyr [maxFields25zoyr]bool
	var curField25zoyr string

doneWithStruct25zoyr:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft25zoyr > 0 || missingFieldsLeft25zoyr > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft25zoyr, missingFieldsLeft25zoyr, msgp.ShowFound(found25zoyr[:]), decodeMsgFieldOrder25zoyr)
		if encodedFieldsLeft25zoyr > 0 {
			encodedFieldsLeft25zoyr--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField25zoyr = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss25zoyr < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss25zoyr = 0
			}
			for nextMiss25zoyr < maxFields25zoyr && found25zoyr[nextMiss25zoyr] {
				nextMiss25zoyr++
			}
			if nextMiss25zoyr == maxFields25zoyr {
				// filled all the empty fields!
				break doneWithStruct25zoyr
			}
			missingFieldsLeft25zoyr--
			curField25zoyr = decodeMsgFieldOrder25zoyr[nextMiss25zoyr]
		}
		fmt.Printf("switching on curField: '%v'\n", curField25zoyr)
		switch curField25zoyr {
		// -- templateDecodeMsg ends here --

		case "Bugs":
			found25zoyr[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bugs != nil {
					dc.PushAlwaysNil()
					err = z.Bugs.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bugs == nil {
					z.Bugs = new(Bunny)
				}
				err = z.Bugs.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "Road":
			found25zoyr[1] = true
			z.Road, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Moose":
			found25zoyr[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Moose != nil {
					dc.PushAlwaysNil()
					err = z.Moose.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Moose == nil {
					z.Moose = new(Moose)
				}
				err = z.Moose.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss25zoyr != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Rocky
var decodeMsgFieldOrder25zoyr = []string{"Bugs", "Road", "Moose"}

// fieldsNotEmpty supports omitempty tags
func (z *Rocky) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (z.Bugs == nil) // pointer, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Road) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Moose == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Rocky) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zwuw [3]bool
	fieldsInUse_zexa := z.fieldsNotEmpty(empty_zwuw[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zexa)
	if err != nil {
		return err
	}

	if !empty_zwuw[0] {
		// write "Bugs"
		err = en.Append(0xa4, 0x42, 0x75, 0x67, 0x73)
		if err != nil {
			return err
		}
		if z.Bugs == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bugs.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zwuw[1] {
		// write "Road"
		err = en.Append(0xa4, 0x52, 0x6f, 0x61, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Road)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zwuw[2] {
		// write "Moose"
		err = en.Append(0xa5, 0x4d, 0x6f, 0x6f, 0x73, 0x65)
		if err != nil {
			return err
		}
		if z.Moose == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Moose.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Rocky) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Bugs"
		o = append(o, 0xa4, 0x42, 0x75, 0x67, 0x73)
		if z.Bugs == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bugs.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[1] {
		// string "Road"
		o = append(o, 0xa4, 0x52, 0x6f, 0x61, 0x64)
		o = msgp.AppendString(o, z.Road)
	}

	if !empty[2] {
		// string "Moose"
		o = append(o, 0xa5, 0x4d, 0x6f, 0x6f, 0x73, 0x65)
		if z.Moose == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Moose.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Rocky) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields26zlnf = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields26zlnf uint32
	if !nbs.AlwaysNil {
		totalEncodedFields26zlnf, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft26zlnf := totalEncodedFields26zlnf
	missingFieldsLeft26zlnf := maxFields26zlnf - totalEncodedFields26zlnf

	var nextMiss26zlnf int32 = -1
	var found26zlnf [maxFields26zlnf]bool
	var curField26zlnf string

doneWithStruct26zlnf:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft26zlnf > 0 || missingFieldsLeft26zlnf > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft26zlnf, missingFieldsLeft26zlnf, msgp.ShowFound(found26zlnf[:]), unmarshalMsgFieldOrder26zlnf)
		if encodedFieldsLeft26zlnf > 0 {
			encodedFieldsLeft26zlnf--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField26zlnf = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss26zlnf < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss26zlnf = 0
			}
			for nextMiss26zlnf < maxFields26zlnf && found26zlnf[nextMiss26zlnf] {
				nextMiss26zlnf++
			}
			if nextMiss26zlnf == maxFields26zlnf {
				// filled all the empty fields!
				break doneWithStruct26zlnf
			}
			missingFieldsLeft26zlnf--
			curField26zlnf = unmarshalMsgFieldOrder26zlnf[nextMiss26zlnf]
		}
		fmt.Printf("switching on curField: '%v'\n", curField26zlnf)
		switch curField26zlnf {
		// -- templateUnmarshalMsg ends here --

		case "Bugs":
			found26zlnf[0] = true
			if nbs.AlwaysNil {
				if z.Bugs != nil {
					z.Bugs.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bugs {
						z.Bugs.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bugs == nil {
						z.Bugs = new(Bunny)
					}
					bts, err = z.Bugs.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "Road":
			found26zlnf[1] = true
			z.Road, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Moose":
			found26zlnf[2] = true
			if nbs.AlwaysNil {
				if z.Moose != nil {
					z.Moose.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Moose {
						z.Moose.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Moose == nil {
						z.Moose = new(Moose)
					}
					bts, err = z.Moose.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss26zlnf != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Rocky
var unmarshalMsgFieldOrder26zlnf = []string{"Bugs", "Road", "Moose"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Rocky) Msgsize() (s int) {
	s = 1 + 5
	if z.Bugs == nil {
		s += msgp.NilSize
	} else {
		s += z.Bugs.Msgsize()
	}
	s += 5 + msgp.StringPrefixSize + len(z.Road) + 6
	if z.Moose == nil {
		s += msgp.NilSize
	} else {
		s += z.Moose.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestBench) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zsnx uint32
	zsnx, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zsnx != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zsnx}
		return
	}
	z.Name, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	z.BirthDay, err = dc.ReadTime()
	if err != nil {
		panic(err)
	}
	z.Phone, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	z.Siblings, err = dc.ReadInt()
	if err != nil {
		panic(err)
	}
	z.Spouse, err = dc.ReadBool()
	if err != nil {
		panic(err)
	}
	z.Money, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *TestBench) fieldsNotEmpty(isempty []bool) uint32 {
	return 6
}

// EncodeMsg implements msgp.Encodable
func (z *TestBench) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Name)
	if err != nil {
		panic(err)
	}
	err = en.WriteTime(z.BirthDay)
	if err != nil {
		panic(err)
	}
	err = en.WriteString(z.Phone)
	if err != nil {
		panic(err)
	}
	err = en.WriteInt(z.Siblings)
	if err != nil {
		panic(err)
	}
	err = en.WriteBool(z.Spouse)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Money)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestBench) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendString(o, z.Name)
	o = msgp.AppendTime(o, z.BirthDay)
	o = msgp.AppendString(o, z.Phone)
	o = msgp.AppendInt(o, z.Siblings)
	o = msgp.AppendBool(o, z.Spouse)
	o = msgp.AppendFloat64(o, z.Money)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestBench) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zria uint32
	zria, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zria != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zria}
		return
	}
	z.Name, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	z.BirthDay, bts, err = nbs.ReadTimeBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Phone, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Siblings, bts, err = nbs.ReadIntBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Spouse, bts, err = nbs.ReadBoolBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Money, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestBench) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Name) + msgp.TimeSize + msgp.StringPrefixSize + len(z.Phone) + msgp.IntSize + msgp.BoolSize + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestFast) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zwfe uint32
	zwfe, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zwfe != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zwfe}
		return
	}
	z.Lat, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Long, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Alt, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Data, err = dc.ReadBytes(z.Data)
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *TestFast) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *TestFast) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Lat)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Long)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Alt)
	if err != nil {
		panic(err)
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestFast) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendFloat64(o, z.Lat)
	o = msgp.AppendFloat64(o, z.Long)
	o = msgp.AppendFloat64(o, z.Alt)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestFast) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var ztny uint32
	ztny, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if ztny != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: ztny}
		return
	}
	z.Lat, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	z.Long, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	z.Alt, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	if nbs.AlwaysNil || msgp.IsNil(bts) {
		if !nbs.AlwaysNil {
			bts = bts[1:]
		}
		z.Data = z.Data[:0]
	} else {
		z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

		if err != nil {
			panic(err)
		}
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestFast) Msgsize() (s int) {
	s = 1 + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestHidden) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields27ztyl = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields27ztyl uint32
	totalEncodedFields27ztyl, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft27ztyl := totalEncodedFields27ztyl
	missingFieldsLeft27ztyl := maxFields27ztyl - totalEncodedFields27ztyl

	var nextMiss27ztyl int32 = -1
	var found27ztyl [maxFields27ztyl]bool
	var curField27ztyl string

doneWithStruct27ztyl:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft27ztyl > 0 || missingFieldsLeft27ztyl > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft27ztyl, missingFieldsLeft27ztyl, msgp.ShowFound(found27ztyl[:]), decodeMsgFieldOrder27ztyl)
		if encodedFieldsLeft27ztyl > 0 {
			encodedFieldsLeft27ztyl--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField27ztyl = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss27ztyl < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss27ztyl = 0
			}
			for nextMiss27ztyl < maxFields27ztyl && found27ztyl[nextMiss27ztyl] {
				nextMiss27ztyl++
			}
			if nextMiss27ztyl == maxFields27ztyl {
				// filled all the empty fields!
				break doneWithStruct27ztyl
			}
			missingFieldsLeft27ztyl--
			curField27ztyl = decodeMsgFieldOrder27ztyl[nextMiss27ztyl]
		}
		fmt.Printf("switching on curField: '%v'\n", curField27ztyl)
		switch curField27ztyl {
		// -- templateDecodeMsg ends here --

		case "A":
			found27ztyl[0] = true
			z.A, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "B":
			found27ztyl[1] = true
			var zhas uint32
			zhas, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.B) >= int(zhas) {
				z.B = (z.B)[:zhas]
			} else {
				z.B = make([]float64, zhas)
			}
			for zgzb := range z.B {
				z.B[zgzb], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss27ztyl != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestHidden
var decodeMsgFieldOrder27ztyl = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z *TestHidden) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *TestHidden) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "A"
	err = en.Append(0x82, 0xa1, 0x41)
	if err != nil {
		return err
	}
	err = en.WriteString(z.A)
	if err != nil {
		panic(err)
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.B)))
	if err != nil {
		panic(err)
	}
	for zgzb := range z.B {
		err = en.WriteFloat64(z.B[zgzb])
		if err != nil {
			panic(err)
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestHidden) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "A"
	o = append(o, 0x82, 0xa1, 0x41)
	o = msgp.AppendString(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendArrayHeader(o, uint32(len(z.B)))
	for zgzb := range z.B {
		o = msgp.AppendFloat64(o, z.B[zgzb])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestHidden) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields28zyjp = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields28zyjp uint32
	if !nbs.AlwaysNil {
		totalEncodedFields28zyjp, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft28zyjp := totalEncodedFields28zyjp
	missingFieldsLeft28zyjp := maxFields28zyjp - totalEncodedFields28zyjp

	var nextMiss28zyjp int32 = -1
	var found28zyjp [maxFields28zyjp]bool
	var curField28zyjp string

doneWithStruct28zyjp:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft28zyjp > 0 || missingFieldsLeft28zyjp > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft28zyjp, missingFieldsLeft28zyjp, msgp.ShowFound(found28zyjp[:]), unmarshalMsgFieldOrder28zyjp)
		if encodedFieldsLeft28zyjp > 0 {
			encodedFieldsLeft28zyjp--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField28zyjp = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss28zyjp < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss28zyjp = 0
			}
			for nextMiss28zyjp < maxFields28zyjp && found28zyjp[nextMiss28zyjp] {
				nextMiss28zyjp++
			}
			if nextMiss28zyjp == maxFields28zyjp {
				// filled all the empty fields!
				break doneWithStruct28zyjp
			}
			missingFieldsLeft28zyjp--
			curField28zyjp = unmarshalMsgFieldOrder28zyjp[nextMiss28zyjp]
		}
		fmt.Printf("switching on curField: '%v'\n", curField28zyjp)
		switch curField28zyjp {
		// -- templateUnmarshalMsg ends here --

		case "A":
			found28zyjp[0] = true
			z.A, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "B":
			found28zyjp[1] = true
			if nbs.AlwaysNil {
				(z.B) = (z.B)[:0]
			} else {

				var zmyz uint32
				zmyz, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.B) >= int(zmyz) {
					z.B = (z.B)[:zmyz]
				} else {
					z.B = make([]float64, zmyz)
				}
				for zgzb := range z.B {
					z.B[zgzb], bts, err = nbs.ReadFloat64Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss28zyjp != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestHidden
var unmarshalMsgFieldOrder28zyjp = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestHidden) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.A) + 2 + msgp.ArrayHeaderSize + (len(z.B) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestOmitEmpty) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields29zerb = 29

	// -- templateDecodeMsg starts here--
	var totalEncodedFields29zerb uint32
	totalEncodedFields29zerb, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft29zerb := totalEncodedFields29zerb
	missingFieldsLeft29zerb := maxFields29zerb - totalEncodedFields29zerb

	var nextMiss29zerb int32 = -1
	var found29zerb [maxFields29zerb]bool
	var curField29zerb string

doneWithStruct29zerb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft29zerb > 0 || missingFieldsLeft29zerb > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft29zerb, missingFieldsLeft29zerb, msgp.ShowFound(found29zerb[:]), decodeMsgFieldOrder29zerb)
		if encodedFieldsLeft29zerb > 0 {
			encodedFieldsLeft29zerb--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField29zerb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss29zerb < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss29zerb = 0
			}
			for nextMiss29zerb < maxFields29zerb && found29zerb[nextMiss29zerb] {
				nextMiss29zerb++
			}
			if nextMiss29zerb == maxFields29zerb {
				// filled all the empty fields!
				break doneWithStruct29zerb
			}
			missingFieldsLeft29zerb--
			curField29zerb = decodeMsgFieldOrder29zerb[nextMiss29zerb]
		}
		fmt.Printf("switching on curField: '%v'\n", curField29zerb)
		switch curField29zerb {
		// -- templateDecodeMsg ends here --

		case "Name":
			found29zerb[0] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "BirthDay":
			found29zerb[1] = true
			z.BirthDay, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "Phone":
			found29zerb[2] = true
			z.Phone, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Siblings":
			found29zerb[3] = true
			z.Siblings, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Spouse":
			found29zerb[4] = true
			z.Spouse, err = dc.ReadBool()
			if err != nil {
				panic(err)
			}
		case "Money":
			found29zerb[5] = true
			z.Money, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "SliceName":
			found29zerb[6] = true
			var zbht uint32
			zbht, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceName) >= int(zbht) {
				z.SliceName = (z.SliceName)[:zbht]
			} else {
				z.SliceName = make([]string, zbht)
			}
			for zajb := range z.SliceName {
				z.SliceName[zajb], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SliceBirthDay":
			found29zerb[7] = true
			var ztfg uint32
			ztfg, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceBirthDay) >= int(ztfg) {
				z.SliceBirthDay = (z.SliceBirthDay)[:ztfg]
			} else {
				z.SliceBirthDay = make([]time.Time, ztfg)
			}
			for zhwi := range z.SliceBirthDay {
				z.SliceBirthDay[zhwi], err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "SlicePhone":
			found29zerb[8] = true
			var zxwm uint32
			zxwm, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SlicePhone) >= int(zxwm) {
				z.SlicePhone = (z.SlicePhone)[:zxwm]
			} else {
				z.SlicePhone = make([]string, zxwm)
			}
			for zdju := range z.SlicePhone {
				z.SlicePhone[zdju], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SliceSiblings":
			found29zerb[9] = true
			var zlqe uint32
			zlqe, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceSiblings) >= int(zlqe) {
				z.SliceSiblings = (z.SliceSiblings)[:zlqe]
			} else {
				z.SliceSiblings = make([]int, zlqe)
			}
			for zunk := range z.SliceSiblings {
				z.SliceSiblings[zunk], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "SliceSpouse":
			found29zerb[10] = true
			var ziuc uint32
			ziuc, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceSpouse) >= int(ziuc) {
				z.SliceSpouse = (z.SliceSpouse)[:ziuc]
			} else {
				z.SliceSpouse = make([]bool, ziuc)
			}
			for zabn := range z.SliceSpouse {
				z.SliceSpouse[zabn], err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "SliceMoney":
			found29zerb[11] = true
			var zfts uint32
			zfts, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceMoney) >= int(zfts) {
				z.SliceMoney = (z.SliceMoney)[:zfts]
			} else {
				z.SliceMoney = make([]float64, zfts)
			}
			for zkqs := range z.SliceMoney {
				z.SliceMoney[zkqs], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayName":
			found29zerb[12] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zqkk uint32
				zqkk, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zqkk != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zqkk}
					return
				}
			}
			for ziir := range z.ArrayName {
				z.ArrayName[ziir], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayBirthDay":
			found29zerb[13] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zntx uint32
				zntx, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zntx != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zntx}
					return
				}
			}
			for zyie := range z.ArrayBirthDay {
				z.ArrayBirthDay[zyie], err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayPhone":
			found29zerb[14] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zvgr uint32
				zvgr, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zvgr != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zvgr}
					return
				}
			}
			for zaax := range z.ArrayPhone {
				z.ArrayPhone[zaax], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "ArraySiblings":
			found29zerb[15] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zwwm uint32
				zwwm, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zwwm != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zwwm}
					return
				}
			}
			for zyaz := range z.ArraySiblings {
				z.ArraySiblings[zyaz], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "ArraySpouse":
			found29zerb[16] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zbfe uint32
				zbfe, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zbfe != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zbfe}
					return
				}
			}
			for zkqh := range z.ArraySpouse {
				z.ArraySpouse[zkqh], err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayMoney":
			found29zerb[17] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zfgb uint32
				zfgb, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zfgb != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zfgb}
					return
				}
			}
			for zirr := range z.ArrayMoney {
				z.ArrayMoney[zirr], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "MapStringString":
			found29zerb[18] = true
			var zgld uint32
			zgld, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MapStringString == nil && zgld > 0 {
				z.MapStringString = make(map[string]string, zgld)
			} else if len(z.MapStringString) > 0 {
				for key, _ := range z.MapStringString {
					delete(z.MapStringString, key)
				}
			}
			for zgld > 0 {
				zgld--
				var zbee string
				var zglg string
				zbee, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zglg, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.MapStringString[zbee] = zglg
			}
		case "MapStringIface":
			found29zerb[19] = true
			var zlkm uint32
			zlkm, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MapStringIface == nil && zlkm > 0 {
				z.MapStringIface = make(map[string]interface{}, zlkm)
			} else if len(z.MapStringIface) > 0 {
				for key, _ := range z.MapStringIface {
					delete(z.MapStringIface, key)
				}
			}
			for zlkm > 0 {
				zlkm--
				var zszf string
				var zkyz interface{}
				zszf, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zkyz, err = dc.ReadIntf()
				if err != nil {
					panic(err)
				}
				z.MapStringIface[zszf] = zkyz
			}
		case "PtrName":
			found29zerb[20] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrName == nil {
					z.PtrName = new(string)
				}
				*z.PtrName, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "PtrBirthDay":
			found29zerb[21] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrBirthDay == nil {
					z.PtrBirthDay = new(time.Time)
				}
				*z.PtrBirthDay, err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "PtrPhone":
			found29zerb[22] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrPhone == nil {
					z.PtrPhone = new(string)
				}
				*z.PtrPhone, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "PtrSiblings":
			found29zerb[23] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrSiblings == nil {
					z.PtrSiblings = new(int)
				}
				*z.PtrSiblings, err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "PtrSpouse":
			found29zerb[24] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrSpouse == nil {
					z.PtrSpouse = new(bool)
				}
				*z.PtrSpouse, err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "PtrMoney":
			found29zerb[25] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrMoney == nil {
					z.PtrMoney = new(float64)
				}
				*z.PtrMoney, err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "Inside1":
			found29zerb[26] = true
			err = z.Inside1.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found29zerb[27] = true
			z.Greetings, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found29zerb[28] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bullwinkle != nil {
					dc.PushAlwaysNil()
					err = z.Bullwinkle.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bullwinkle == nil {
					z.Bullwinkle = new(Rocky)
				}
				err = z.Bullwinkle.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss29zerb != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestOmitEmpty
var decodeMsgFieldOrder29zerb = []string{"Name", "BirthDay", "Phone", "Siblings", "Spouse", "Money", "SliceName", "SliceBirthDay", "SlicePhone", "SliceSiblings", "SliceSpouse", "SliceMoney", "ArrayName", "ArrayBirthDay", "ArrayPhone", "ArraySiblings", "ArraySpouse", "ArrayMoney", "MapStringString", "MapStringIface", "PtrName", "PtrBirthDay", "PtrPhone", "PtrSiblings", "PtrSpouse", "PtrMoney", "Inside1", "Greetings", "Bullwinkle"}

// fieldsNotEmpty supports omitempty tags
func (z *TestOmitEmpty) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 29
	}
	var fieldsInUse uint32 = 29
	isempty[0] = (len(z.Name) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (z.BirthDay.IsZero()) // time.Time, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (len(z.Phone) == 0) // string, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (z.Siblings == 0) // number, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (!z.Spouse) // bool, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (z.Money == 0) // number, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (len(z.SliceName) == 0) // string, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (len(z.SliceBirthDay) == 0) // string, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (len(z.SlicePhone) == 0) // string, omitempty
	if isempty[8] {
		fieldsInUse--
	}
	isempty[9] = (len(z.SliceSiblings) == 0) // string, omitempty
	if isempty[9] {
		fieldsInUse--
	}
	isempty[10] = (len(z.SliceSpouse) == 0) // string, omitempty
	if isempty[10] {
		fieldsInUse--
	}
	isempty[11] = (len(z.SliceMoney) == 0) // string, omitempty
	if isempty[11] {
		fieldsInUse--
	}
	isempty[12] = (len(z.ArrayName) == 0) // string, omitempty
	if isempty[12] {
		fieldsInUse--
	}
	isempty[13] = (len(z.ArrayBirthDay) == 0) // string, omitempty
	if isempty[13] {
		fieldsInUse--
	}
	isempty[14] = (len(z.ArrayPhone) == 0) // string, omitempty
	if isempty[14] {
		fieldsInUse--
	}
	isempty[15] = (len(z.ArraySiblings) == 0) // string, omitempty
	if isempty[15] {
		fieldsInUse--
	}
	isempty[16] = (len(z.ArraySpouse) == 0) // string, omitempty
	if isempty[16] {
		fieldsInUse--
	}
	isempty[17] = (len(z.ArrayMoney) == 0) // string, omitempty
	if isempty[17] {
		fieldsInUse--
	}
	isempty[18] = (len(z.MapStringString) == 0) // string, omitempty
	if isempty[18] {
		fieldsInUse--
	}
	isempty[19] = (len(z.MapStringIface) == 0) // string, omitempty
	if isempty[19] {
		fieldsInUse--
	}
	isempty[20] = (z.PtrName == nil) // pointer, omitempty
	if isempty[20] {
		fieldsInUse--
	}
	isempty[21] = (z.PtrBirthDay == nil) // pointer, omitempty
	if isempty[21] {
		fieldsInUse--
	}
	isempty[22] = (z.PtrPhone == nil) // pointer, omitempty
	if isempty[22] {
		fieldsInUse--
	}
	isempty[23] = (z.PtrSiblings == nil) // pointer, omitempty
	if isempty[23] {
		fieldsInUse--
	}
	isempty[24] = (z.PtrSpouse == nil) // pointer, omitempty
	if isempty[24] {
		fieldsInUse--
	}
	isempty[25] = (z.PtrMoney == nil) // pointer, omitempty
	if isempty[25] {
		fieldsInUse--
	}
	isempty[26] = false
	if isempty[26] {
		fieldsInUse--
	}
	isempty[27] = (len(z.Greetings) == 0) // string, omitempty
	if isempty[27] {
		fieldsInUse--
	}
	isempty[28] = (z.Bullwinkle == nil) // pointer, omitempty
	if isempty[28] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *TestOmitEmpty) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zbgk [29]bool
	fieldsInUse_zwyv := z.fieldsNotEmpty(empty_zbgk[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zwyv)
	if err != nil {
		return err
	}

	if !empty_zbgk[0] {
		// write "Name"
		err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Name)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[1] {
		// write "BirthDay"
		err = en.Append(0xa8, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteTime(z.BirthDay)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[2] {
		// write "Phone"
		err = en.Append(0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Phone)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[3] {
		// write "Siblings"
		err = en.Append(0xa8, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.Siblings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[4] {
		// write "Spouse"
		err = en.Append(0xa6, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Spouse)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[5] {
		// write "Money"
		err = en.Append(0xa5, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteFloat64(z.Money)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[6] {
		// write "SliceName"
		err = en.Append(0xa9, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceName)))
		if err != nil {
			panic(err)
		}
		for zajb := range z.SliceName {
			err = en.WriteString(z.SliceName[zajb])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[7] {
		// write "SliceBirthDay"
		err = en.Append(0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceBirthDay)))
		if err != nil {
			panic(err)
		}
		for zhwi := range z.SliceBirthDay {
			err = en.WriteTime(z.SliceBirthDay[zhwi])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[8] {
		// write "SlicePhone"
		err = en.Append(0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SlicePhone)))
		if err != nil {
			panic(err)
		}
		for zdju := range z.SlicePhone {
			err = en.WriteString(z.SlicePhone[zdju])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[9] {
		// write "SliceSiblings"
		err = en.Append(0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceSiblings)))
		if err != nil {
			panic(err)
		}
		for zunk := range z.SliceSiblings {
			err = en.WriteInt(z.SliceSiblings[zunk])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[10] {
		// write "SliceSpouse"
		err = en.Append(0xab, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceSpouse)))
		if err != nil {
			panic(err)
		}
		for zabn := range z.SliceSpouse {
			err = en.WriteBool(z.SliceSpouse[zabn])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[11] {
		// write "SliceMoney"
		err = en.Append(0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceMoney)))
		if err != nil {
			panic(err)
		}
		for zkqs := range z.SliceMoney {
			err = en.WriteFloat64(z.SliceMoney[zkqs])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[12] {
		// write "ArrayName"
		err = en.Append(0xa9, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for ziir := range z.ArrayName {
			err = en.WriteString(z.ArrayName[ziir])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[13] {
		// write "ArrayBirthDay"
		err = en.Append(0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zyie := range z.ArrayBirthDay {
			err = en.WriteTime(z.ArrayBirthDay[zyie])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[14] {
		// write "ArrayPhone"
		err = en.Append(0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zaax := range z.ArrayPhone {
			err = en.WriteString(z.ArrayPhone[zaax])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[15] {
		// write "ArraySiblings"
		err = en.Append(0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zyaz := range z.ArraySiblings {
			err = en.WriteInt(z.ArraySiblings[zyaz])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[16] {
		// write "ArraySpouse"
		err = en.Append(0xab, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zkqh := range z.ArraySpouse {
			err = en.WriteBool(z.ArraySpouse[zkqh])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[17] {
		// write "ArrayMoney"
		err = en.Append(0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zirr := range z.ArrayMoney {
			err = en.WriteFloat64(z.ArrayMoney[zirr])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[18] {
		// write "MapStringString"
		err = en.Append(0xaf, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MapStringString)))
		if err != nil {
			panic(err)
		}
		for zbee, zglg := range z.MapStringString {
			err = en.WriteString(zbee)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zglg)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[19] {
		// write "MapStringIface"
		err = en.Append(0xae, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x66, 0x61, 0x63, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MapStringIface)))
		if err != nil {
			panic(err)
		}
		for zszf, zkyz := range z.MapStringIface {
			err = en.WriteString(zszf)
			if err != nil {
				panic(err)
			}
			err = en.WriteIntf(zkyz)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[20] {
		// write "PtrName"
		err = en.Append(0xa7, 0x50, 0x74, 0x72, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		if z.PtrName == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PtrName)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[21] {
		// write "PtrBirthDay"
		err = en.Append(0xab, 0x50, 0x74, 0x72, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		if z.PtrBirthDay == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteTime(*z.PtrBirthDay)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[22] {
		// write "PtrPhone"
		err = en.Append(0xa8, 0x50, 0x74, 0x72, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		if z.PtrPhone == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PtrPhone)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[23] {
		// write "PtrSiblings"
		err = en.Append(0xab, 0x50, 0x74, 0x72, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		if z.PtrSiblings == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.PtrSiblings)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[24] {
		// write "PtrSpouse"
		err = en.Append(0xa9, 0x50, 0x74, 0x72, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		if z.PtrSpouse == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.PtrSpouse)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[25] {
		// write "PtrMoney"
		err = en.Append(0xa8, 0x50, 0x74, 0x72, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		if z.PtrMoney == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.PtrMoney)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zbgk[26] {
		// write "Inside1"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		if err != nil {
			return err
		}
		err = z.Inside1.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[27] {
		// write "Greetings"
		err = en.Append(0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Greetings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zbgk[28] {
		// write "Bullwinkle"
		err = en.Append(0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if err != nil {
			return err
		}
		if z.Bullwinkle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullwinkle.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestOmitEmpty) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [29]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Name"
		o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
	}

	if !empty[1] {
		// string "BirthDay"
		o = append(o, 0xa8, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendTime(o, z.BirthDay)
	}

	if !empty[2] {
		// string "Phone"
		o = append(o, 0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendString(o, z.Phone)
	}

	if !empty[3] {
		// string "Siblings"
		o = append(o, 0xa8, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendInt(o, z.Siblings)
	}

	if !empty[4] {
		// string "Spouse"
		o = append(o, 0xa6, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendBool(o, z.Spouse)
	}

	if !empty[5] {
		// string "Money"
		o = append(o, 0xa5, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendFloat64(o, z.Money)
	}

	if !empty[6] {
		// string "SliceName"
		o = append(o, 0xa9, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceName)))
		for zajb := range z.SliceName {
			o = msgp.AppendString(o, z.SliceName[zajb])
		}
	}

	if !empty[7] {
		// string "SliceBirthDay"
		o = append(o, 0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceBirthDay)))
		for zhwi := range z.SliceBirthDay {
			o = msgp.AppendTime(o, z.SliceBirthDay[zhwi])
		}
	}

	if !empty[8] {
		// string "SlicePhone"
		o = append(o, 0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SlicePhone)))
		for zdju := range z.SlicePhone {
			o = msgp.AppendString(o, z.SlicePhone[zdju])
		}
	}

	if !empty[9] {
		// string "SliceSiblings"
		o = append(o, 0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceSiblings)))
		for zunk := range z.SliceSiblings {
			o = msgp.AppendInt(o, z.SliceSiblings[zunk])
		}
	}

	if !empty[10] {
		// string "SliceSpouse"
		o = append(o, 0xab, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceSpouse)))
		for zabn := range z.SliceSpouse {
			o = msgp.AppendBool(o, z.SliceSpouse[zabn])
		}
	}

	if !empty[11] {
		// string "SliceMoney"
		o = append(o, 0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceMoney)))
		for zkqs := range z.SliceMoney {
			o = msgp.AppendFloat64(o, z.SliceMoney[zkqs])
		}
	}

	if !empty[12] {
		// string "ArrayName"
		o = append(o, 0xa9, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for ziir := range z.ArrayName {
			o = msgp.AppendString(o, z.ArrayName[ziir])
		}
	}

	if !empty[13] {
		// string "ArrayBirthDay"
		o = append(o, 0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zyie := range z.ArrayBirthDay {
			o = msgp.AppendTime(o, z.ArrayBirthDay[zyie])
		}
	}

	if !empty[14] {
		// string "ArrayPhone"
		o = append(o, 0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zaax := range z.ArrayPhone {
			o = msgp.AppendString(o, z.ArrayPhone[zaax])
		}
	}

	if !empty[15] {
		// string "ArraySiblings"
		o = append(o, 0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, 3)
		for zyaz := range z.ArraySiblings {
			o = msgp.AppendInt(o, z.ArraySiblings[zyaz])
		}
	}

	if !empty[16] {
		// string "ArraySpouse"
		o = append(o, 0xab, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zkqh := range z.ArraySpouse {
			o = msgp.AppendBool(o, z.ArraySpouse[zkqh])
		}
	}

	if !empty[17] {
		// string "ArrayMoney"
		o = append(o, 0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zirr := range z.ArrayMoney {
			o = msgp.AppendFloat64(o, z.ArrayMoney[zirr])
		}
	}

	if !empty[18] {
		// string "MapStringString"
		o = append(o, 0xaf, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
		o = msgp.AppendMapHeader(o, uint32(len(z.MapStringString)))
		for zbee, zglg := range z.MapStringString {
			o = msgp.AppendString(o, zbee)
			o = msgp.AppendString(o, zglg)
		}
	}

	if !empty[19] {
		// string "MapStringIface"
		o = append(o, 0xae, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x66, 0x61, 0x63, 0x65)
		o = msgp.AppendMapHeader(o, uint32(len(z.MapStringIface)))
		for zszf, zkyz := range z.MapStringIface {
			o = msgp.AppendString(o, zszf)
			o, err = msgp.AppendIntf(o, zkyz)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[20] {
		// string "PtrName"
		o = append(o, 0xa7, 0x50, 0x74, 0x72, 0x4e, 0x61, 0x6d, 0x65)
		if z.PtrName == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PtrName)
		}
	}

	if !empty[21] {
		// string "PtrBirthDay"
		o = append(o, 0xab, 0x50, 0x74, 0x72, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if z.PtrBirthDay == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendTime(o, *z.PtrBirthDay)
		}
	}

	if !empty[22] {
		// string "PtrPhone"
		o = append(o, 0xa8, 0x50, 0x74, 0x72, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if z.PtrPhone == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PtrPhone)
		}
	}

	if !empty[23] {
		// string "PtrSiblings"
		o = append(o, 0xab, 0x50, 0x74, 0x72, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if z.PtrSiblings == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.PtrSiblings)
		}
	}

	if !empty[24] {
		// string "PtrSpouse"
		o = append(o, 0xa9, 0x50, 0x74, 0x72, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if z.PtrSpouse == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.PtrSpouse)
		}
	}

	if !empty[25] {
		// string "PtrMoney"
		o = append(o, 0xa8, 0x50, 0x74, 0x72, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if z.PtrMoney == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.PtrMoney)
		}
	}

	if !empty[26] {
		// string "Inside1"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		o, err = z.Inside1.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}

	if !empty[27] {
		// string "Greetings"
		o = append(o, 0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendString(o, z.Greetings)
	}

	if !empty[28] {
		// string "Bullwinkle"
		o = append(o, 0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if z.Bullwinkle == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullwinkle.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestOmitEmpty) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields30zqrm = 29

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields30zqrm uint32
	if !nbs.AlwaysNil {
		totalEncodedFields30zqrm, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft30zqrm := totalEncodedFields30zqrm
	missingFieldsLeft30zqrm := maxFields30zqrm - totalEncodedFields30zqrm

	var nextMiss30zqrm int32 = -1
	var found30zqrm [maxFields30zqrm]bool
	var curField30zqrm string

doneWithStruct30zqrm:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft30zqrm > 0 || missingFieldsLeft30zqrm > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft30zqrm, missingFieldsLeft30zqrm, msgp.ShowFound(found30zqrm[:]), unmarshalMsgFieldOrder30zqrm)
		if encodedFieldsLeft30zqrm > 0 {
			encodedFieldsLeft30zqrm--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField30zqrm = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss30zqrm < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss30zqrm = 0
			}
			for nextMiss30zqrm < maxFields30zqrm && found30zqrm[nextMiss30zqrm] {
				nextMiss30zqrm++
			}
			if nextMiss30zqrm == maxFields30zqrm {
				// filled all the empty fields!
				break doneWithStruct30zqrm
			}
			missingFieldsLeft30zqrm--
			curField30zqrm = unmarshalMsgFieldOrder30zqrm[nextMiss30zqrm]
		}
		fmt.Printf("switching on curField: '%v'\n", curField30zqrm)
		switch curField30zqrm {
		// -- templateUnmarshalMsg ends here --

		case "Name":
			found30zqrm[0] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "BirthDay":
			found30zqrm[1] = true
			z.BirthDay, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Phone":
			found30zqrm[2] = true
			z.Phone, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Siblings":
			found30zqrm[3] = true
			z.Siblings, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Spouse":
			found30zqrm[4] = true
			z.Spouse, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Money":
			found30zqrm[5] = true
			z.Money, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "SliceName":
			found30zqrm[6] = true
			if nbs.AlwaysNil {
				(z.SliceName) = (z.SliceName)[:0]
			} else {

				var zkoe uint32
				zkoe, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceName) >= int(zkoe) {
					z.SliceName = (z.SliceName)[:zkoe]
				} else {
					z.SliceName = make([]string, zkoe)
				}
				for zajb := range z.SliceName {
					z.SliceName[zajb], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceBirthDay":
			found30zqrm[7] = true
			if nbs.AlwaysNil {
				(z.SliceBirthDay) = (z.SliceBirthDay)[:0]
			} else {

				var zzob uint32
				zzob, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceBirthDay) >= int(zzob) {
					z.SliceBirthDay = (z.SliceBirthDay)[:zzob]
				} else {
					z.SliceBirthDay = make([]time.Time, zzob)
				}
				for zhwi := range z.SliceBirthDay {
					z.SliceBirthDay[zhwi], bts, err = nbs.ReadTimeBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SlicePhone":
			found30zqrm[8] = true
			if nbs.AlwaysNil {
				(z.SlicePhone) = (z.SlicePhone)[:0]
			} else {

				var zotb uint32
				zotb, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SlicePhone) >= int(zotb) {
					z.SlicePhone = (z.SlicePhone)[:zotb]
				} else {
					z.SlicePhone = make([]string, zotb)
				}
				for zdju := range z.SlicePhone {
					z.SlicePhone[zdju], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceSiblings":
			found30zqrm[9] = true
			if nbs.AlwaysNil {
				(z.SliceSiblings) = (z.SliceSiblings)[:0]
			} else {

				var zcem uint32
				zcem, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceSiblings) >= int(zcem) {
					z.SliceSiblings = (z.SliceSiblings)[:zcem]
				} else {
					z.SliceSiblings = make([]int, zcem)
				}
				for zunk := range z.SliceSiblings {
					z.SliceSiblings[zunk], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceSpouse":
			found30zqrm[10] = true
			if nbs.AlwaysNil {
				(z.SliceSpouse) = (z.SliceSpouse)[:0]
			} else {

				var zotb uint32
				zotb, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceSpouse) >= int(zotb) {
					z.SliceSpouse = (z.SliceSpouse)[:zotb]
				} else {
					z.SliceSpouse = make([]bool, zotb)
				}
				for zabn := range z.SliceSpouse {
					z.SliceSpouse[zabn], bts, err = nbs.ReadBoolBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceMoney":
			found30zqrm[11] = true
			if nbs.AlwaysNil {
				(z.SliceMoney) = (z.SliceMoney)[:0]
			} else {

				var ztuh uint32
				ztuh, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceMoney) >= int(ztuh) {
					z.SliceMoney = (z.SliceMoney)[:ztuh]
				} else {
					z.SliceMoney = make([]float64, ztuh)
				}
				for zkqs := range z.SliceMoney {
					z.SliceMoney[zkqs], bts, err = nbs.ReadFloat64Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "ArrayName":
			found30zqrm[12] = true
			var zumb uint32
			zumb, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zumb != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zumb}
				return
			}
			for ziir := range z.ArrayName {
				z.ArrayName[ziir], bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayBirthDay":
			found30zqrm[13] = true
			var zvjf uint32
			zvjf, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zvjf != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zvjf}
				return
			}
			for zyie := range z.ArrayBirthDay {
				z.ArrayBirthDay[zyie], bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayPhone":
			found30zqrm[14] = true
			var zrpa uint32
			zrpa, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zrpa != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zrpa}
				return
			}
			for zaax := range z.ArrayPhone {
				z.ArrayPhone[zaax], bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArraySiblings":
			found30zqrm[15] = true
			var zuzt uint32
			zuzt, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zuzt != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zuzt}
				return
			}
			for zyaz := range z.ArraySiblings {
				z.ArraySiblings[zyaz], bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArraySpouse":
			found30zqrm[16] = true
			var zqsj uint32
			zqsj, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zqsj != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zqsj}
				return
			}
			for zkqh := range z.ArraySpouse {
				z.ArraySpouse[zkqh], bts, err = nbs.ReadBoolBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayMoney":
			found30zqrm[17] = true
			var zfsr uint32
			zfsr, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zfsr != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zfsr}
				return
			}
			for zirr := range z.ArrayMoney {
				z.ArrayMoney[zirr], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "MapStringString":
			found30zqrm[18] = true
			if nbs.AlwaysNil {
				if len(z.MapStringString) > 0 {
					for key, _ := range z.MapStringString {
						delete(z.MapStringString, key)
					}
				}

			} else {

				var zdjc uint32
				zdjc, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MapStringString == nil && zdjc > 0 {
					z.MapStringString = make(map[string]string, zdjc)
				} else if len(z.MapStringString) > 0 {
					for key, _ := range z.MapStringString {
						delete(z.MapStringString, key)
					}
				}
				for zdjc > 0 {
					var zbee string
					var zglg string
					zdjc--
					zbee, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zglg, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MapStringString[zbee] = zglg
				}
			}
		case "MapStringIface":
			found30zqrm[19] = true
			if nbs.AlwaysNil {
				if len(z.MapStringIface) > 0 {
					for key, _ := range z.MapStringIface {
						delete(z.MapStringIface, key)
					}
				}

			} else {

				var zils uint32
				zils, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MapStringIface == nil && zils > 0 {
					z.MapStringIface = make(map[string]interface{}, zils)
				} else if len(z.MapStringIface) > 0 {
					for key, _ := range z.MapStringIface {
						delete(z.MapStringIface, key)
					}
				}
				for zils > 0 {
					var zszf string
					var zkyz interface{}
					zils--
					zszf, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zkyz, bts, err = nbs.ReadIntfBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MapStringIface[zszf] = zkyz
				}
			}
		case "PtrName":
			found30zqrm[20] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrName != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrName", alias:"*string"}, Value:(*gen.BaseElem)(0xc42026aaa0)}
					(z.PtrName) = nil
				}
			} else { // wire has bytes

				if z.PtrName == nil {
					z.PtrName = new(string)
				}
				*z.PtrName, bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrBirthDay":
			found30zqrm[21] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrBirthDay != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrBirthDay", alias:"*time.Time"}, Value:(*gen.BaseElem)(0xc42026aaf0)}
					(z.PtrBirthDay) = nil
				}
			} else { // wire has bytes

				if z.PtrBirthDay == nil {
					z.PtrBirthDay = new(time.Time)
				}
				*z.PtrBirthDay, bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrPhone":
			found30zqrm[22] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrPhone != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrPhone", alias:"*string"}, Value:(*gen.BaseElem)(0xc42026ab40)}
					(z.PtrPhone) = nil
				}
			} else { // wire has bytes

				if z.PtrPhone == nil {
					z.PtrPhone = new(string)
				}
				*z.PtrPhone, bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrSiblings":
			found30zqrm[23] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrSiblings != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrSiblings", alias:"*int"}, Value:(*gen.BaseElem)(0xc42026ab90)}
					(z.PtrSiblings) = nil
				}
			} else { // wire has bytes

				if z.PtrSiblings == nil {
					z.PtrSiblings = new(int)
				}
				*z.PtrSiblings, bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrSpouse":
			found30zqrm[24] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrSpouse != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrSpouse", alias:"*bool"}, Value:(*gen.BaseElem)(0xc42026abe0)}
					(z.PtrSpouse) = nil
				}
			} else { // wire has bytes

				if z.PtrSpouse == nil {
					z.PtrSpouse = new(bool)
				}
				*z.PtrSpouse, bts, err = nbs.ReadBoolBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrMoney":
			found30zqrm[25] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrMoney != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrMoney", alias:"*float64"}, Value:(*gen.BaseElem)(0xc42026ac30)}
					(z.PtrMoney) = nil
				}
			} else { // wire has bytes

				if z.PtrMoney == nil {
					z.PtrMoney = new(float64)
				}
				*z.PtrMoney, bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "Inside1":
			found30zqrm[26] = true
			bts, err = z.Inside1.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found30zqrm[27] = true
			z.Greetings, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found30zqrm[28] = true
			if nbs.AlwaysNil {
				if z.Bullwinkle != nil {
					z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bullwinkle {
						z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bullwinkle == nil {
						z.Bullwinkle = new(Rocky)
					}
					bts, err = z.Bullwinkle.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss30zqrm != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestOmitEmpty
var unmarshalMsgFieldOrder30zqrm = []string{"Name", "BirthDay", "Phone", "Siblings", "Spouse", "Money", "SliceName", "SliceBirthDay", "SlicePhone", "SliceSiblings", "SliceSpouse", "SliceMoney", "ArrayName", "ArrayBirthDay", "ArrayPhone", "ArraySiblings", "ArraySpouse", "ArrayMoney", "MapStringString", "MapStringIface", "PtrName", "PtrBirthDay", "PtrPhone", "PtrSiblings", "PtrSpouse", "PtrMoney", "Inside1", "Greetings", "Bullwinkle"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestOmitEmpty) Msgsize() (s int) {
	s = 3 + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.TimeSize + 6 + msgp.StringPrefixSize + len(z.Phone) + 9 + msgp.IntSize + 7 + msgp.BoolSize + 6 + msgp.Float64Size + 10 + msgp.ArrayHeaderSize
	for zajb := range z.SliceName {
		s += msgp.StringPrefixSize + len(z.SliceName[zajb])
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.SliceBirthDay) * (msgp.TimeSize)) + 11 + msgp.ArrayHeaderSize
	for zdju := range z.SlicePhone {
		s += msgp.StringPrefixSize + len(z.SlicePhone[zdju])
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.SliceSiblings) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.SliceSpouse) * (msgp.BoolSize)) + 11 + msgp.ArrayHeaderSize + (len(z.SliceMoney) * (msgp.Float64Size)) + 10 + msgp.ArrayHeaderSize
	for ziir := range z.ArrayName {
		s += msgp.StringPrefixSize + len(z.ArrayName[ziir])
	}
	s += 14 + msgp.ArrayHeaderSize + (3 * (msgp.TimeSize)) + 11 + msgp.ArrayHeaderSize
	for zaax := range z.ArrayPhone {
		s += msgp.StringPrefixSize + len(z.ArrayPhone[zaax])
	}
	s += 14 + msgp.ArrayHeaderSize + (3 * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (3 * (msgp.BoolSize)) + 11 + msgp.ArrayHeaderSize + (3 * (msgp.Float64Size)) + 16 + msgp.MapHeaderSize
	if z.MapStringString != nil {
		for zbee, zglg := range z.MapStringString {
			_ = zglg
			s += msgp.StringPrefixSize + len(zbee) + msgp.StringPrefixSize + len(zglg)
		}
	}
	s += 15 + msgp.MapHeaderSize
	if z.MapStringIface != nil {
		for zszf, zkyz := range z.MapStringIface {
			_ = zkyz
			s += msgp.StringPrefixSize + len(zszf) + msgp.GuessSize(zkyz)
		}
	}
	s += 8
	if z.PtrName == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PtrName)
	}
	s += 12
	if z.PtrBirthDay == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 9
	if z.PtrPhone == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PtrPhone)
	}
	s += 12
	if z.PtrSiblings == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.PtrSpouse == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 9
	if z.PtrMoney == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 8 + z.Inside1.Msgsize() + 10 + msgp.StringPrefixSize + len(z.Greetings) + 11
	if z.Bullwinkle == nil {
		s += msgp.NilSize
	} else {
		s += z.Bullwinkle.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestType) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields31zvjt = 11

	// -- templateDecodeMsg starts here--
	var totalEncodedFields31zvjt uint32
	totalEncodedFields31zvjt, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft31zvjt := totalEncodedFields31zvjt
	missingFieldsLeft31zvjt := maxFields31zvjt - totalEncodedFields31zvjt

	var nextMiss31zvjt int32 = -1
	var found31zvjt [maxFields31zvjt]bool
	var curField31zvjt string

doneWithStruct31zvjt:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft31zvjt > 0 || missingFieldsLeft31zvjt > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft31zvjt, missingFieldsLeft31zvjt, msgp.ShowFound(found31zvjt[:]), decodeMsgFieldOrder31zvjt)
		if encodedFieldsLeft31zvjt > 0 {
			encodedFieldsLeft31zvjt--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField31zvjt = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss31zvjt < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss31zvjt = 0
			}
			for nextMiss31zvjt < maxFields31zvjt && found31zvjt[nextMiss31zvjt] {
				nextMiss31zvjt++
			}
			if nextMiss31zvjt == maxFields31zvjt {
				// filled all the empty fields!
				break doneWithStruct31zvjt
			}
			missingFieldsLeft31zvjt--
			curField31zvjt = decodeMsgFieldOrder31zvjt[nextMiss31zvjt]
		}
		fmt.Printf("switching on curField: '%v'\n", curField31zvjt)
		switch curField31zvjt {
		// -- templateDecodeMsg ends here --

		case "float":
			found31zvjt[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.F == nil {
					z.F = new(float64)
				}
				*z.F, err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "elements":
			found31zvjt[1] = true
			var zvhj uint32
			zvhj, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Els == nil && zvhj > 0 {
				z.Els = make(map[string]string, zvhj)
			} else if len(z.Els) > 0 {
				for key, _ := range z.Els {
					delete(z.Els, key)
				}
			}
			for zvhj > 0 {
				zvhj--
				var zuam string
				var zrao string
				zuam, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zrao, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Els[zuam] = zrao
			}
		case "object":
			found31zvjt[2] = true
			const maxFields32zlra = 2

			// -- templateDecodeMsg starts here--
			var totalEncodedFields32zlra uint32
			totalEncodedFields32zlra, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft32zlra := totalEncodedFields32zlra
			missingFieldsLeft32zlra := maxFields32zlra - totalEncodedFields32zlra

			var nextMiss32zlra int32 = -1
			var found32zlra [maxFields32zlra]bool
			var curField32zlra string

		doneWithStruct32zlra:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft32zlra > 0 || missingFieldsLeft32zlra > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft32zlra, missingFieldsLeft32zlra, msgp.ShowFound(found32zlra[:]), decodeMsgFieldOrder32zlra)
				if encodedFieldsLeft32zlra > 0 {
					encodedFieldsLeft32zlra--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField32zlra = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss32zlra < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss32zlra = 0
					}
					for nextMiss32zlra < maxFields32zlra && found32zlra[nextMiss32zlra] {
						nextMiss32zlra++
					}
					if nextMiss32zlra == maxFields32zlra {
						// filled all the empty fields!
						break doneWithStruct32zlra
					}
					missingFieldsLeft32zlra--
					curField32zlra = decodeMsgFieldOrder32zlra[nextMiss32zlra]
				}
				fmt.Printf("switching on curField: '%v'\n", curField32zlra)
				switch curField32zlra {
				// -- templateDecodeMsg ends here --

				case "value_a":
					found32zlra[0] = true
					z.Obj.ValueA, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				case "value_b":
					found32zlra[1] = true
					z.Obj.ValueB, err = dc.ReadBytes(z.Obj.ValueB)
					if err != nil {
						panic(err)
					}
				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss32zlra != -1 {
				dc.PopAlwaysNil()
			}

		case "child":
			found31zvjt[3] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Child != nil {
					dc.PushAlwaysNil()
					err = z.Child.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Child == nil {
					z.Child = new(TestType)
				}
				err = z.Child.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "time":
			found31zvjt[4] = true
			z.Time, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "any":
			found31zvjt[5] = true
			z.Any, err = dc.ReadIntf()
			if err != nil {
				panic(err)
			}
		case "appended":
			found31zvjt[6] = true
			err = z.Appended.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "num":
			found31zvjt[7] = true
			err = z.Num.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "Slice1":
			found31zvjt[8] = true
			var zbnf uint32
			zbnf, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Slice1) >= int(zbnf) {
				z.Slice1 = (z.Slice1)[:zbnf]
			} else {
				z.Slice1 = make([]string, zbnf)
			}
			for zxrw := range z.Slice1 {
				z.Slice1[zxrw], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "Slice2":
			found31zvjt[9] = true
			var zdxi uint32
			zdxi, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Slice2) >= int(zdxi) {
				z.Slice2 = (z.Slice2)[:zdxi]
			} else {
				z.Slice2 = make([]string, zdxi)
			}
			for zbiy := range z.Slice2 {
				z.Slice2[zbiy], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SlicePtr":
			found31zvjt[10] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				z.SlicePtr = nil
			} else {
				if z.SlicePtr == nil {
					z.SlicePtr = new([]string)
				}
				var zfzz uint32
				zfzz, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if cap(*z.SlicePtr) >= int(zfzz) {
					*z.SlicePtr = (*z.SlicePtr)[:zfzz]
				} else {
					*z.SlicePtr = make([]string, zfzz)
				}
				for zyig := range *z.SlicePtr {
					(*z.SlicePtr)[zyig], err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss31zvjt != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestType
var decodeMsgFieldOrder31zvjt = []string{"float", "elements", "object", "child", "time", "any", "appended", "num", "Slice1", "Slice2", "SlicePtr"}

// fields of struct{;ValueA string;;ValueB []byte;;}
var decodeMsgFieldOrder32zlra = []string{"value_a", "value_b"}

// fieldsNotEmpty supports omitempty tags
func (z *TestType) fieldsNotEmpty(isempty []bool) uint32 {
	return 11
}

// EncodeMsg implements msgp.Encodable
func (z *TestType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "float"
	err = en.Append(0x8b, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74)
	if err != nil {
		return err
	}
	if z.F == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteFloat64(*z.F)
		if err != nil {
			panic(err)
		}
	}
	// write "elements"
	err = en.Append(0xa8, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Els)))
	if err != nil {
		panic(err)
	}
	for zuam, zrao := range z.Els {
		err = en.WriteString(zuam)
		if err != nil {
			panic(err)
		}
		err = en.WriteString(zrao)
		if err != nil {
			panic(err)
		}
	}
	// write "object"
	// map header, size 2
	// write "value_a"
	err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x82, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Obj.ValueA)
	if err != nil {
		panic(err)
	}
	// write "value_b"
	err = en.Append(0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Obj.ValueB)
	if err != nil {
		panic(err)
	}
	// write "child"
	err = en.Append(0xa5, 0x63, 0x68, 0x69, 0x6c, 0x64)
	if err != nil {
		return err
	}
	if z.Child == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Child.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "time"
	err = en.Append(0xa4, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteTime(z.Time)
	if err != nil {
		panic(err)
	}
	// write "any"
	err = en.Append(0xa3, 0x61, 0x6e, 0x79)
	if err != nil {
		return err
	}
	err = en.WriteIntf(z.Any)
	if err != nil {
		panic(err)
	}
	// write "appended"
	err = en.Append(0xa8, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x65, 0x64)
	if err != nil {
		return err
	}
	err = z.Appended.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	// write "num"
	err = en.Append(0xa3, 0x6e, 0x75, 0x6d)
	if err != nil {
		return err
	}
	err = z.Num.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	// write "Slice1"
	err = en.Append(0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x31)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice1)))
	if err != nil {
		panic(err)
	}
	for zxrw := range z.Slice1 {
		err = en.WriteString(z.Slice1[zxrw])
		if err != nil {
			panic(err)
		}
	}
	// write "Slice2"
	err = en.Append(0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x32)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice2)))
	if err != nil {
		panic(err)
	}
	for zbiy := range z.Slice2 {
		err = en.WriteString(z.Slice2[zbiy])
		if err != nil {
			panic(err)
		}
	}
	// write "SlicePtr"
	err = en.Append(0xa8, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x74, 0x72)
	if err != nil {
		return err
	}
	if z.SlicePtr == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteArrayHeader(uint32(len(*z.SlicePtr)))
		if err != nil {
			panic(err)
		}
		for zyig := range *z.SlicePtr {
			err = en.WriteString((*z.SlicePtr)[zyig])
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "float"
	o = append(o, 0x8b, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74)
	if z.F == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendFloat64(o, *z.F)
	}
	// string "elements"
	o = append(o, 0xa8, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Els)))
	for zuam, zrao := range z.Els {
		o = msgp.AppendString(o, zuam)
		o = msgp.AppendString(o, zrao)
	}
	// string "object"
	// map header, size 2
	// string "value_a"
	o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x82, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x61)
	o = msgp.AppendString(o, z.Obj.ValueA)
	// string "value_b"
	o = append(o, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62)
	o = msgp.AppendBytes(o, z.Obj.ValueB)
	// string "child"
	o = append(o, 0xa5, 0x63, 0x68, 0x69, 0x6c, 0x64)
	if z.Child == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Child.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "time"
	o = append(o, 0xa4, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Time)
	// string "any"
	o = append(o, 0xa3, 0x61, 0x6e, 0x79)
	o, err = msgp.AppendIntf(o, z.Any)
	if err != nil {
		panic(err)
	}
	// string "appended"
	o = append(o, 0xa8, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x65, 0x64)
	o, err = z.Appended.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	// string "num"
	o = append(o, 0xa3, 0x6e, 0x75, 0x6d)
	o, err = z.Num.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	// string "Slice1"
	o = append(o, 0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice1)))
	for zxrw := range z.Slice1 {
		o = msgp.AppendString(o, z.Slice1[zxrw])
	}
	// string "Slice2"
	o = append(o, 0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice2)))
	for zbiy := range z.Slice2 {
		o = msgp.AppendString(o, z.Slice2[zbiy])
	}
	// string "SlicePtr"
	o = append(o, 0xa8, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x74, 0x72)
	if z.SlicePtr == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.SlicePtr)))
		for zyig := range *z.SlicePtr {
			o = msgp.AppendString(o, (*z.SlicePtr)[zyig])
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields33zojd = 11

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields33zojd uint32
	if !nbs.AlwaysNil {
		totalEncodedFields33zojd, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft33zojd := totalEncodedFields33zojd
	missingFieldsLeft33zojd := maxFields33zojd - totalEncodedFields33zojd

	var nextMiss33zojd int32 = -1
	var found33zojd [maxFields33zojd]bool
	var curField33zojd string

doneWithStruct33zojd:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft33zojd > 0 || missingFieldsLeft33zojd > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft33zojd, missingFieldsLeft33zojd, msgp.ShowFound(found33zojd[:]), unmarshalMsgFieldOrder33zojd)
		if encodedFieldsLeft33zojd > 0 {
			encodedFieldsLeft33zojd--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField33zojd = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss33zojd < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss33zojd = 0
			}
			for nextMiss33zojd < maxFields33zojd && found33zojd[nextMiss33zojd] {
				nextMiss33zojd++
			}
			if nextMiss33zojd == maxFields33zojd {
				// filled all the empty fields!
				break doneWithStruct33zojd
			}
			missingFieldsLeft33zojd--
			curField33zojd = unmarshalMsgFieldOrder33zojd[nextMiss33zojd]
		}
		fmt.Printf("switching on curField: '%v'\n", curField33zojd)
		switch curField33zojd {
		// -- templateUnmarshalMsg ends here --

		case "float":
			found33zojd[0] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.F == nil {
				// nothing more to do
			} else {
				if z.F == nil {
					z.F = new(float64)
				}
				*z.F, bts, err = nbs.ReadFloat64Bytes(bts)
				if err != nil {
					panic(err)
				}
			}

		case "elements":
			found33zojd[1] = true
			if nbs.AlwaysNil {
				if len(z.Els) > 0 {
					for key, _ := range z.Els {
						delete(z.Els, key)
					}
				}

			} else {

				var zvoy uint32
				zvoy, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Els == nil && zvoy > 0 {
					z.Els = make(map[string]string, zvoy)
				} else if len(z.Els) > 0 {
					for key, _ := range z.Els {
						delete(z.Els, key)
					}
				}
				for zvoy > 0 {
					var zuam string
					var zrao string
					zvoy--
					zuam, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zrao, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Els[zuam] = zrao
				}
			}
		case "object":
			found33zojd[2] = true
			const maxFields34zsil = 2

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields34zsil uint32
			if !nbs.AlwaysNil {
				totalEncodedFields34zsil, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft34zsil := totalEncodedFields34zsil
			missingFieldsLeft34zsil := maxFields34zsil - totalEncodedFields34zsil

			var nextMiss34zsil int32 = -1
			var found34zsil [maxFields34zsil]bool
			var curField34zsil string

		doneWithStruct34zsil:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft34zsil > 0 || missingFieldsLeft34zsil > 0 {
				fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft34zsil, missingFieldsLeft34zsil, msgp.ShowFound(found34zsil[:]), unmarshalMsgFieldOrder34zsil)
				if encodedFieldsLeft34zsil > 0 {
					encodedFieldsLeft34zsil--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField34zsil = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss34zsil < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss34zsil = 0
					}
					for nextMiss34zsil < maxFields34zsil && found34zsil[nextMiss34zsil] {
						nextMiss34zsil++
					}
					if nextMiss34zsil == maxFields34zsil {
						// filled all the empty fields!
						break doneWithStruct34zsil
					}
					missingFieldsLeft34zsil--
					curField34zsil = unmarshalMsgFieldOrder34zsil[nextMiss34zsil]
				}
				fmt.Printf("switching on curField: '%v'\n", curField34zsil)
				switch curField34zsil {
				// -- templateUnmarshalMsg ends here --

				case "value_a":
					found34zsil[0] = true
					z.Obj.ValueA, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				case "value_b":
					found34zsil[1] = true
					if nbs.AlwaysNil || msgp.IsNil(bts) {
						if !nbs.AlwaysNil {
							bts = bts[1:]
						}
						z.Obj.ValueB = z.Obj.ValueB[:0]
					} else {
						z.Obj.ValueB, bts, err = nbs.ReadBytesBytes(bts, z.Obj.ValueB)

						if err != nil {
							panic(err)
						}
					}
					if err != nil {
						panic(err)
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss34zsil != -1 {
				bts = nbs.PopAlwaysNil()
			}

		case "child":
			found33zojd[3] = true
			if nbs.AlwaysNil {
				if z.Child != nil {
					z.Child.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Child {
						z.Child.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Child == nil {
						z.Child = new(TestType)
					}
					bts, err = z.Child.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "time":
			found33zojd[4] = true
			z.Time, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "any":
			found33zojd[5] = true
			z.Any, bts, err = nbs.ReadIntfBytes(bts)

			if err != nil {
				panic(err)
			}
		case "appended":
			found33zojd[6] = true
			bts, err = z.Appended.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "num":
			found33zojd[7] = true
			bts, err = z.Num.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "Slice1":
			found33zojd[8] = true
			if nbs.AlwaysNil {
				(z.Slice1) = (z.Slice1)[:0]
			} else {

				var zunc uint32
				zunc, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Slice1) >= int(zunc) {
					z.Slice1 = (z.Slice1)[:zunc]
				} else {
					z.Slice1 = make([]string, zunc)
				}
				for zxrw := range z.Slice1 {
					z.Slice1[zxrw], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Slice2":
			found33zojd[9] = true
			if nbs.AlwaysNil {
				(z.Slice2) = (z.Slice2)[:0]
			} else {

				var zxxa uint32
				zxxa, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Slice2) >= int(zxxa) {
					z.Slice2 = (z.Slice2)[:zxxa]
				} else {
					z.Slice2 = make([]string, zxxa)
				}
				for zbiy := range z.Slice2 {
					z.Slice2[zbiy], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SlicePtr":
			found33zojd[10] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.SlicePtr != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.SlicePtr", alias:"*[]string"}, Value:(*gen.Slice)(0xc42025d980)}
					(z.SlicePtr) = nil
				}
			} else { // wire has bytes

				if z.SlicePtr == nil {
					z.SlicePtr = new([]string)
				}
				if nbs.AlwaysNil {
					(*z.SlicePtr) = (*z.SlicePtr)[:0]
				} else {

					var zopb uint32
					zopb, bts, err = nbs.ReadArrayHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if cap(*z.SlicePtr) >= int(zopb) {
						*z.SlicePtr = (*z.SlicePtr)[:zopb]
					} else {
						*z.SlicePtr = make([]string, zopb)
					}
					for zyig := range *z.SlicePtr {
						(*z.SlicePtr)[zyig], bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss33zojd != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestType
var unmarshalMsgFieldOrder33zojd = []string{"float", "elements", "object", "child", "time", "any", "appended", "num", "Slice1", "Slice2", "SlicePtr"}

// fields of struct{;ValueA string;;ValueB []byte;;}
var unmarshalMsgFieldOrder34zsil = []string{"value_a", "value_b"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestType) Msgsize() (s int) {
	s = 1 + 6
	if z.F == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 9 + msgp.MapHeaderSize
	if z.Els != nil {
		for zuam, zrao := range z.Els {
			_ = zrao
			s += msgp.StringPrefixSize + len(zuam) + msgp.StringPrefixSize + len(zrao)
		}
	}
	s += 7 + 1 + 8 + msgp.StringPrefixSize + len(z.Obj.ValueA) + 8 + msgp.BytesPrefixSize + len(z.Obj.ValueB) + 6
	if z.Child == nil {
		s += msgp.NilSize
	} else {
		s += z.Child.Msgsize()
	}
	s += 5 + msgp.TimeSize + 4 + msgp.GuessSize(z.Any) + 9 + z.Appended.Msgsize() + 4 + z.Num.Msgsize() + 7 + msgp.ArrayHeaderSize
	for zxrw := range z.Slice1 {
		s += msgp.StringPrefixSize + len(z.Slice1[zxrw])
	}
	s += 7 + msgp.ArrayHeaderSize
	for zbiy := range z.Slice2 {
		s += msgp.StringPrefixSize + len(z.Slice2[zbiy])
	}
	s += 9
	if z.SlicePtr == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for zyig := range *z.SlicePtr {
			s += msgp.StringPrefixSize + len((*z.SlicePtr)[zyig])
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Things) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields35zwgx = 6

	// -- templateDecodeMsg starts here--
	var totalEncodedFields35zwgx uint32
	totalEncodedFields35zwgx, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft35zwgx := totalEncodedFields35zwgx
	missingFieldsLeft35zwgx := maxFields35zwgx - totalEncodedFields35zwgx

	var nextMiss35zwgx int32 = -1
	var found35zwgx [maxFields35zwgx]bool
	var curField35zwgx string

doneWithStruct35zwgx:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft35zwgx > 0 || missingFieldsLeft35zwgx > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft35zwgx, missingFieldsLeft35zwgx, msgp.ShowFound(found35zwgx[:]), decodeMsgFieldOrder35zwgx)
		if encodedFieldsLeft35zwgx > 0 {
			encodedFieldsLeft35zwgx--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField35zwgx = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss35zwgx < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss35zwgx = 0
			}
			for nextMiss35zwgx < maxFields35zwgx && found35zwgx[nextMiss35zwgx] {
				nextMiss35zwgx++
			}
			if nextMiss35zwgx == maxFields35zwgx {
				// filled all the empty fields!
				break doneWithStruct35zwgx
			}
			missingFieldsLeft35zwgx--
			curField35zwgx = decodeMsgFieldOrder35zwgx[nextMiss35zwgx]
		}
		fmt.Printf("switching on curField: '%v'\n", curField35zwgx)
		switch curField35zwgx {
		// -- templateDecodeMsg ends here --

		case "complex":
			found35zwgx[0] = true
			z.Cmplx, err = dc.ReadComplex64()
			if err != nil {
				panic(err)
			}
		case "values":
			found35zwgx[1] = true
			var zeqn uint32
			zeqn, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Vals) >= int(zeqn) {
				z.Vals = (z.Vals)[:zeqn]
			} else {
				z.Vals = make([]int32, zeqn)
			}
			for ztkg := range z.Vals {
				z.Vals[ztkg], err = dc.ReadInt32()
				if err != nil {
					panic(err)
				}
			}
		case "arr":
			found35zwgx[2] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zmlb uint32
				zmlb, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zmlb != msgp.ExtensionPrefixSize {
					err = msgp.ArrayError{Wanted: msgp.ExtensionPrefixSize, Got: zmlb}
					return
				}
			}
			for zfzb := range z.Arr {
				z.Arr[zfzb], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "arr2":
			found35zwgx[3] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zrql uint32
				zrql, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zrql != 4 {
					err = msgp.ArrayError{Wanted: 4, Got: zrql}
					return
				}
			}
			for zzef := range z.Arr2 {
				z.Arr2[zzef], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "ext":
			found35zwgx[4] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				// we have an base.Value of Ext: replace the Ext iff already allocated

				if z.Ext != nil {
					z.Ext = new(msgp.RawExtension)
				}
			} else {
				// we have bytes in dc to read

				if z.Ext == nil {
					z.Ext = new(msgp.RawExtension)
				}
				if !dc.IsNil() {
					err = dc.ReadExtension(z.Ext)
				} else {
					err = dc.ReadNil()
				}

				if err != nil {
					panic(err)
				}
			}
		case "oext":
			found35zwgx[5] = true
			if !dc.IsNil() {
				err = dc.ReadExtension(&z.Oext)
			} else {
				err = dc.ReadNil()
			}

			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss35zwgx != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Things
var decodeMsgFieldOrder35zwgx = []string{"complex", "values", "arr", "arr2", "ext", "oext"}

// fieldsNotEmpty supports omitempty tags
func (z *Things) fieldsNotEmpty(isempty []bool) uint32 {
	return 6
}

// EncodeMsg implements msgp.Encodable
func (z *Things) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "complex"
	err = en.Append(0x86, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78)
	if err != nil {
		return err
	}
	err = en.WriteComplex64(z.Cmplx)
	if err != nil {
		panic(err)
	}
	// write "values"
	err = en.Append(0xa6, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Vals)))
	if err != nil {
		panic(err)
	}
	for ztkg := range z.Vals {
		err = en.WriteInt32(z.Vals[ztkg])
		if err != nil {
			panic(err)
		}
	}
	// write "arr"
	err = en.Append(0xa3, 0x61, 0x72, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(msgp.ExtensionPrefixSize)
	if err != nil {
		panic(err)
	}
	for zfzb := range z.Arr {
		err = en.WriteFloat64(z.Arr[zfzb])
		if err != nil {
			panic(err)
		}
	}
	// write "arr2"
	err = en.Append(0xa4, 0x61, 0x72, 0x72, 0x32)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(4)
	if err != nil {
		panic(err)
	}
	for zzef := range z.Arr2 {
		err = en.WriteFloat64(z.Arr2[zzef])
		if err != nil {
			panic(err)
		}
	}
	// write "ext"
	err = en.Append(0xa3, 0x65, 0x78, 0x74)
	if err != nil {
		return err
	}
	if z.Ext == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteExtension(z.Ext)
		if err != nil {
			panic(err)
		}
	}
	// write "oext"
	err = en.Append(0xa4, 0x6f, 0x65, 0x78, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteExtension(&z.Oext)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Things) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "complex"
	o = append(o, 0x86, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78)
	o = msgp.AppendComplex64(o, z.Cmplx)
	// string "values"
	o = append(o, 0xa6, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Vals)))
	for ztkg := range z.Vals {
		o = msgp.AppendInt32(o, z.Vals[ztkg])
	}
	// string "arr"
	o = append(o, 0xa3, 0x61, 0x72, 0x72)
	o = msgp.AppendArrayHeader(o, msgp.ExtensionPrefixSize)
	for zfzb := range z.Arr {
		o = msgp.AppendFloat64(o, z.Arr[zfzb])
	}
	// string "arr2"
	o = append(o, 0xa4, 0x61, 0x72, 0x72, 0x32)
	o = msgp.AppendArrayHeader(o, 4)
	for zzef := range z.Arr2 {
		o = msgp.AppendFloat64(o, z.Arr2[zzef])
	}
	// string "ext"
	o = append(o, 0xa3, 0x65, 0x78, 0x74)
	if z.Ext == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = msgp.AppendExtension(o, z.Ext)
		if err != nil {
			panic(err)
		}
	}
	// string "oext"
	o = append(o, 0xa4, 0x6f, 0x65, 0x78, 0x74)
	o, err = msgp.AppendExtension(o, &z.Oext)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Things) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields36zybp = 6

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields36zybp uint32
	if !nbs.AlwaysNil {
		totalEncodedFields36zybp, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft36zybp := totalEncodedFields36zybp
	missingFieldsLeft36zybp := maxFields36zybp - totalEncodedFields36zybp

	var nextMiss36zybp int32 = -1
	var found36zybp [maxFields36zybp]bool
	var curField36zybp string

doneWithStruct36zybp:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft36zybp > 0 || missingFieldsLeft36zybp > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft36zybp, missingFieldsLeft36zybp, msgp.ShowFound(found36zybp[:]), unmarshalMsgFieldOrder36zybp)
		if encodedFieldsLeft36zybp > 0 {
			encodedFieldsLeft36zybp--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField36zybp = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss36zybp < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss36zybp = 0
			}
			for nextMiss36zybp < maxFields36zybp && found36zybp[nextMiss36zybp] {
				nextMiss36zybp++
			}
			if nextMiss36zybp == maxFields36zybp {
				// filled all the empty fields!
				break doneWithStruct36zybp
			}
			missingFieldsLeft36zybp--
			curField36zybp = unmarshalMsgFieldOrder36zybp[nextMiss36zybp]
		}
		fmt.Printf("switching on curField: '%v'\n", curField36zybp)
		switch curField36zybp {
		// -- templateUnmarshalMsg ends here --

		case "complex":
			found36zybp[0] = true
			z.Cmplx, bts, err = nbs.ReadComplex64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "values":
			found36zybp[1] = true
			if nbs.AlwaysNil {
				(z.Vals) = (z.Vals)[:0]
			} else {

				var zolb uint32
				zolb, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Vals) >= int(zolb) {
					z.Vals = (z.Vals)[:zolb]
				} else {
					z.Vals = make([]int32, zolb)
				}
				for ztkg := range z.Vals {
					z.Vals[ztkg], bts, err = nbs.ReadInt32Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "arr":
			found36zybp[2] = true
			var zhhi uint32
			zhhi, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zhhi != msgp.ExtensionPrefixSize {
				err = msgp.ArrayError{Wanted: msgp.ExtensionPrefixSize, Got: zhhi}
				return
			}
			for zfzb := range z.Arr {
				z.Arr[zfzb], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "arr2":
			found36zybp[3] = true
			var zmsd uint32
			zmsd, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zmsd != 4 {
				err = msgp.ArrayError{Wanted: 4, Got: zmsd}
				return
			}
			for zzef := range z.Arr2 {
				z.Arr2[zzef], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ext":
			found36zybp[4] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				// don't try to re-use extension pointers
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Ext = nil
			} else {
				// we have data

				if z.Ext == nil {
					z.Ext = new(msgp.RawExtension)
				}
				bts, err = nbs.ReadExtensionBytes(bts, z.Ext)

				if err != nil {
					panic(err)
				}
			}
		case "oext":
			found36zybp[5] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Oext = msgp.RawExtension{}
			} else {
				bts, err = nbs.ReadExtensionBytes(bts, &z.Oext)

				if err != nil {
					panic(err)
				}
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss36zybp != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Things
var unmarshalMsgFieldOrder36zybp = []string{"complex", "values", "arr", "arr2", "ext", "oext"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Things) Msgsize() (s int) {
	s = 1 + 8 + msgp.Complex64Size + 7 + msgp.ArrayHeaderSize + (len(z.Vals) * (msgp.Int32Size)) + 4 + msgp.ArrayHeaderSize + (msgp.ExtensionPrefixSize * (msgp.Float64Size)) + 5 + msgp.ArrayHeaderSize + (4 * (msgp.Float64Size)) + 4
	if z.Ext == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ExtensionPrefixSize + z.Ext.Len()
	}
	s += 5 + msgp.ExtensionPrefixSize + z.Oext.Len()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TopNester) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields37zqnu = 9

	// -- templateDecodeMsg starts here--
	var totalEncodedFields37zqnu uint32
	totalEncodedFields37zqnu, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft37zqnu := totalEncodedFields37zqnu
	missingFieldsLeft37zqnu := maxFields37zqnu - totalEncodedFields37zqnu

	var nextMiss37zqnu int32 = -1
	var found37zqnu [maxFields37zqnu]bool
	var curField37zqnu string

doneWithStruct37zqnu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft37zqnu > 0 || missingFieldsLeft37zqnu > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft37zqnu, missingFieldsLeft37zqnu, msgp.ShowFound(found37zqnu[:]), decodeMsgFieldOrder37zqnu)
		if encodedFieldsLeft37zqnu > 0 {
			encodedFieldsLeft37zqnu--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField37zqnu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss37zqnu < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss37zqnu = 0
			}
			for nextMiss37zqnu < maxFields37zqnu && found37zqnu[nextMiss37zqnu] {
				nextMiss37zqnu++
			}
			if nextMiss37zqnu == maxFields37zqnu {
				// filled all the empty fields!
				break doneWithStruct37zqnu
			}
			missingFieldsLeft37zqnu--
			curField37zqnu = decodeMsgFieldOrder37zqnu[nextMiss37zqnu]
		}
		fmt.Printf("switching on curField: '%v'\n", curField37zqnu)
		switch curField37zqnu {
		// -- templateDecodeMsg ends here --

		case "TopId":
			found37zqnu[0] = true
			z.TopId, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found37zqnu[1] = true
			z.Greetings, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found37zqnu[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bullwinkle != nil {
					dc.PushAlwaysNil()
					err = z.Bullwinkle.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bullwinkle == nil {
					z.Bullwinkle = new(Rocky)
				}
				err = z.Bullwinkle.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "MyIntArray":
			found37zqnu[3] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zhev uint32
				zhev, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zhev != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zhev}
					return
				}
			}
			for zqyc := range z.MyIntArray {
				z.MyIntArray[zqyc], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "MyByteArray":
			found37zqnu[4] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.MyByteArray[:])
			if err != nil {
				panic(err)
			}
		case "MyMap":
			found37zqnu[5] = true
			var zazt uint32
			zazt, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MyMap == nil && zazt > 0 {
				z.MyMap = make(map[string]string, zazt)
			} else if len(z.MyMap) > 0 {
				for key, _ := range z.MyMap {
					delete(z.MyMap, key)
				}
			}
			for zazt > 0 {
				zazt--
				var zmqy string
				var zcet string
				zmqy, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zcet, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.MyMap[zmqy] = zcet
			}
		case "MyArrayMap":
			found37zqnu[6] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zlrj uint32
				zlrj, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zlrj != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zlrj}
					return
				}
			}
			for zicq := range z.MyArrayMap {
				var ztqt uint32
				ztqt, err = dc.ReadMapHeader()
				if err != nil {
					panic(err)
				}
				if z.MyArrayMap[zicq] == nil && ztqt > 0 {
					z.MyArrayMap[zicq] = make(map[string]string, ztqt)
				} else if len(z.MyArrayMap[zicq]) > 0 {
					for key, _ := range z.MyArrayMap[zicq] {
						delete(z.MyArrayMap[zicq], key)
					}
				}
				for ztqt > 0 {
					ztqt--
					var zzvs string
					var zlle string
					zzvs, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
					zlle, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
					z.MyArrayMap[zicq][zzvs] = zlle
				}
			}
		case "TopTime":
			found37zqnu[7] = true
			z.TopTime, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "PtrTime":
			found37zqnu[8] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrTime == nil {
					z.PtrTime = new(time.Time)
				}
				*z.PtrTime, err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss37zqnu != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TopNester
var decodeMsgFieldOrder37zqnu = []string{"TopId", "Greetings", "Bullwinkle", "MyIntArray", "MyByteArray", "MyMap", "MyArrayMap", "TopTime", "PtrTime"}

// fieldsNotEmpty supports omitempty tags
func (z *TopNester) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 9
	}
	var fieldsInUse uint32 = 9
	isempty[1] = (len(z.Greetings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Bullwinkle == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.MyIntArray) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (len(z.MyByteArray) == 0) // string, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (len(z.MyMap) == 0) // string, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (len(z.MyArrayMap) == 0) // string, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (z.TopTime.IsZero()) // time.Time, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (z.PtrTime == nil) // pointer, omitempty
	if isempty[8] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *TopNester) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_ztlw [9]bool
	fieldsInUse_ztgs := z.fieldsNotEmpty(empty_ztlw[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_ztgs)
	if err != nil {
		return err
	}

	// write "TopId"
	err = en.Append(0xa5, 0x54, 0x6f, 0x70, 0x49, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.TopId)
	if err != nil {
		panic(err)
	}
	if !empty_ztlw[1] {
		// write "Greetings"
		err = en.Append(0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Greetings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_ztlw[2] {
		// write "Bullwinkle"
		err = en.Append(0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if err != nil {
			return err
		}
		if z.Bullwinkle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullwinkle.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_ztlw[3] {
		// write "MyIntArray"
		err = en.Append(0xaa, 0x4d, 0x79, 0x49, 0x6e, 0x74, 0x41, 0x72, 0x72, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zqyc := range z.MyIntArray {
			err = en.WriteInt(z.MyIntArray[zqyc])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_ztlw[4] {
		// write "MyByteArray"
		err = en.Append(0xab, 0x4d, 0x79, 0x42, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteBytes(z.MyByteArray[:])
		if err != nil {
			panic(err)
		}
	}

	if !empty_ztlw[5] {
		// write "MyMap"
		err = en.Append(0xa5, 0x4d, 0x79, 0x4d, 0x61, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MyMap)))
		if err != nil {
			panic(err)
		}
		for zmqy, zcet := range z.MyMap {
			err = en.WriteString(zmqy)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zcet)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_ztlw[6] {
		// write "MyArrayMap"
		err = en.Append(0xaa, 0x4d, 0x79, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x61, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zicq := range z.MyArrayMap {
			err = en.WriteMapHeader(uint32(len(z.MyArrayMap[zicq])))
			if err != nil {
				panic(err)
			}
			for zzvs, zlle := range z.MyArrayMap[zicq] {
				err = en.WriteString(zzvs)
				if err != nil {
					panic(err)
				}
				err = en.WriteString(zlle)
				if err != nil {
					panic(err)
				}
			}
		}
	}

	if !empty_ztlw[7] {
		// write "TopTime"
		err = en.Append(0xa7, 0x54, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteTime(z.TopTime)
		if err != nil {
			panic(err)
		}
	}

	if !empty_ztlw[8] {
		// write "PtrTime"
		err = en.Append(0xa7, 0x50, 0x74, 0x72, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return err
		}
		if z.PtrTime == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteTime(*z.PtrTime)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TopNester) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [9]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "TopId"
	o = append(o, 0xa5, 0x54, 0x6f, 0x70, 0x49, 0x64)
	o = msgp.AppendInt(o, z.TopId)
	if !empty[1] {
		// string "Greetings"
		o = append(o, 0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendString(o, z.Greetings)
	}

	if !empty[2] {
		// string "Bullwinkle"
		o = append(o, 0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if z.Bullwinkle == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullwinkle.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[3] {
		// string "MyIntArray"
		o = append(o, 0xaa, 0x4d, 0x79, 0x49, 0x6e, 0x74, 0x41, 0x72, 0x72, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zqyc := range z.MyIntArray {
			o = msgp.AppendInt(o, z.MyIntArray[zqyc])
		}
	}

	if !empty[4] {
		// string "MyByteArray"
		o = append(o, 0xab, 0x4d, 0x79, 0x42, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79)
		o = msgp.AppendBytes(o, z.MyByteArray[:])
	}

	if !empty[5] {
		// string "MyMap"
		o = append(o, 0xa5, 0x4d, 0x79, 0x4d, 0x61, 0x70)
		o = msgp.AppendMapHeader(o, uint32(len(z.MyMap)))
		for zmqy, zcet := range z.MyMap {
			o = msgp.AppendString(o, zmqy)
			o = msgp.AppendString(o, zcet)
		}
	}

	if !empty[6] {
		// string "MyArrayMap"
		o = append(o, 0xaa, 0x4d, 0x79, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x61, 0x70)
		o = msgp.AppendArrayHeader(o, 3)
		for zicq := range z.MyArrayMap {
			o = msgp.AppendMapHeader(o, uint32(len(z.MyArrayMap[zicq])))
			for zzvs, zlle := range z.MyArrayMap[zicq] {
				o = msgp.AppendString(o, zzvs)
				o = msgp.AppendString(o, zlle)
			}
		}
	}

	if !empty[7] {
		// string "TopTime"
		o = append(o, 0xa7, 0x54, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.TopTime)
	}

	if !empty[8] {
		// string "PtrTime"
		o = append(o, 0xa7, 0x50, 0x74, 0x72, 0x54, 0x69, 0x6d, 0x65)
		if z.PtrTime == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendTime(o, *z.PtrTime)
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TopNester) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields38zzgt = 9

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields38zzgt uint32
	if !nbs.AlwaysNil {
		totalEncodedFields38zzgt, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft38zzgt := totalEncodedFields38zzgt
	missingFieldsLeft38zzgt := maxFields38zzgt - totalEncodedFields38zzgt

	var nextMiss38zzgt int32 = -1
	var found38zzgt [maxFields38zzgt]bool
	var curField38zzgt string

doneWithStruct38zzgt:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft38zzgt > 0 || missingFieldsLeft38zzgt > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft38zzgt, missingFieldsLeft38zzgt, msgp.ShowFound(found38zzgt[:]), unmarshalMsgFieldOrder38zzgt)
		if encodedFieldsLeft38zzgt > 0 {
			encodedFieldsLeft38zzgt--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField38zzgt = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss38zzgt < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss38zzgt = 0
			}
			for nextMiss38zzgt < maxFields38zzgt && found38zzgt[nextMiss38zzgt] {
				nextMiss38zzgt++
			}
			if nextMiss38zzgt == maxFields38zzgt {
				// filled all the empty fields!
				break doneWithStruct38zzgt
			}
			missingFieldsLeft38zzgt--
			curField38zzgt = unmarshalMsgFieldOrder38zzgt[nextMiss38zzgt]
		}
		fmt.Printf("switching on curField: '%v'\n", curField38zzgt)
		switch curField38zzgt {
		// -- templateUnmarshalMsg ends here --

		case "TopId":
			found38zzgt[0] = true
			z.TopId, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Greetings":
			found38zzgt[1] = true
			z.Greetings, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found38zzgt[2] = true
			if nbs.AlwaysNil {
				if z.Bullwinkle != nil {
					z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bullwinkle {
						z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bullwinkle == nil {
						z.Bullwinkle = new(Rocky)
					}
					bts, err = z.Bullwinkle.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "MyIntArray":
			found38zzgt[3] = true
			var zwln uint32
			zwln, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zwln != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zwln}
				return
			}
			for zqyc := range z.MyIntArray {
				z.MyIntArray[zqyc], bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "MyByteArray":
			found38zzgt[4] = true
			bts, err = nbs.ReadExactBytes(bts, z.MyByteArray[:])
			if err != nil {
				panic(err)
			}
		case "MyMap":
			found38zzgt[5] = true
			if nbs.AlwaysNil {
				if len(z.MyMap) > 0 {
					for key, _ := range z.MyMap {
						delete(z.MyMap, key)
					}
				}

			} else {

				var zpab uint32
				zpab, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MyMap == nil && zpab > 0 {
					z.MyMap = make(map[string]string, zpab)
				} else if len(z.MyMap) > 0 {
					for key, _ := range z.MyMap {
						delete(z.MyMap, key)
					}
				}
				for zpab > 0 {
					var zmqy string
					var zcet string
					zpab--
					zmqy, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zcet, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MyMap[zmqy] = zcet
				}
			}
		case "MyArrayMap":
			found38zzgt[6] = true
			var zwyt uint32
			zwyt, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zwyt != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zwyt}
				return
			}
			for zicq := range z.MyArrayMap {
				if nbs.AlwaysNil {
					if len(z.MyArrayMap[zicq]) > 0 {
						for key, _ := range z.MyArrayMap[zicq] {
							delete(z.MyArrayMap[zicq], key)
						}
					}

				} else {

					var zben uint32
					zben, bts, err = nbs.ReadMapHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if z.MyArrayMap[zicq] == nil && zben > 0 {
						z.MyArrayMap[zicq] = make(map[string]string, zben)
					} else if len(z.MyArrayMap[zicq]) > 0 {
						for key, _ := range z.MyArrayMap[zicq] {
							delete(z.MyArrayMap[zicq], key)
						}
					}
					for zben > 0 {
						var zzvs string
						var zlle string
						zben--
						zzvs, bts, err = nbs.ReadStringBytes(bts)
						if err != nil {
							panic(err)
						}
						zlle, bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
						z.MyArrayMap[zicq][zzvs] = zlle
					}
				}
			}
		case "TopTime":
			found38zzgt[7] = true
			z.TopTime, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "PtrTime":
			found38zzgt[8] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) {
				if z.PtrTime != nil {
					// Ptr.ZeroLiteral() was not a pointer to Struct, was *gen.Ptr/val=&gen.Ptr{common:gen.common{vname:"z.PtrTime", alias:"*time.Time"}, Value:(*gen.BaseElem)(0xc42026b180)}
					(z.PtrTime) = nil
				}
			} else { // wire has bytes

				if z.PtrTime == nil {
					z.PtrTime = new(time.Time)
				}
				*z.PtrTime, bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss38zzgt != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TopNester
var unmarshalMsgFieldOrder38zzgt = []string{"TopId", "Greetings", "Bullwinkle", "MyIntArray", "MyByteArray", "MyMap", "MyArrayMap", "TopTime", "PtrTime"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TopNester) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 10 + msgp.StringPrefixSize + len(z.Greetings) + 11
	if z.Bullwinkle == nil {
		s += msgp.NilSize
	} else {
		s += z.Bullwinkle.Msgsize()
	}
	s += 11 + msgp.ArrayHeaderSize + (3 * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (3 * (msgp.ByteSize)) + 6 + msgp.MapHeaderSize
	if z.MyMap != nil {
		for zmqy, zcet := range z.MyMap {
			_ = zcet
			s += msgp.StringPrefixSize + len(zmqy) + msgp.StringPrefixSize + len(zcet)
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zicq := range z.MyArrayMap {
		s += msgp.MapHeaderSize
		if z.MyArrayMap[zicq] != nil {
			for zzvs, zlle := range z.MyArrayMap[zicq] {
				_ = zlle
				s += msgp.StringPrefixSize + len(zzvs) + msgp.StringPrefixSize + len(zlle)
			}
		}
	}
	s += 8 + msgp.TimeSize + 8
	if z.PtrTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *X) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields39zuxp = 5

	// -- templateDecodeMsg starts here--
	var totalEncodedFields39zuxp uint32
	totalEncodedFields39zuxp, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft39zuxp := totalEncodedFields39zuxp
	missingFieldsLeft39zuxp := maxFields39zuxp - totalEncodedFields39zuxp

	var nextMiss39zuxp int32 = -1
	var found39zuxp [maxFields39zuxp]bool
	var curField39zuxp string

doneWithStruct39zuxp:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft39zuxp > 0 || missingFieldsLeft39zuxp > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft39zuxp, missingFieldsLeft39zuxp, msgp.ShowFound(found39zuxp[:]), decodeMsgFieldOrder39zuxp)
		if encodedFieldsLeft39zuxp > 0 {
			encodedFieldsLeft39zuxp--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField39zuxp = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss39zuxp < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss39zuxp = 0
			}
			for nextMiss39zuxp < maxFields39zuxp && found39zuxp[nextMiss39zuxp] {
				nextMiss39zuxp++
			}
			if nextMiss39zuxp == maxFields39zuxp {
				// filled all the empty fields!
				break doneWithStruct39zuxp
			}
			missingFieldsLeft39zuxp--
			curField39zuxp = decodeMsgFieldOrder39zuxp[nextMiss39zuxp]
		}
		fmt.Printf("switching on curField: '%v'\n", curField39zuxp)
		switch curField39zuxp {
		// -- templateDecodeMsg ends here --

		case "Values":
			found39zuxp[0] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.Values[:])
			if err != nil {
				panic(err)
			}
		case "More":
			found39zuxp[1] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.More[:])
			if err != nil {
				panic(err)
			}
		case "Others":
			found39zuxp[2] = true
			var zlyp uint32
			zlyp, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Others) >= int(zlyp) {
				z.Others = (z.Others)[:zlyp]
			} else {
				z.Others = make([][32]int32, zlyp)
			}
			for zmlm := range z.Others {
				if dc.AlwaysNil {
					// nothing more here
				} else if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}
				} else {

					var zigq uint32
					zigq, err = dc.ReadArrayHeader()
					if err != nil {
						panic(err)
					}
					if !dc.IsNil() && zigq != 32 {
						err = msgp.ArrayError{Wanted: 32, Got: zigq}
						return
					}
				}
				for zktk := range z.Others[zmlm] {
					z.Others[zmlm][zktk], err = dc.ReadInt32()
					if err != nil {
						panic(err)
					}
				}
			}
		case "Matrix":
			found39zuxp[3] = true
			var ztrf uint32
			ztrf, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Matrix) >= int(ztrf) {
				z.Matrix = (z.Matrix)[:ztrf]
			} else {
				z.Matrix = make([][]int32, ztrf)
			}
			for zdqh := range z.Matrix {
				var zgdw uint32
				zgdw, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if cap(z.Matrix[zdqh]) >= int(zgdw) {
					z.Matrix[zdqh] = (z.Matrix[zdqh])[:zgdw]
				} else {
					z.Matrix[zdqh] = make([]int32, zgdw)
				}
				for zfys := range z.Matrix[zdqh] {
					z.Matrix[zdqh][zfys], err = dc.ReadInt32()
					if err != nil {
						panic(err)
					}
				}
			}
		case "ManyFixed":
			found39zuxp[4] = true
			var zpol uint32
			zpol, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.ManyFixed) >= int(zpol) {
				z.ManyFixed = (z.ManyFixed)[:zpol]
			} else {
				z.ManyFixed = make([]Fixed, zpol)
			}
			for zjoh := range z.ManyFixed {
				const maxFields40zuvq = 2

				// -- templateDecodeMsg starts here--
				var totalEncodedFields40zuvq uint32
				totalEncodedFields40zuvq, err = dc.ReadMapHeader()
				if err != nil {
					return
				}
				encodedFieldsLeft40zuvq := totalEncodedFields40zuvq
				missingFieldsLeft40zuvq := maxFields40zuvq - totalEncodedFields40zuvq

				var nextMiss40zuvq int32 = -1
				var found40zuvq [maxFields40zuvq]bool
				var curField40zuvq string

			doneWithStruct40zuvq:
				// First fill all the encoded fields, then
				// treat the remaining, missing fields, as Nil.
				for encodedFieldsLeft40zuvq > 0 || missingFieldsLeft40zuvq > 0 {
					fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft40zuvq, missingFieldsLeft40zuvq, msgp.ShowFound(found40zuvq[:]), decodeMsgFieldOrder40zuvq)
					if encodedFieldsLeft40zuvq > 0 {
						encodedFieldsLeft40zuvq--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							return
						}
						curField40zuvq = msgp.UnsafeString(field)
					} else {
						//missing fields need handling
						if nextMiss40zuvq < 0 {
							// tell the reader to only give us Nils
							// until further notice.
							dc.PushAlwaysNil()
							nextMiss40zuvq = 0
						}
						for nextMiss40zuvq < maxFields40zuvq && found40zuvq[nextMiss40zuvq] {
							nextMiss40zuvq++
						}
						if nextMiss40zuvq == maxFields40zuvq {
							// filled all the empty fields!
							break doneWithStruct40zuvq
						}
						missingFieldsLeft40zuvq--
						curField40zuvq = decodeMsgFieldOrder40zuvq[nextMiss40zuvq]
					}
					fmt.Printf("switching on curField: '%v'\n", curField40zuvq)
					switch curField40zuvq {
					// -- templateDecodeMsg ends here --

					case "A":
						found40zuvq[0] = true
						z.ManyFixed[zjoh].A, err = dc.ReadFloat64()
						if err != nil {
							panic(err)
						}
					case "B":
						found40zuvq[1] = true
						z.ManyFixed[zjoh].B, err = dc.ReadBool()
						if err != nil {
							panic(err)
						}
					default:
						err = dc.Skip()
						if err != nil {
							panic(err)
						}
					}
				}
				if nextMiss40zuvq != -1 {
					dc.PopAlwaysNil()
				}

			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss39zuxp != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of X
var decodeMsgFieldOrder39zuxp = []string{"Values", "More", "Others", "Matrix", "ManyFixed"}

// fields of Fixed
var decodeMsgFieldOrder40zuvq = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z *X) fieldsNotEmpty(isempty []bool) uint32 {
	return 5
}

// EncodeMsg implements msgp.Encodable
func (z *X) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "Values"
	err = en.Append(0x85, 0xa6, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Values[:])
	if err != nil {
		panic(err)
	}
	// write "More"
	err = en.Append(0xa4, 0x4d, 0x6f, 0x72, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.More[:])
	if err != nil {
		panic(err)
	}
	// write "Others"
	err = en.Append(0xa6, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Others)))
	if err != nil {
		panic(err)
	}
	for zmlm := range z.Others {
		err = en.WriteArrayHeader(32)
		if err != nil {
			panic(err)
		}
		for zktk := range z.Others[zmlm] {
			err = en.WriteInt32(z.Others[zmlm][zktk])
			if err != nil {
				panic(err)
			}
		}
	}
	// write "Matrix"
	err = en.Append(0xa6, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Matrix)))
	if err != nil {
		panic(err)
	}
	for zdqh := range z.Matrix {
		err = en.WriteArrayHeader(uint32(len(z.Matrix[zdqh])))
		if err != nil {
			panic(err)
		}
		for zfys := range z.Matrix[zdqh] {
			err = en.WriteInt32(z.Matrix[zdqh][zfys])
			if err != nil {
				panic(err)
			}
		}
	}
	// write "ManyFixed"
	err = en.Append(0xa9, 0x4d, 0x61, 0x6e, 0x79, 0x46, 0x69, 0x78, 0x65, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.ManyFixed)))
	if err != nil {
		panic(err)
	}
	for zjoh := range z.ManyFixed {
		// map header, size 2
		// write "A"
		err = en.Append(0x82, 0xa1, 0x41)
		if err != nil {
			return err
		}
		err = en.WriteFloat64(z.ManyFixed[zjoh].A)
		if err != nil {
			panic(err)
		}
		// write "B"
		err = en.Append(0xa1, 0x42)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.ManyFixed[zjoh].B)
		if err != nil {
			panic(err)
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *X) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "Values"
	o = append(o, 0x85, 0xa6, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendBytes(o, z.Values[:])
	// string "More"
	o = append(o, 0xa4, 0x4d, 0x6f, 0x72, 0x65)
	o = msgp.AppendBytes(o, z.More[:])
	// string "Others"
	o = append(o, 0xa6, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Others)))
	for zmlm := range z.Others {
		o = msgp.AppendArrayHeader(o, 32)
		for zktk := range z.Others[zmlm] {
			o = msgp.AppendInt32(o, z.Others[zmlm][zktk])
		}
	}
	// string "Matrix"
	o = append(o, 0xa6, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Matrix)))
	for zdqh := range z.Matrix {
		o = msgp.AppendArrayHeader(o, uint32(len(z.Matrix[zdqh])))
		for zfys := range z.Matrix[zdqh] {
			o = msgp.AppendInt32(o, z.Matrix[zdqh][zfys])
		}
	}
	// string "ManyFixed"
	o = append(o, 0xa9, 0x4d, 0x61, 0x6e, 0x79, 0x46, 0x69, 0x78, 0x65, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ManyFixed)))
	for zjoh := range z.ManyFixed {
		// map header, size 2
		// string "A"
		o = append(o, 0x82, 0xa1, 0x41)
		o = msgp.AppendFloat64(o, z.ManyFixed[zjoh].A)
		// string "B"
		o = append(o, 0xa1, 0x42)
		o = msgp.AppendBool(o, z.ManyFixed[zjoh].B)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *X) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields41zvoz = 5

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields41zvoz uint32
	if !nbs.AlwaysNil {
		totalEncodedFields41zvoz, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft41zvoz := totalEncodedFields41zvoz
	missingFieldsLeft41zvoz := maxFields41zvoz - totalEncodedFields41zvoz

	var nextMiss41zvoz int32 = -1
	var found41zvoz [maxFields41zvoz]bool
	var curField41zvoz string

doneWithStruct41zvoz:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft41zvoz > 0 || missingFieldsLeft41zvoz > 0 {
		fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft41zvoz, missingFieldsLeft41zvoz, msgp.ShowFound(found41zvoz[:]), unmarshalMsgFieldOrder41zvoz)
		if encodedFieldsLeft41zvoz > 0 {
			encodedFieldsLeft41zvoz--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField41zvoz = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss41zvoz < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss41zvoz = 0
			}
			for nextMiss41zvoz < maxFields41zvoz && found41zvoz[nextMiss41zvoz] {
				nextMiss41zvoz++
			}
			if nextMiss41zvoz == maxFields41zvoz {
				// filled all the empty fields!
				break doneWithStruct41zvoz
			}
			missingFieldsLeft41zvoz--
			curField41zvoz = unmarshalMsgFieldOrder41zvoz[nextMiss41zvoz]
		}
		fmt.Printf("switching on curField: '%v'\n", curField41zvoz)
		switch curField41zvoz {
		// -- templateUnmarshalMsg ends here --

		case "Values":
			found41zvoz[0] = true
			bts, err = nbs.ReadExactBytes(bts, z.Values[:])
			if err != nil {
				panic(err)
			}
		case "More":
			found41zvoz[1] = true
			bts, err = nbs.ReadExactBytes(bts, z.More[:])
			if err != nil {
				panic(err)
			}
		case "Others":
			found41zvoz[2] = true
			if nbs.AlwaysNil {
				(z.Others) = (z.Others)[:0]
			} else {

				var zwfo uint32
				zwfo, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Others) >= int(zwfo) {
					z.Others = (z.Others)[:zwfo]
				} else {
					z.Others = make([][32]int32, zwfo)
				}
				for zmlm := range z.Others {
					var zags uint32
					zags, bts, err = nbs.ReadArrayHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if !nbs.IsNil(bts) && zags != 32 {
						err = msgp.ArrayError{Wanted: 32, Got: zags}
						return
					}
					for zktk := range z.Others[zmlm] {
						z.Others[zmlm][zktk], bts, err = nbs.ReadInt32Bytes(bts)

						if err != nil {
							panic(err)
						}
					}
				}
			}
		case "Matrix":
			found41zvoz[3] = true
			if nbs.AlwaysNil {
				(z.Matrix) = (z.Matrix)[:0]
			} else {

				var zqvv uint32
				zqvv, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Matrix) >= int(zqvv) {
					z.Matrix = (z.Matrix)[:zqvv]
				} else {
					z.Matrix = make([][]int32, zqvv)
				}
				for zdqh := range z.Matrix {
					if nbs.AlwaysNil {
						(z.Matrix[zdqh]) = (z.Matrix[zdqh])[:0]
					} else {

						var zbma uint32
						zbma, bts, err = nbs.ReadArrayHeaderBytes(bts)
						if err != nil {
							panic(err)
						}
						if cap(z.Matrix[zdqh]) >= int(zbma) {
							z.Matrix[zdqh] = (z.Matrix[zdqh])[:zbma]
						} else {
							z.Matrix[zdqh] = make([]int32, zbma)
						}
						for zfys := range z.Matrix[zdqh] {
							z.Matrix[zdqh][zfys], bts, err = nbs.ReadInt32Bytes(bts)

							if err != nil {
								panic(err)
							}
						}
					}
				}
			}
		case "ManyFixed":
			found41zvoz[4] = true
			if nbs.AlwaysNil {
				(z.ManyFixed) = (z.ManyFixed)[:0]
			} else {

				var zpug uint32
				zpug, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.ManyFixed) >= int(zpug) {
					z.ManyFixed = (z.ManyFixed)[:zpug]
				} else {
					z.ManyFixed = make([]Fixed, zpug)
				}
				for zjoh := range z.ManyFixed {
					const maxFields42zfpj = 2

					// -- templateUnmarshalMsg starts here--
					var totalEncodedFields42zfpj uint32
					if !nbs.AlwaysNil {
						totalEncodedFields42zfpj, bts, err = nbs.ReadMapHeaderBytes(bts)
						if err != nil {
							panic(err)
							return
						}
					}
					encodedFieldsLeft42zfpj := totalEncodedFields42zfpj
					missingFieldsLeft42zfpj := maxFields42zfpj - totalEncodedFields42zfpj

					var nextMiss42zfpj int32 = -1
					var found42zfpj [maxFields42zfpj]bool
					var curField42zfpj string

				doneWithStruct42zfpj:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft42zfpj > 0 || missingFieldsLeft42zfpj > 0 {
						fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft42zfpj, missingFieldsLeft42zfpj, msgp.ShowFound(found42zfpj[:]), unmarshalMsgFieldOrder42zfpj)
						if encodedFieldsLeft42zfpj > 0 {
							encodedFieldsLeft42zfpj--
							field, bts, err = nbs.ReadMapKeyZC(bts)
							if err != nil {
								panic(err)
								return
							}
							curField42zfpj = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss42zfpj < 0 {
								// set bts to contain just mnil (0xc0)
								bts = nbs.PushAlwaysNil(bts)
								nextMiss42zfpj = 0
							}
							for nextMiss42zfpj < maxFields42zfpj && found42zfpj[nextMiss42zfpj] {
								nextMiss42zfpj++
							}
							if nextMiss42zfpj == maxFields42zfpj {
								// filled all the empty fields!
								break doneWithStruct42zfpj
							}
							missingFieldsLeft42zfpj--
							curField42zfpj = unmarshalMsgFieldOrder42zfpj[nextMiss42zfpj]
						}
						fmt.Printf("switching on curField: '%v'\n", curField42zfpj)
						switch curField42zfpj {
						// -- templateUnmarshalMsg ends here --

						case "A":
							found42zfpj[0] = true
							z.ManyFixed[zjoh].A, bts, err = nbs.ReadFloat64Bytes(bts)

							if err != nil {
								panic(err)
							}
						case "B":
							found42zfpj[1] = true
							z.ManyFixed[zjoh].B, bts, err = nbs.ReadBoolBytes(bts)

							if err != nil {
								panic(err)
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								panic(err)
							}
						}
					}
					if nextMiss42zfpj != -1 {
						bts = nbs.PopAlwaysNil()
					}

				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss41zvoz != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of X
var unmarshalMsgFieldOrder41zvoz = []string{"Values", "More", "Others", "Matrix", "ManyFixed"}

// fields of Fixed
var unmarshalMsgFieldOrder42zfpj = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *X) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 5 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 7 + msgp.ArrayHeaderSize + (len(z.Others) * (32 * (msgp.Int32Size))) + 7 + msgp.ArrayHeaderSize
	for zdqh := range z.Matrix {
		s += msgp.ArrayHeaderSize + (len(z.Matrix[zdqh]) * (msgp.Int32Size))
	}
	s += 10 + msgp.ArrayHeaderSize + (len(z.ManyFixed) * (5 + msgp.Float64Size + msgp.BoolSize))
	return
}
