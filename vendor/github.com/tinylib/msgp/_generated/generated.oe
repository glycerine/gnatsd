package _generated

// NOTE: THIS FILE WAS PRODUCED BY THE
// MSGP CODE GENERATION TOOL (github.com/tinylib/msgp)
// DO NOT EDIT

import (
	"time"

	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *AliasContainer) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields0zsmy = 1

	// -- templateDecodeMsg starts here--
	var totalEncodedFields0zsmy uint32
	totalEncodedFields0zsmy, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft0zsmy := totalEncodedFields0zsmy
	missingFieldsLeft0zsmy := maxFields0zsmy - totalEncodedFields0zsmy

	var nextMiss0zsmy int32 = -1
	var found0zsmy [maxFields0zsmy]bool
	var curField0zsmy string

doneWithStruct0zsmy:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft0zsmy > 0 || missingFieldsLeft0zsmy > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft0zsmy, missingFieldsLeft0zsmy, msgp.ShowFound(found0zsmy[:]), decodeMsgFieldOrder0zsmy)
		if encodedFieldsLeft0zsmy > 0 {
			encodedFieldsLeft0zsmy--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField0zsmy = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss0zsmy < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss0zsmy = 0
			}
			for nextMiss0zsmy < maxFields0zsmy && found0zsmy[nextMiss0zsmy] {
				nextMiss0zsmy++
			}
			if nextMiss0zsmy == maxFields0zsmy {
				// filled all the empty fields!
				break doneWithStruct0zsmy
			}
			missingFieldsLeft0zsmy--
			curField0zsmy = decodeMsgFieldOrder0zsmy[nextMiss0zsmy]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField0zsmy)
		switch curField0zsmy {
		// -- templateDecodeMsg ends here --

		case "Fast":
			found0zsmy[0] = true
			err = z.Fast.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss0zsmy != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of AliasContainer
var decodeMsgFieldOrder0zsmy = []string{"Fast"}

// fieldsNotEmpty supports omitempty tags
func (z *AliasContainer) fieldsNotEmpty(isempty []bool) uint32 {
	return 1
}

// EncodeMsg implements msgp.Encodable
func (z *AliasContainer) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Fast"
	err = en.Append(0x81, 0xa4, 0x46, 0x61, 0x73, 0x74)
	if err != nil {
		return err
	}
	err = z.Fast.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AliasContainer) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Fast"
	o = append(o, 0x81, 0xa4, 0x46, 0x61, 0x73, 0x74)
	o, err = z.Fast.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AliasContainer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields1zpra = 1

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields1zpra uint32
	if !nbs.AlwaysNil {
		totalEncodedFields1zpra, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft1zpra := totalEncodedFields1zpra
	missingFieldsLeft1zpra := maxFields1zpra - totalEncodedFields1zpra

	var nextMiss1zpra int32 = -1
	var found1zpra [maxFields1zpra]bool
	var curField1zpra string

doneWithStruct1zpra:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft1zpra > 0 || missingFieldsLeft1zpra > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft1zpra, missingFieldsLeft1zpra, msgp.ShowFound(found1zpra[:]), unmarshalMsgFieldOrder1zpra)
		if encodedFieldsLeft1zpra > 0 {
			encodedFieldsLeft1zpra--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField1zpra = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss1zpra < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss1zpra = 0
			}
			for nextMiss1zpra < maxFields1zpra && found1zpra[nextMiss1zpra] {
				nextMiss1zpra++
			}
			if nextMiss1zpra == maxFields1zpra {
				// filled all the empty fields!
				break doneWithStruct1zpra
			}
			missingFieldsLeft1zpra--
			curField1zpra = unmarshalMsgFieldOrder1zpra[nextMiss1zpra]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField1zpra)
		switch curField1zpra {
		// -- templateUnmarshalMsg ends here --

		case "Fast":
			found1zpra[0] = true
			bts, err = z.Fast.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss1zpra != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of AliasContainer
var unmarshalMsgFieldOrder1zpra = []string{"Fast"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AliasContainer) Msgsize() (s int) {
	s = 1 + 5 + z.Fast.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Block) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	if dc.AlwaysNil {
		// nothing more here
	} else if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			return
		}
	}
	err = dc.ReadExactBytes(z[:])
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *Block) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes(z[:])
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Block) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, z[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Block) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	bts, err = nbs.ReadExactBytes(bts, z[:])
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Block) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Bunny) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields2zwur = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields2zwur uint32
	totalEncodedFields2zwur, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft2zwur := totalEncodedFields2zwur
	missingFieldsLeft2zwur := maxFields2zwur - totalEncodedFields2zwur

	var nextMiss2zwur int32 = -1
	var found2zwur [maxFields2zwur]bool
	var curField2zwur string

doneWithStruct2zwur:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft2zwur > 0 || missingFieldsLeft2zwur > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft2zwur, missingFieldsLeft2zwur, msgp.ShowFound(found2zwur[:]), decodeMsgFieldOrder2zwur)
		if encodedFieldsLeft2zwur > 0 {
			encodedFieldsLeft2zwur--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField2zwur = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss2zwur < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss2zwur = 0
			}
			for nextMiss2zwur < maxFields2zwur && found2zwur[nextMiss2zwur] {
				nextMiss2zwur++
			}
			if nextMiss2zwur == maxFields2zwur {
				// filled all the empty fields!
				break doneWithStruct2zwur
			}
			missingFieldsLeft2zwur--
			curField2zwur = decodeMsgFieldOrder2zwur[nextMiss2zwur]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField2zwur)
		switch curField2zwur {
		// -- templateDecodeMsg ends here --

		case "Carrots":
			found2zwur[0] = true
			var zobd uint32
			zobd, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Carrots) >= int(zobd) {
				z.Carrots = (z.Carrots)[:zobd]
			} else {
				z.Carrots = make([]int, zobd)
			}
			for zejp := range z.Carrots {
				z.Carrots[zejp], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "Sayings":
			found2zwur[1] = true
			var zazg uint32
			zazg, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Sayings == nil && zazg > 0 {
				z.Sayings = make(map[string]string, zazg)
			} else if len(z.Sayings) > 0 {
				for key, _ := range z.Sayings {
					delete(z.Sayings, key)
				}
			}
			for zazg > 0 {
				zazg--
				var zxzm string
				var zgnz string
				zxzm, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zgnz, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Sayings[zxzm] = zgnz
			}
		case "BunnyId":
			found2zwur[2] = true
			z.BunnyId, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss2zwur != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Bunny
var decodeMsgFieldOrder2zwur = []string{"Carrots", "Sayings", "BunnyId"}

// fieldsNotEmpty supports omitempty tags
func (z *Bunny) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (len(z.Carrots) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Sayings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.BunnyId == 0) // number, omitempty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Bunny) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zmsa [3]bool
	fieldsInUse_znus := z.fieldsNotEmpty(empty_zmsa[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_znus)
	if err != nil {
		return err
	}

	if !empty_zmsa[0] {
		// write "Carrots"
		err = en.Append(0xa7, 0x43, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Carrots)))
		if err != nil {
			panic(err)
		}
		for zejp := range z.Carrots {
			err = en.WriteInt(z.Carrots[zejp])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zmsa[1] {
		// write "Sayings"
		err = en.Append(0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Sayings)))
		if err != nil {
			panic(err)
		}
		for zxzm, zgnz := range z.Sayings {
			err = en.WriteString(zxzm)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zgnz)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zmsa[2] {
		// write "BunnyId"
		err = en.Append(0xa7, 0x42, 0x75, 0x6e, 0x6e, 0x79, 0x49, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.BunnyId)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Bunny) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Carrots"
		o = append(o, 0xa7, 0x43, 0x61, 0x72, 0x72, 0x6f, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Carrots)))
		for zejp := range z.Carrots {
			o = msgp.AppendInt(o, z.Carrots[zejp])
		}
	}

	if !empty[1] {
		// string "Sayings"
		o = append(o, 0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Sayings)))
		for zxzm, zgnz := range z.Sayings {
			o = msgp.AppendString(o, zxzm)
			o = msgp.AppendString(o, zgnz)
		}
	}

	if !empty[2] {
		// string "BunnyId"
		o = append(o, 0xa7, 0x42, 0x75, 0x6e, 0x6e, 0x79, 0x49, 0x64)
		o = msgp.AppendInt(o, z.BunnyId)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bunny) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields3zhmn = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields3zhmn uint32
	if !nbs.AlwaysNil {
		totalEncodedFields3zhmn, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft3zhmn := totalEncodedFields3zhmn
	missingFieldsLeft3zhmn := maxFields3zhmn - totalEncodedFields3zhmn

	var nextMiss3zhmn int32 = -1
	var found3zhmn [maxFields3zhmn]bool
	var curField3zhmn string

doneWithStruct3zhmn:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft3zhmn > 0 || missingFieldsLeft3zhmn > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft3zhmn, missingFieldsLeft3zhmn, msgp.ShowFound(found3zhmn[:]), unmarshalMsgFieldOrder3zhmn)
		if encodedFieldsLeft3zhmn > 0 {
			encodedFieldsLeft3zhmn--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField3zhmn = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss3zhmn < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss3zhmn = 0
			}
			for nextMiss3zhmn < maxFields3zhmn && found3zhmn[nextMiss3zhmn] {
				nextMiss3zhmn++
			}
			if nextMiss3zhmn == maxFields3zhmn {
				// filled all the empty fields!
				break doneWithStruct3zhmn
			}
			missingFieldsLeft3zhmn--
			curField3zhmn = unmarshalMsgFieldOrder3zhmn[nextMiss3zhmn]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField3zhmn)
		switch curField3zhmn {
		// -- templateUnmarshalMsg ends here --

		case "Carrots":
			found3zhmn[0] = true
			if nbs.AlwaysNil {
				(z.Carrots) = (z.Carrots)[:0]
			} else {

				var zeym uint32
				zeym, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Carrots) >= int(zeym) {
					z.Carrots = (z.Carrots)[:zeym]
				} else {
					z.Carrots = make([]int, zeym)
				}
				for zejp := range z.Carrots {
					z.Carrots[zejp], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Sayings":
			found3zhmn[1] = true
			if nbs.AlwaysNil {
				if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}

			} else {

				var zulo uint32
				zulo, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Sayings == nil && zulo > 0 {
					z.Sayings = make(map[string]string, zulo)
				} else if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}
				for zulo > 0 {
					var zxzm string
					var zgnz string
					zulo--
					zxzm, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zgnz, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Sayings[zxzm] = zgnz
				}
			}
		case "BunnyId":
			found3zhmn[2] = true
			z.BunnyId, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss3zhmn != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Bunny
var unmarshalMsgFieldOrder3zhmn = []string{"Carrots", "Sayings", "BunnyId"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bunny) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize + (len(z.Carrots) * (msgp.IntSize)) + 8 + msgp.MapHeaderSize
	if z.Sayings != nil {
		for zxzm, zgnz := range z.Sayings {
			_ = zgnz
			s += msgp.StringPrefixSize + len(zxzm) + msgp.StringPrefixSize + len(zgnz)
		}
	}
	s += 8 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Custom) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields4zoql = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields4zoql uint32
	totalEncodedFields4zoql, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft4zoql := totalEncodedFields4zoql
	missingFieldsLeft4zoql := maxFields4zoql - totalEncodedFields4zoql

	var nextMiss4zoql int32 = -1
	var found4zoql [maxFields4zoql]bool
	var curField4zoql string

doneWithStruct4zoql:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft4zoql > 0 || missingFieldsLeft4zoql > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft4zoql, missingFieldsLeft4zoql, msgp.ShowFound(found4zoql[:]), decodeMsgFieldOrder4zoql)
		if encodedFieldsLeft4zoql > 0 {
			encodedFieldsLeft4zoql--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField4zoql = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss4zoql < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss4zoql = 0
			}
			for nextMiss4zoql < maxFields4zoql && found4zoql[nextMiss4zoql] {
				nextMiss4zoql++
			}
			if nextMiss4zoql == maxFields4zoql {
				// filled all the empty fields!
				break doneWithStruct4zoql
			}
			missingFieldsLeft4zoql--
			curField4zoql = decodeMsgFieldOrder4zoql[nextMiss4zoql]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField4zoql)
		switch curField4zoql {
		// -- templateDecodeMsg ends here --

		case "bts":
			found4zoql[0] = true
			{
				var zhka []byte
				zhka, err = dc.ReadBytes([]byte(z.Bts))
				z.Bts = CustomBytes(zhka)
			}
			if err != nil {
				panic(err)
			}
		case "mp":
			found4zoql[1] = true
			var zsmf uint32
			zsmf, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Mp == nil && zsmf > 0 {
				z.Mp = make(map[string]*Embedded, zsmf)
			} else if len(z.Mp) > 0 {
				for key, _ := range z.Mp {
					delete(z.Mp, key)
				}
			}
			for zsmf > 0 {
				zsmf--
				var zsil string
				var zwfk *Embedded
				zsil, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					if zwfk != nil {
						dc.PushAlwaysNil()
						err = zwfk.DecodeMsg(dc)
						if err != nil {
							return
						}
						dc.PopAlwaysNil()
					}
				} else {
					// not Nil, we have something to read

					if zwfk == nil {
						zwfk = new(Embedded)
					}
					err = zwfk.DecodeMsg(dc)
					if err != nil {
						panic(err)
					}
				}
				z.Mp[zsil] = zwfk
			}
		case "enums":
			found4zoql[2] = true
			var zozx uint32
			zozx, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Enums) >= int(zozx) {
				z.Enums = (z.Enums)[:zozx]
			} else {
				z.Enums = make([]MyEnum, zozx)
			}
			for zlvc := range z.Enums {
				{
					var zmbs string
					zmbs, err = dc.ReadString()
					z.Enums[zlvc] = myenumStr(zmbs)
				}
				if err != nil {
					panic(err)
				}
			}
		case "Some":
			found4zoql[3] = true
			err = z.Some.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss4zoql != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Custom
var decodeMsgFieldOrder4zoql = []string{"bts", "mp", "enums", "Some"}

// fieldsNotEmpty supports omitempty tags
func (z *Custom) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Custom) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "bts"
	err = en.Append(0x84, 0xa3, 0x62, 0x74, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteBytes([]byte(z.Bts))
	if err != nil {
		panic(err)
	}
	// write "mp"
	err = en.Append(0xa2, 0x6d, 0x70)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Mp)))
	if err != nil {
		panic(err)
	}
	for zsil, zwfk := range z.Mp {
		err = en.WriteString(zsil)
		if err != nil {
			panic(err)
		}
		if zwfk == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = zwfk.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}
	// write "enums"
	err = en.Append(0xa5, 0x65, 0x6e, 0x75, 0x6d, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Enums)))
	if err != nil {
		panic(err)
	}
	for zlvc := range z.Enums {
		err = en.WriteString((MyEnum).String(z.Enums[zlvc]))
		if err != nil {
			panic(err)
		}
	}
	// write "Some"
	err = en.Append(0xa4, 0x53, 0x6f, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = z.Some.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Custom) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "bts"
	o = append(o, 0x84, 0xa3, 0x62, 0x74, 0x73)
	o = msgp.AppendBytes(o, []byte(z.Bts))
	// string "mp"
	o = append(o, 0xa2, 0x6d, 0x70)
	o = msgp.AppendMapHeader(o, uint32(len(z.Mp)))
	for zsil, zwfk := range z.Mp {
		o = msgp.AppendString(o, zsil)
		if zwfk == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = zwfk.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}
	// string "enums"
	o = append(o, 0xa5, 0x65, 0x6e, 0x75, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Enums)))
	for zlvc := range z.Enums {
		o = msgp.AppendString(o, (MyEnum).String(z.Enums[zlvc]))
	}
	// string "Some"
	o = append(o, 0xa4, 0x53, 0x6f, 0x6d, 0x65)
	o, err = z.Some.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Custom) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields5zeiq = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields5zeiq uint32
	if !nbs.AlwaysNil {
		totalEncodedFields5zeiq, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft5zeiq := totalEncodedFields5zeiq
	missingFieldsLeft5zeiq := maxFields5zeiq - totalEncodedFields5zeiq

	var nextMiss5zeiq int32 = -1
	var found5zeiq [maxFields5zeiq]bool
	var curField5zeiq string

doneWithStruct5zeiq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft5zeiq > 0 || missingFieldsLeft5zeiq > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft5zeiq, missingFieldsLeft5zeiq, msgp.ShowFound(found5zeiq[:]), unmarshalMsgFieldOrder5zeiq)
		if encodedFieldsLeft5zeiq > 0 {
			encodedFieldsLeft5zeiq--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField5zeiq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss5zeiq < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss5zeiq = 0
			}
			for nextMiss5zeiq < maxFields5zeiq && found5zeiq[nextMiss5zeiq] {
				nextMiss5zeiq++
			}
			if nextMiss5zeiq == maxFields5zeiq {
				// filled all the empty fields!
				break doneWithStruct5zeiq
			}
			missingFieldsLeft5zeiq--
			curField5zeiq = unmarshalMsgFieldOrder5zeiq[nextMiss5zeiq]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField5zeiq)
		switch curField5zeiq {
		// -- templateUnmarshalMsg ends here --

		case "bts":
			found5zeiq[0] = true
			{
				var zsia []byte
				if nbs.AlwaysNil || msgp.IsNil(bts) {
					if !nbs.AlwaysNil {
						bts = bts[1:]
					}
					zsia = zsia[:0]
				} else {
					zsia, bts, err = nbs.ReadBytesBytes(bts, []byte(z.Bts))

					if err != nil {
						panic(err)
					}
				}
				if err != nil {
					panic(err)
				}
				z.Bts = CustomBytes(zsia)
			}
		case "mp":
			found5zeiq[1] = true
			if nbs.AlwaysNil {
				if len(z.Mp) > 0 {
					for key, _ := range z.Mp {
						delete(z.Mp, key)
					}
				}

			} else {

				var zwda uint32
				zwda, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Mp == nil && zwda > 0 {
					z.Mp = make(map[string]*Embedded, zwda)
				} else if len(z.Mp) > 0 {
					for key, _ := range z.Mp {
						delete(z.Mp, key)
					}
				}
				for zwda > 0 {
					var zsil string
					var zwfk *Embedded
					zwda--
					zsil, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					if nbs.AlwaysNil {
						if zwfk != nil {
							zwfk.UnmarshalMsg(msgp.OnlyNilSlice)
						}
					} else {
						// not nbs.AlwaysNil
						if msgp.IsNil(bts) {
							bts = bts[1:]
							if nil != zwfk {
								zwfk.UnmarshalMsg(msgp.OnlyNilSlice)
							}
						} else {
							// not nbs.AlwaysNil and not IsNil(bts): have something to read

							if zwfk == nil {
								zwfk = new(Embedded)
							}
							bts, err = zwfk.UnmarshalMsg(bts)
							if err != nil {
								panic(err)
							}
							if err != nil {
								panic(err)
							}
						}
					}
					z.Mp[zsil] = zwfk
				}
			}
		case "enums":
			found5zeiq[2] = true
			if nbs.AlwaysNil {
				(z.Enums) = (z.Enums)[:0]
			} else {

				var zfrw uint32
				zfrw, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Enums) >= int(zfrw) {
					z.Enums = (z.Enums)[:zfrw]
				} else {
					z.Enums = make([]MyEnum, zfrw)
				}
				for zlvc := range z.Enums {
					{
						var znqq string
						znqq, bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
						z.Enums[zlvc] = myenumStr(znqq)
					}
				}
			}
		case "Some":
			found5zeiq[3] = true
			bts, err = z.Some.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss5zeiq != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Custom
var unmarshalMsgFieldOrder5zeiq = []string{"bts", "mp", "enums", "Some"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Custom) Msgsize() (s int) {
	s = 1 + 4 + msgp.BytesPrefixSize + len([]byte(z.Bts)) + 3 + msgp.MapHeaderSize
	if z.Mp != nil {
		for zsil, zwfk := range z.Mp {
			_ = zwfk
			s += msgp.StringPrefixSize + len(zsil)
			if zwfk == nil {
				s += msgp.NilSize
			} else {
				s += zwfk.Msgsize()
			}
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for zlvc := range z.Enums {
		s += msgp.StringPrefixSize + len((MyEnum).String(z.Enums[zlvc]))
	}
	s += 5 + z.Some.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *CustomBytes) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zyqv []byte
		zyqv, err = dc.ReadBytes([]byte((*z)))
		(*z) = CustomBytes(zyqv)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z CustomBytes) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes([]byte(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CustomBytes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CustomBytes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zzyd []byte
		if nbs.AlwaysNil || msgp.IsNil(bts) {
			if !nbs.AlwaysNil {
				bts = bts[1:]
			}
			zzyd = zzyd[:0]
		} else {
			zzyd, bts, err = nbs.ReadBytesBytes(bts, []byte((*z)))

			if err != nil {
				panic(err)
			}
		}
		if err != nil {
			panic(err)
		}
		(*z) = CustomBytes(zzyd)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CustomBytes) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *CustomInt) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zkse int
		zkse, err = dc.ReadInt()
		(*z) = CustomInt(zkse)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z CustomInt) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CustomInt) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CustomInt) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var ztrz int
		ztrz, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = CustomInt(ztrz)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CustomInt) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Embedded) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields6zxmc = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields6zxmc uint32
	totalEncodedFields6zxmc, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft6zxmc := totalEncodedFields6zxmc
	missingFieldsLeft6zxmc := maxFields6zxmc - totalEncodedFields6zxmc

	var nextMiss6zxmc int32 = -1
	var found6zxmc [maxFields6zxmc]bool
	var curField6zxmc string

doneWithStruct6zxmc:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft6zxmc > 0 || missingFieldsLeft6zxmc > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft6zxmc, missingFieldsLeft6zxmc, msgp.ShowFound(found6zxmc[:]), decodeMsgFieldOrder6zxmc)
		if encodedFieldsLeft6zxmc > 0 {
			encodedFieldsLeft6zxmc--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField6zxmc = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss6zxmc < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss6zxmc = 0
			}
			for nextMiss6zxmc < maxFields6zxmc && found6zxmc[nextMiss6zxmc] {
				nextMiss6zxmc++
			}
			if nextMiss6zxmc == maxFields6zxmc {
				// filled all the empty fields!
				break doneWithStruct6zxmc
			}
			missingFieldsLeft6zxmc--
			curField6zxmc = decodeMsgFieldOrder6zxmc[nextMiss6zxmc]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField6zxmc)
		switch curField6zxmc {
		// -- templateDecodeMsg ends here --

		case "Embedded":
			found6zxmc[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Embedded != nil {
					dc.PushAlwaysNil()
					err = z.Embedded.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Embedded == nil {
					z.Embedded = new(Embedded)
				}
				err = z.Embedded.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "Children":
			found6zxmc[1] = true
			var zyrf uint32
			zyrf, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Children) >= int(zyrf) {
				z.Children = (z.Children)[:zyrf]
			} else {
				z.Children = make([]Embedded, zyrf)
			}
			for zvqo := range z.Children {
				err = z.Children[zvqo].DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "PtrChildren":
			found6zxmc[2] = true
			var zxwp uint32
			zxwp, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.PtrChildren) >= int(zxwp) {
				z.PtrChildren = (z.PtrChildren)[:zxwp]
			} else {
				z.PtrChildren = make([]*Embedded, zxwp)
			}
			for zkbo := range z.PtrChildren {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

					if z.PtrChildren[zkbo] != nil {
						dc.PushAlwaysNil()
						err = z.PtrChildren[zkbo].DecodeMsg(dc)
						if err != nil {
							return
						}
						dc.PopAlwaysNil()
					}
				} else {
					// not Nil, we have something to read

					if z.PtrChildren[zkbo] == nil {
						z.PtrChildren[zkbo] = new(Embedded)
					}
					err = z.PtrChildren[zkbo].DecodeMsg(dc)
					if err != nil {
						panic(err)
					}
				}
			}
		case "Other":
			found6zxmc[3] = true
			z.Other, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss6zxmc != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Embedded
var decodeMsgFieldOrder6zxmc = []string{"Embedded", "Children", "PtrChildren", "Other"}

// fieldsNotEmpty supports omitempty tags
func (z *Embedded) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Embedded) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Embedded"
	err = en.Append(0x84, 0xa8, 0x45, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64)
	if err != nil {
		return err
	}
	if z.Embedded == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Embedded.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "Children"
	err = en.Append(0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Children)))
	if err != nil {
		panic(err)
	}
	for zvqo := range z.Children {
		err = z.Children[zvqo].EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "PtrChildren"
	err = en.Append(0xab, 0x50, 0x74, 0x72, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.PtrChildren)))
	if err != nil {
		panic(err)
	}
	for zkbo := range z.PtrChildren {
		if z.PtrChildren[zkbo] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.PtrChildren[zkbo].EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}
	// write "Other"
	err = en.Append(0xa5, 0x4f, 0x74, 0x68, 0x65, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Other)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Embedded) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Embedded"
	o = append(o, 0x84, 0xa8, 0x45, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64)
	if z.Embedded == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Embedded.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "Children"
	o = append(o, 0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Children)))
	for zvqo := range z.Children {
		o, err = z.Children[zvqo].MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "PtrChildren"
	o = append(o, 0xab, 0x50, 0x74, 0x72, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PtrChildren)))
	for zkbo := range z.PtrChildren {
		if z.PtrChildren[zkbo] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.PtrChildren[zkbo].MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}
	// string "Other"
	o = append(o, 0xa5, 0x4f, 0x74, 0x68, 0x65, 0x72)
	o = msgp.AppendString(o, z.Other)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Embedded) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields7zfxk = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields7zfxk uint32
	if !nbs.AlwaysNil {
		totalEncodedFields7zfxk, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft7zfxk := totalEncodedFields7zfxk
	missingFieldsLeft7zfxk := maxFields7zfxk - totalEncodedFields7zfxk

	var nextMiss7zfxk int32 = -1
	var found7zfxk [maxFields7zfxk]bool
	var curField7zfxk string

doneWithStruct7zfxk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft7zfxk > 0 || missingFieldsLeft7zfxk > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft7zfxk, missingFieldsLeft7zfxk, msgp.ShowFound(found7zfxk[:]), unmarshalMsgFieldOrder7zfxk)
		if encodedFieldsLeft7zfxk > 0 {
			encodedFieldsLeft7zfxk--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField7zfxk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss7zfxk < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss7zfxk = 0
			}
			for nextMiss7zfxk < maxFields7zfxk && found7zfxk[nextMiss7zfxk] {
				nextMiss7zfxk++
			}
			if nextMiss7zfxk == maxFields7zfxk {
				// filled all the empty fields!
				break doneWithStruct7zfxk
			}
			missingFieldsLeft7zfxk--
			curField7zfxk = unmarshalMsgFieldOrder7zfxk[nextMiss7zfxk]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField7zfxk)
		switch curField7zfxk {
		// -- templateUnmarshalMsg ends here --

		case "Embedded":
			found7zfxk[0] = true
			if nbs.AlwaysNil {
				if z.Embedded != nil {
					z.Embedded.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Embedded {
						z.Embedded.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Embedded == nil {
						z.Embedded = new(Embedded)
					}
					bts, err = z.Embedded.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "Children":
			found7zfxk[1] = true
			if nbs.AlwaysNil {
				(z.Children) = (z.Children)[:0]
			} else {

				var zaga uint32
				zaga, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Children) >= int(zaga) {
					z.Children = (z.Children)[:zaga]
				} else {
					z.Children = make([]Embedded, zaga)
				}
				for zvqo := range z.Children {
					bts, err = z.Children[zvqo].UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "PtrChildren":
			found7zfxk[2] = true
			if nbs.AlwaysNil {
				(z.PtrChildren) = (z.PtrChildren)[:0]
			} else {

				var zdel uint32
				zdel, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.PtrChildren) >= int(zdel) {
					z.PtrChildren = (z.PtrChildren)[:zdel]
				} else {
					z.PtrChildren = make([]*Embedded, zdel)
				}
				for zkbo := range z.PtrChildren {
					if nbs.AlwaysNil {
						if z.PtrChildren[zkbo] != nil {
							z.PtrChildren[zkbo].UnmarshalMsg(msgp.OnlyNilSlice)
						}
					} else {
						// not nbs.AlwaysNil
						if msgp.IsNil(bts) {
							bts = bts[1:]
							if nil != z.PtrChildren[zkbo] {
								z.PtrChildren[zkbo].UnmarshalMsg(msgp.OnlyNilSlice)
							}
						} else {
							// not nbs.AlwaysNil and not IsNil(bts): have something to read

							if z.PtrChildren[zkbo] == nil {
								z.PtrChildren[zkbo] = new(Embedded)
							}
							bts, err = z.PtrChildren[zkbo].UnmarshalMsg(bts)
							if err != nil {
								panic(err)
							}
							if err != nil {
								panic(err)
							}
						}
					}
				}
			}
		case "Other":
			found7zfxk[3] = true
			z.Other, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss7zfxk != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Embedded
var unmarshalMsgFieldOrder7zfxk = []string{"Embedded", "Children", "PtrChildren", "Other"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Embedded) Msgsize() (s int) {
	s = 1 + 9
	if z.Embedded == nil {
		s += msgp.NilSize
	} else {
		s += z.Embedded.Msgsize()
	}
	s += 9 + msgp.ArrayHeaderSize
	for zvqo := range z.Children {
		s += z.Children[zvqo].Msgsize()
	}
	s += 12 + msgp.ArrayHeaderSize
	for zkbo := range z.PtrChildren {
		if z.PtrChildren[zkbo] == nil {
			s += msgp.NilSize
		} else {
			s += z.PtrChildren[zkbo].Msgsize()
		}
	}
	s += 6 + msgp.StringPrefixSize + len(z.Other)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *FastAlias) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields8znih = 4

	// -- templateDecodeMsg starts here--
	var totalEncodedFields8znih uint32
	totalEncodedFields8znih, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft8znih := totalEncodedFields8znih
	missingFieldsLeft8znih := maxFields8znih - totalEncodedFields8znih

	var nextMiss8znih int32 = -1
	var found8znih [maxFields8znih]bool
	var curField8znih string

doneWithStruct8znih:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft8znih > 0 || missingFieldsLeft8znih > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft8znih, missingFieldsLeft8znih, msgp.ShowFound(found8znih[:]), decodeMsgFieldOrder8znih)
		if encodedFieldsLeft8znih > 0 {
			encodedFieldsLeft8znih--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField8znih = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss8znih < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss8znih = 0
			}
			for nextMiss8znih < maxFields8znih && found8znih[nextMiss8znih] {
				nextMiss8znih++
			}
			if nextMiss8znih == maxFields8znih {
				// filled all the empty fields!
				break doneWithStruct8znih
			}
			missingFieldsLeft8znih--
			curField8znih = decodeMsgFieldOrder8znih[nextMiss8znih]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField8znih)
		switch curField8znih {
		// -- templateDecodeMsg ends here --

		case "Lat":
			found8znih[0] = true
			z.Lat, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Long":
			found8znih[1] = true
			z.Long, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Alt":
			found8znih[2] = true
			z.Alt, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "Data":
			found8znih[3] = true
			z.Data, err = dc.ReadBytes(z.Data)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss8znih != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of FastAlias
var decodeMsgFieldOrder8znih = []string{"Lat", "Long", "Alt", "Data"}

// fieldsNotEmpty supports omitempty tags
func (z *FastAlias) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *FastAlias) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "Lat"
	err = en.Append(0x84, 0xa3, 0x4c, 0x61, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Lat)
	if err != nil {
		panic(err)
	}
	// write "Long"
	err = en.Append(0xa4, 0x4c, 0x6f, 0x6e, 0x67)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Long)
	if err != nil {
		panic(err)
	}
	// write "Alt"
	err = en.Append(0xa3, 0x41, 0x6c, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Alt)
	if err != nil {
		panic(err)
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FastAlias) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Lat"
	o = append(o, 0x84, 0xa3, 0x4c, 0x61, 0x74)
	o = msgp.AppendFloat64(o, z.Lat)
	// string "Long"
	o = append(o, 0xa4, 0x4c, 0x6f, 0x6e, 0x67)
	o = msgp.AppendFloat64(o, z.Long)
	// string "Alt"
	o = append(o, 0xa3, 0x41, 0x6c, 0x74)
	o = msgp.AppendFloat64(o, z.Alt)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FastAlias) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields9zthy = 4

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields9zthy uint32
	if !nbs.AlwaysNil {
		totalEncodedFields9zthy, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft9zthy := totalEncodedFields9zthy
	missingFieldsLeft9zthy := maxFields9zthy - totalEncodedFields9zthy

	var nextMiss9zthy int32 = -1
	var found9zthy [maxFields9zthy]bool
	var curField9zthy string

doneWithStruct9zthy:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft9zthy > 0 || missingFieldsLeft9zthy > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft9zthy, missingFieldsLeft9zthy, msgp.ShowFound(found9zthy[:]), unmarshalMsgFieldOrder9zthy)
		if encodedFieldsLeft9zthy > 0 {
			encodedFieldsLeft9zthy--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField9zthy = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss9zthy < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss9zthy = 0
			}
			for nextMiss9zthy < maxFields9zthy && found9zthy[nextMiss9zthy] {
				nextMiss9zthy++
			}
			if nextMiss9zthy == maxFields9zthy {
				// filled all the empty fields!
				break doneWithStruct9zthy
			}
			missingFieldsLeft9zthy--
			curField9zthy = unmarshalMsgFieldOrder9zthy[nextMiss9zthy]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField9zthy)
		switch curField9zthy {
		// -- templateUnmarshalMsg ends here --

		case "Lat":
			found9zthy[0] = true
			z.Lat, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Long":
			found9zthy[1] = true
			z.Long, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Alt":
			found9zthy[2] = true
			z.Alt, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "Data":
			found9zthy[3] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Data = z.Data[:0]
			} else {
				z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

				if err != nil {
					panic(err)
				}
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss9zthy != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of FastAlias
var unmarshalMsgFieldOrder9zthy = []string{"Lat", "Long", "Alt", "Data"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FastAlias) Msgsize() (s int) {
	s = 1 + 4 + msgp.Float64Size + 5 + msgp.Float64Size + 4 + msgp.Float64Size + 5 + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *FileHandle) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields10ztpb = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields10ztpb uint32
	totalEncodedFields10ztpb, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft10ztpb := totalEncodedFields10ztpb
	missingFieldsLeft10ztpb := maxFields10ztpb - totalEncodedFields10ztpb

	var nextMiss10ztpb int32 = -1
	var found10ztpb [maxFields10ztpb]bool
	var curField10ztpb string

doneWithStruct10ztpb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft10ztpb > 0 || missingFieldsLeft10ztpb > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft10ztpb, missingFieldsLeft10ztpb, msgp.ShowFound(found10ztpb[:]), decodeMsgFieldOrder10ztpb)
		if encodedFieldsLeft10ztpb > 0 {
			encodedFieldsLeft10ztpb--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField10ztpb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss10ztpb < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss10ztpb = 0
			}
			for nextMiss10ztpb < maxFields10ztpb && found10ztpb[nextMiss10ztpb] {
				nextMiss10ztpb++
			}
			if nextMiss10ztpb == maxFields10ztpb {
				// filled all the empty fields!
				break doneWithStruct10ztpb
			}
			missingFieldsLeft10ztpb--
			curField10ztpb = decodeMsgFieldOrder10ztpb[nextMiss10ztpb]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField10ztpb)
		switch curField10ztpb {
		// -- templateDecodeMsg ends here --

		case "files":
			found10ztpb[0] = true
			var zsht uint32
			zsht, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Relevent) >= int(zsht) {
				z.Relevent = (z.Relevent)[:zsht]
			} else {
				z.Relevent = make(Files, zsht)
			}
			for zvhq := range z.Relevent {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}

				} else {

					{
						var zknh string
						zknh, err = dc.ReadString()
						z.Relevent[zvhq] = filefromstr(zknh)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "name":
			found10ztpb[1] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss10ztpb != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of FileHandle
var decodeMsgFieldOrder10ztpb = []string{"files", "name"}

// fieldsNotEmpty supports omitempty tags
func (z *FileHandle) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *FileHandle) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "files"
	err = en.Append(0x82, 0xa5, 0x66, 0x69, 0x6c, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Relevent)))
	if err != nil {
		panic(err)
	}
	for zvhq := range z.Relevent {
		if z.Relevent[zvhq] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(filetostr(z.Relevent[zvhq]))
			if err != nil {
				panic(err)
			}
		}
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Name)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileHandle) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "files"
	o = append(o, 0x82, 0xa5, 0x66, 0x69, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Relevent)))
	for zvhq := range z.Relevent {
		if z.Relevent[zvhq] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, filetostr(z.Relevent[zvhq]))
		}
	}
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileHandle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields11zzyx = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields11zzyx uint32
	if !nbs.AlwaysNil {
		totalEncodedFields11zzyx, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft11zzyx := totalEncodedFields11zzyx
	missingFieldsLeft11zzyx := maxFields11zzyx - totalEncodedFields11zzyx

	var nextMiss11zzyx int32 = -1
	var found11zzyx [maxFields11zzyx]bool
	var curField11zzyx string

doneWithStruct11zzyx:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft11zzyx > 0 || missingFieldsLeft11zzyx > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft11zzyx, missingFieldsLeft11zzyx, msgp.ShowFound(found11zzyx[:]), unmarshalMsgFieldOrder11zzyx)
		if encodedFieldsLeft11zzyx > 0 {
			encodedFieldsLeft11zzyx--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField11zzyx = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss11zzyx < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss11zzyx = 0
			}
			for nextMiss11zzyx < maxFields11zzyx && found11zzyx[nextMiss11zzyx] {
				nextMiss11zzyx++
			}
			if nextMiss11zzyx == maxFields11zzyx {
				// filled all the empty fields!
				break doneWithStruct11zzyx
			}
			missingFieldsLeft11zzyx--
			curField11zzyx = unmarshalMsgFieldOrder11zzyx[nextMiss11zzyx]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField11zzyx)
		switch curField11zzyx {
		// -- templateUnmarshalMsg ends here --

		case "files":
			found11zzyx[0] = true
			if nbs.AlwaysNil {
				(z.Relevent) = (z.Relevent)[:0]
			} else {

				var zrkl uint32
				zrkl, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Relevent) >= int(zrkl) {
					z.Relevent = (z.Relevent)[:zrkl]
				} else {
					z.Relevent = make(Files, zrkl)
				}
				for zvhq := range z.Relevent {
					// default gPtr logic.
					if nbs.PeekNil(bts) && z.Relevent[zvhq] == nil {
						// consume the nil
						bts, err = nbs.ReadNilBytes(bts)
						if err != nil {
							return
						}
					} else {
						// read as-if the wire has bytes, letting nbs take care of nils.

						{
							var zgmp string
							zgmp, bts, err = nbs.ReadStringBytes(bts)

							if err != nil {
								panic(err)
							}
							z.Relevent[zvhq] = filefromstr(zgmp)
						}
					}
				}
			}
		case "name":
			found11zzyx[1] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss11zzyx != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of FileHandle
var unmarshalMsgFieldOrder11zzyx = []string{"files", "name"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileHandle) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for zvhq := range z.Relevent {
		if z.Relevent[zvhq] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(filetostr(z.Relevent[zvhq]))
		}
	}
	s += 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Files) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zpzo uint32
	zpzo, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap((*z)) >= int(zpzo) {
		(*z) = (*z)[:zpzo]
	} else {
		(*z) = make(Files, zpzo)
	}
	for zhmp := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				return
			}

		} else {

			{
				var ztxe string
				ztxe, err = dc.ReadString()
				(*z)[zhmp] = filefromstr(ztxe)
			}
			if err != nil {
				panic(err)
			}
		}
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z Files) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		panic(err)
	}
	for zrnr := range z {
		if z[zrnr] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(filetostr(z[zrnr]))
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Files) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zrnr := range z {
		if z[zrnr] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, filetostr(z[zrnr]))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Files) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zlxc uint32
		zlxc, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap((*z)) >= int(zlxc) {
			(*z) = (*z)[:zlxc]
		} else {
			(*z) = make(Files, zlxc)
		}
		for zsnk := range *z {
			// default gPtr logic.
			if nbs.PeekNil(bts) && (*z)[zsnk] == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				{
					var zldu string
					zldu, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					(*z)[zsnk] = filefromstr(zldu)
				}
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Files) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zojk := range z {
		if z[zojk] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(filetostr(z[zojk]))
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Fixed) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields12zmuo = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields12zmuo uint32
	totalEncodedFields12zmuo, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft12zmuo := totalEncodedFields12zmuo
	missingFieldsLeft12zmuo := maxFields12zmuo - totalEncodedFields12zmuo

	var nextMiss12zmuo int32 = -1
	var found12zmuo [maxFields12zmuo]bool
	var curField12zmuo string

doneWithStruct12zmuo:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft12zmuo > 0 || missingFieldsLeft12zmuo > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft12zmuo, missingFieldsLeft12zmuo, msgp.ShowFound(found12zmuo[:]), decodeMsgFieldOrder12zmuo)
		if encodedFieldsLeft12zmuo > 0 {
			encodedFieldsLeft12zmuo--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField12zmuo = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss12zmuo < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss12zmuo = 0
			}
			for nextMiss12zmuo < maxFields12zmuo && found12zmuo[nextMiss12zmuo] {
				nextMiss12zmuo++
			}
			if nextMiss12zmuo == maxFields12zmuo {
				// filled all the empty fields!
				break doneWithStruct12zmuo
			}
			missingFieldsLeft12zmuo--
			curField12zmuo = decodeMsgFieldOrder12zmuo[nextMiss12zmuo]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField12zmuo)
		switch curField12zmuo {
		// -- templateDecodeMsg ends here --

		case "A":
			found12zmuo[0] = true
			z.A, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "B":
			found12zmuo[1] = true
			z.B, err = dc.ReadBool()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss12zmuo != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Fixed
var decodeMsgFieldOrder12zmuo = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z Fixed) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z Fixed) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "A"
	err = en.Append(0x82, 0xa1, 0x41)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.A)
	if err != nil {
		panic(err)
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return err
	}
	err = en.WriteBool(z.B)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Fixed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "A"
	o = append(o, 0x82, 0xa1, 0x41)
	o = msgp.AppendFloat64(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendBool(o, z.B)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Fixed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields13zimb = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields13zimb uint32
	if !nbs.AlwaysNil {
		totalEncodedFields13zimb, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft13zimb := totalEncodedFields13zimb
	missingFieldsLeft13zimb := maxFields13zimb - totalEncodedFields13zimb

	var nextMiss13zimb int32 = -1
	var found13zimb [maxFields13zimb]bool
	var curField13zimb string

doneWithStruct13zimb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft13zimb > 0 || missingFieldsLeft13zimb > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft13zimb, missingFieldsLeft13zimb, msgp.ShowFound(found13zimb[:]), unmarshalMsgFieldOrder13zimb)
		if encodedFieldsLeft13zimb > 0 {
			encodedFieldsLeft13zimb--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField13zimb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss13zimb < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss13zimb = 0
			}
			for nextMiss13zimb < maxFields13zimb && found13zimb[nextMiss13zimb] {
				nextMiss13zimb++
			}
			if nextMiss13zimb == maxFields13zimb {
				// filled all the empty fields!
				break doneWithStruct13zimb
			}
			missingFieldsLeft13zimb--
			curField13zimb = unmarshalMsgFieldOrder13zimb[nextMiss13zimb]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField13zimb)
		switch curField13zimb {
		// -- templateUnmarshalMsg ends here --

		case "A":
			found13zimb[0] = true
			z.A, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "B":
			found13zimb[1] = true
			z.B, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss13zimb != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Fixed
var unmarshalMsgFieldOrder13zimb = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Fixed) Msgsize() (s int) {
	s = 1 + 2 + msgp.Float64Size + 2 + msgp.BoolSize
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Insane) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(3)
	if err != nil {
		panic(err)
	}
	for zfvj := range z {
		err = en.WriteMapHeader(uint32(len(z[zfvj])))
		if err != nil {
			panic(err)
		}
		for zdzy, zysx := range z[zfvj] {
			err = en.WriteString(zdzy)
			if err != nil {
				panic(err)
			}
			// map header, size 2
			// write "A"
			err = en.Append(0x82, 0xa1, 0x41)
			if err != nil {
				return err
			}
			err = en.WriteInt(int(zysx.A))
			if err != nil {
				panic(err)
			}
			// write "B"
			err = en.Append(0xa1, 0x42)
			if err != nil {
				return err
			}
			err = en.WriteInt(int(zysx.B))
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Insane) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, 3)
	for zfvj := range z {
		o = msgp.AppendMapHeader(o, uint32(len(z[zfvj])))
		for zdzy, zysx := range z[zfvj] {
			o = msgp.AppendString(o, zdzy)
			// map header, size 2
			// string "A"
			o = append(o, 0x82, 0xa1, 0x41)
			o = msgp.AppendInt(o, int(zysx.A))
			// string "B"
			o = append(o, 0xa1, 0x42)
			o = msgp.AppendInt(o, int(zysx.B))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Insane) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zjyc uint32
	zjyc, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if !nbs.IsNil(bts) && zjyc != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zjyc}
		return
	}
	for zfvj := range z {
		if nbs.AlwaysNil {
			if len(z[zfvj]) > 0 {
				for key, _ := range z[zfvj] {
					delete(z[zfvj], key)
				}
			}

		} else {

			var zjbb uint32
			zjbb, bts, err = nbs.ReadMapHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if z[zfvj] == nil && zjbb > 0 {
				z[zfvj] = make(map[string]struct {
					A CustomInt
					B CustomInt
				}, zjbb)
			} else if len(z[zfvj]) > 0 {
				for key, _ := range z[zfvj] {
					delete(z[zfvj], key)
				}
			}
			for zjbb > 0 {
				var zdzy string
				var zysx struct {
					A CustomInt
					B CustomInt
				}
				zjbb--
				zdzy, bts, err = nbs.ReadStringBytes(bts)
				if err != nil {
					panic(err)
				}
				var field []byte
				_ = field
				const maxFields14ztei = 2

				// -- templateUnmarshalMsg starts here--
				var totalEncodedFields14ztei uint32
				if !nbs.AlwaysNil {
					totalEncodedFields14ztei, bts, err = nbs.ReadMapHeaderBytes(bts)
					if err != nil {
						panic(err)
						return
					}
				}
				encodedFieldsLeft14ztei := totalEncodedFields14ztei
				missingFieldsLeft14ztei := maxFields14ztei - totalEncodedFields14ztei

				var nextMiss14ztei int32 = -1
				var found14ztei [maxFields14ztei]bool
				var curField14ztei string

			doneWithStruct14ztei:
				// First fill all the encoded fields, then
				// treat the remaining, missing fields, as Nil.
				for encodedFieldsLeft14ztei > 0 || missingFieldsLeft14ztei > 0 {
					//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft14ztei, missingFieldsLeft14ztei, msgp.ShowFound(found14ztei[:]), unmarshalMsgFieldOrder14ztei)
					if encodedFieldsLeft14ztei > 0 {
						encodedFieldsLeft14ztei--
						field, bts, err = nbs.ReadMapKeyZC(bts)
						if err != nil {
							panic(err)
							return
						}
						curField14ztei = msgp.UnsafeString(field)
					} else {
						//missing fields need handling
						if nextMiss14ztei < 0 {
							// set bts to contain just mnil (0xc0)
							bts = nbs.PushAlwaysNil(bts)
							nextMiss14ztei = 0
						}
						for nextMiss14ztei < maxFields14ztei && found14ztei[nextMiss14ztei] {
							nextMiss14ztei++
						}
						if nextMiss14ztei == maxFields14ztei {
							// filled all the empty fields!
							break doneWithStruct14ztei
						}
						missingFieldsLeft14ztei--
						curField14ztei = unmarshalMsgFieldOrder14ztei[nextMiss14ztei]
					}
					//fmt.Printf("switching on curField: '%v'\n", curField14ztei)
					switch curField14ztei {
					// -- templateUnmarshalMsg ends here --

					case "A":
						found14ztei[0] = true
						{
							var zeoa int
							zeoa, bts, err = nbs.ReadIntBytes(bts)

							if err != nil {
								panic(err)
							}
							zysx.A = CustomInt(zeoa)
						}
					case "B":
						found14ztei[1] = true
						{
							var zzpg int
							zzpg, bts, err = nbs.ReadIntBytes(bts)

							if err != nil {
								panic(err)
							}
							zysx.B = CustomInt(zzpg)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							panic(err)
						}
					}
				}
				if nextMiss14ztei != -1 {
					bts = nbs.PopAlwaysNil()
				}

				z[zfvj][zdzy] = zysx
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of struct{;A CustomInt;;B CustomInt;;}
var unmarshalMsgFieldOrder14ztei = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Insane) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zfvj := range z {
		s += msgp.MapHeaderSize
		if z[zfvj] != nil {
			for zdzy, zysx := range z[zfvj] {
				_ = zysx
				s += msgp.StringPrefixSize + len(zdzy) + 1 + 2 + msgp.IntSize + 2 + msgp.IntSize
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntA) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zeej int
		zeej, err = dc.ReadInt()
		(*z) = IntA(zeej)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntA) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntA) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntA) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zpva int
		zpva, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntA(zpva)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntA) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntB) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zjjl int
		zjjl, err = dc.ReadInt()
		(*z) = IntB(zjjl)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntB) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntB) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntB) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zjvw int
		zjvw, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntB(zjvw)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntB) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *IntC) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zlrl int
		zlrl, err = dc.ReadInt()
		(*z) = IntC(zlrl)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z IntC) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z IntC) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *IntC) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zwlb int
		zwlb, bts, err = nbs.ReadIntBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = IntC(zwlb)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z IntC) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Moose) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields15zeav = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields15zeav uint32
	totalEncodedFields15zeav, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft15zeav := totalEncodedFields15zeav
	missingFieldsLeft15zeav := maxFields15zeav - totalEncodedFields15zeav

	var nextMiss15zeav int32 = -1
	var found15zeav [maxFields15zeav]bool
	var curField15zeav string

doneWithStruct15zeav:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft15zeav > 0 || missingFieldsLeft15zeav > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft15zeav, missingFieldsLeft15zeav, msgp.ShowFound(found15zeav[:]), decodeMsgFieldOrder15zeav)
		if encodedFieldsLeft15zeav > 0 {
			encodedFieldsLeft15zeav--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField15zeav = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss15zeav < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss15zeav = 0
			}
			for nextMiss15zeav < maxFields15zeav && found15zeav[nextMiss15zeav] {
				nextMiss15zeav++
			}
			if nextMiss15zeav == maxFields15zeav {
				// filled all the empty fields!
				break doneWithStruct15zeav
			}
			missingFieldsLeft15zeav--
			curField15zeav = decodeMsgFieldOrder15zeav[nextMiss15zeav]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField15zeav)
		switch curField15zeav {
		// -- templateDecodeMsg ends here --

		case "Trees":
			found15zeav[0] = true
			var zbwq uint32
			zbwq, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Trees) >= int(zbwq) {
				z.Trees = (z.Trees)[:zbwq]
			} else {
				z.Trees = make([]int, zbwq)
			}
			for zsmi := range z.Trees {
				z.Trees[zsmi], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "Sayings":
			found15zeav[1] = true
			var zqdi uint32
			zqdi, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Sayings == nil && zqdi > 0 {
				z.Sayings = make(map[string]string, zqdi)
			} else if len(z.Sayings) > 0 {
				for key, _ := range z.Sayings {
					delete(z.Sayings, key)
				}
			}
			for zqdi > 0 {
				zqdi--
				var zwcq string
				var zugf string
				zwcq, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zugf, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Sayings[zwcq] = zugf
			}
		case "Id":
			found15zeav[2] = true
			z.Id, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss15zeav != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Moose
var decodeMsgFieldOrder15zeav = []string{"Trees", "Sayings", "Id"}

// fieldsNotEmpty supports omitempty tags
func (z *Moose) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (len(z.Trees) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Sayings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Moose) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zpzk [3]bool
	fieldsInUse_zdug := z.fieldsNotEmpty(empty_zpzk[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zdug)
	if err != nil {
		return err
	}

	if !empty_zpzk[0] {
		// write "Trees"
		err = en.Append(0xa5, 0x54, 0x72, 0x65, 0x65, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.Trees)))
		if err != nil {
			panic(err)
		}
		for zsmi := range z.Trees {
			err = en.WriteInt(z.Trees[zsmi])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zpzk[1] {
		// write "Sayings"
		err = en.Append(0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.Sayings)))
		if err != nil {
			panic(err)
		}
		for zwcq, zugf := range z.Sayings {
			err = en.WriteString(zwcq)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zugf)
			if err != nil {
				panic(err)
			}
		}
	}

	// write "Id"
	err = en.Append(0xa2, 0x49, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.Id)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Moose) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Trees"
		o = append(o, 0xa5, 0x54, 0x72, 0x65, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Trees)))
		for zsmi := range z.Trees {
			o = msgp.AppendInt(o, z.Trees[zsmi])
		}
	}

	if !empty[1] {
		// string "Sayings"
		o = append(o, 0xa7, 0x53, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Sayings)))
		for zwcq, zugf := range z.Sayings {
			o = msgp.AppendString(o, zwcq)
			o = msgp.AppendString(o, zugf)
		}
	}

	// string "Id"
	o = append(o, 0xa2, 0x49, 0x64)
	o = msgp.AppendInt(o, z.Id)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Moose) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields16zmja = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields16zmja uint32
	if !nbs.AlwaysNil {
		totalEncodedFields16zmja, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft16zmja := totalEncodedFields16zmja
	missingFieldsLeft16zmja := maxFields16zmja - totalEncodedFields16zmja

	var nextMiss16zmja int32 = -1
	var found16zmja [maxFields16zmja]bool
	var curField16zmja string

doneWithStruct16zmja:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft16zmja > 0 || missingFieldsLeft16zmja > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft16zmja, missingFieldsLeft16zmja, msgp.ShowFound(found16zmja[:]), unmarshalMsgFieldOrder16zmja)
		if encodedFieldsLeft16zmja > 0 {
			encodedFieldsLeft16zmja--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField16zmja = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss16zmja < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss16zmja = 0
			}
			for nextMiss16zmja < maxFields16zmja && found16zmja[nextMiss16zmja] {
				nextMiss16zmja++
			}
			if nextMiss16zmja == maxFields16zmja {
				// filled all the empty fields!
				break doneWithStruct16zmja
			}
			missingFieldsLeft16zmja--
			curField16zmja = unmarshalMsgFieldOrder16zmja[nextMiss16zmja]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField16zmja)
		switch curField16zmja {
		// -- templateUnmarshalMsg ends here --

		case "Trees":
			found16zmja[0] = true
			if nbs.AlwaysNil {
				(z.Trees) = (z.Trees)[:0]
			} else {

				var zxpp uint32
				zxpp, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Trees) >= int(zxpp) {
					z.Trees = (z.Trees)[:zxpp]
				} else {
					z.Trees = make([]int, zxpp)
				}
				for zsmi := range z.Trees {
					z.Trees[zsmi], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Sayings":
			found16zmja[1] = true
			if nbs.AlwaysNil {
				if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}

			} else {

				var zuju uint32
				zuju, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Sayings == nil && zuju > 0 {
					z.Sayings = make(map[string]string, zuju)
				} else if len(z.Sayings) > 0 {
					for key, _ := range z.Sayings {
						delete(z.Sayings, key)
					}
				}
				for zuju > 0 {
					var zwcq string
					var zugf string
					zuju--
					zwcq, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zugf, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Sayings[zwcq] = zugf
				}
			}
		case "Id":
			found16zmja[2] = true
			z.Id, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss16zmja != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Moose
var unmarshalMsgFieldOrder16zmja = []string{"Trees", "Sayings", "Id"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Moose) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize + (len(z.Trees) * (msgp.IntSize)) + 8 + msgp.MapHeaderSize
	if z.Sayings != nil {
		for zwcq, zugf := range z.Sayings {
			_ = zugf
			s += msgp.StringPrefixSize + len(zwcq) + msgp.StringPrefixSize + len(zugf)
		}
	}
	s += 3 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *MyEnum) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	{
		var zebn string
		zebn, err = dc.ReadString()
		(*z) = myenumStr(zebn)
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z MyEnum) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString((MyEnum).String(z))
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MyEnum) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, (MyEnum).String(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MyEnum) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zulx string
		zulx, bts, err = nbs.ReadStringBytes(bts)

		if err != nil {
			panic(err)
		}
		(*z) = myenumStr(zulx)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MyEnum) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len((MyEnum).String(z))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Object) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zhqs uint32
	zhqs, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zhqs != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zhqs}
		return
	}
	z.ObjectNo, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	var zipa uint32
	zipa, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap(z.Slice1) >= int(zipa) {
		z.Slice1 = (z.Slice1)[:zipa]
	} else {
		z.Slice1 = make([]string, zipa)
	}
	for zmzl := range z.Slice1 {
		z.Slice1[zmzl], err = dc.ReadString()
		if err != nil {
			panic(err)
		}
	}
	var zlmj uint32
	zlmj, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if cap(z.Slice2) >= int(zlmj) {
		z.Slice2 = (z.Slice2)[:zlmj]
	} else {
		z.Slice2 = make([]string, zlmj)
	}
	for zfpr := range z.Slice2 {
		z.Slice2[zfpr], err = dc.ReadString()
		if err != nil {
			panic(err)
		}
	}
	var zfzk uint32
	zfzk, err = dc.ReadMapHeader()
	if err != nil {
		panic(err)
	}
	if z.MapMap == nil && zfzk > 0 {
		z.MapMap = make(map[string]map[string]string, zfzk)
	} else if len(z.MapMap) > 0 {
		for key, _ := range z.MapMap {
			delete(z.MapMap, key)
		}
	}
	for zfzk > 0 {
		zfzk--
		var zzbz string
		var zzqy map[string]string
		zzbz, err = dc.ReadString()
		if err != nil {
			panic(err)
		}
		var zwco uint32
		zwco, err = dc.ReadMapHeader()
		if err != nil {
			panic(err)
		}
		if zzqy == nil && zwco > 0 {
			zzqy = make(map[string]string, zwco)
		} else if len(zzqy) > 0 {
			for key, _ := range zzqy {
				delete(zzqy, key)
			}
		}
		for zwco > 0 {
			zwco--
			var zkgm string
			var zuhy string
			zkgm, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
			zuhy, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
			zzqy[zkgm] = zuhy
		}
		z.MapMap[zzbz] = zzqy
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *Object) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *Object) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return err
	}
	err = en.WriteString(z.ObjectNo)
	if err != nil {
		panic(err)
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice1)))
	if err != nil {
		panic(err)
	}
	for zmzl := range z.Slice1 {
		err = en.WriteString(z.Slice1[zmzl])
		if err != nil {
			panic(err)
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice2)))
	if err != nil {
		panic(err)
	}
	for zfpr := range z.Slice2 {
		err = en.WriteString(z.Slice2[zfpr])
		if err != nil {
			panic(err)
		}
	}
	err = en.WriteMapHeader(uint32(len(z.MapMap)))
	if err != nil {
		panic(err)
	}
	for zzbz, zzqy := range z.MapMap {
		err = en.WriteString(zzbz)
		if err != nil {
			panic(err)
		}
		err = en.WriteMapHeader(uint32(len(zzqy)))
		if err != nil {
			panic(err)
		}
		for zkgm, zuhy := range zzqy {
			err = en.WriteString(zkgm)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zuhy)
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Object) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendString(o, z.ObjectNo)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice1)))
	for zmzl := range z.Slice1 {
		o = msgp.AppendString(o, z.Slice1[zmzl])
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice2)))
	for zfpr := range z.Slice2 {
		o = msgp.AppendString(o, z.Slice2[zfpr])
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.MapMap)))
	for zzbz, zzqy := range z.MapMap {
		o = msgp.AppendString(o, zzbz)
		o = msgp.AppendMapHeader(o, uint32(len(zzqy)))
		for zkgm, zuhy := range zzqy {
			o = msgp.AppendString(o, zkgm)
			o = msgp.AppendString(o, zuhy)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Object) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zzah uint32
	zzah, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zzah != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zzah}
		return
	}
	z.ObjectNo, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	if nbs.AlwaysNil {
		(z.Slice1) = (z.Slice1)[:0]
	} else {

		var zcus uint32
		zcus, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap(z.Slice1) >= int(zcus) {
			z.Slice1 = (z.Slice1)[:zcus]
		} else {
			z.Slice1 = make([]string, zcus)
		}
		for zmzl := range z.Slice1 {
			z.Slice1[zmzl], bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		}
	}
	if nbs.AlwaysNil {
		(z.Slice2) = (z.Slice2)[:0]
	} else {

		var zwtu uint32
		zwtu, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if cap(z.Slice2) >= int(zwtu) {
			z.Slice2 = (z.Slice2)[:zwtu]
		} else {
			z.Slice2 = make([]string, zwtu)
		}
		for zfpr := range z.Slice2 {
			z.Slice2[zfpr], bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		}
	}
	if nbs.AlwaysNil {
		if len(z.MapMap) > 0 {
			for key, _ := range z.MapMap {
				delete(z.MapMap, key)
			}
		}

	} else {

		var zauw uint32
		zauw, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
		}
		if z.MapMap == nil && zauw > 0 {
			z.MapMap = make(map[string]map[string]string, zauw)
		} else if len(z.MapMap) > 0 {
			for key, _ := range z.MapMap {
				delete(z.MapMap, key)
			}
		}
		for zauw > 0 {
			var zzbz string
			var zzqy map[string]string
			zauw--
			zzbz, bts, err = nbs.ReadStringBytes(bts)
			if err != nil {
				panic(err)
			}
			if nbs.AlwaysNil {
				if len(zzqy) > 0 {
					for key, _ := range zzqy {
						delete(zzqy, key)
					}
				}

			} else {

				var zwix uint32
				zwix, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if zzqy == nil && zwix > 0 {
					zzqy = make(map[string]string, zwix)
				} else if len(zzqy) > 0 {
					for key, _ := range zzqy {
						delete(zzqy, key)
					}
				}
				for zwix > 0 {
					var zkgm string
					var zuhy string
					zwix--
					zkgm, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zuhy, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					zzqy[zkgm] = zuhy
				}
			}
			z.MapMap[zzbz] = zzqy
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Object) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.ObjectNo) + msgp.ArrayHeaderSize
	for zmzl := range z.Slice1 {
		s += msgp.StringPrefixSize + len(z.Slice1[zmzl])
	}
	s += msgp.ArrayHeaderSize
	for zfpr := range z.Slice2 {
		s += msgp.StringPrefixSize + len(z.Slice2[zfpr])
	}
	s += msgp.MapHeaderSize
	if z.MapMap != nil {
		for zzbz, zzqy := range z.MapMap {
			_ = zzqy
			s += msgp.StringPrefixSize + len(zzbz) + msgp.MapHeaderSize
			if zzqy != nil {
				for zkgm, zuhy := range zzqy {
					_ = zuhy
					s += msgp.StringPrefixSize + len(zkgm) + msgp.StringPrefixSize + len(zuhy)
				}
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitEmptyInside1) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields17zztw = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields17zztw uint32
	totalEncodedFields17zztw, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft17zztw := totalEncodedFields17zztw
	missingFieldsLeft17zztw := maxFields17zztw - totalEncodedFields17zztw

	var nextMiss17zztw int32 = -1
	var found17zztw [maxFields17zztw]bool
	var curField17zztw string

doneWithStruct17zztw:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft17zztw > 0 || missingFieldsLeft17zztw > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft17zztw, missingFieldsLeft17zztw, msgp.ShowFound(found17zztw[:]), decodeMsgFieldOrder17zztw)
		if encodedFieldsLeft17zztw > 0 {
			encodedFieldsLeft17zztw--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField17zztw = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss17zztw < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss17zztw = 0
			}
			for nextMiss17zztw < maxFields17zztw && found17zztw[nextMiss17zztw] {
				nextMiss17zztw++
			}
			if nextMiss17zztw == maxFields17zztw {
				// filled all the empty fields!
				break doneWithStruct17zztw
			}
			missingFieldsLeft17zztw--
			curField17zztw = decodeMsgFieldOrder17zztw[nextMiss17zztw]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField17zztw)
		switch curField17zztw {
		// -- templateDecodeMsg ends here --

		case "CountOfMonteCrisco":
			found17zztw[0] = true
			z.CountOfMonteCrisco, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "name":
			found17zztw[1] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Inside2":
			found17zztw[2] = true
			const maxFields18zsqw = 1

			// -- templateDecodeMsg starts here--
			var totalEncodedFields18zsqw uint32
			totalEncodedFields18zsqw, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft18zsqw := totalEncodedFields18zsqw
			missingFieldsLeft18zsqw := maxFields18zsqw - totalEncodedFields18zsqw

			var nextMiss18zsqw int32 = -1
			var found18zsqw [maxFields18zsqw]bool
			var curField18zsqw string

		doneWithStruct18zsqw:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft18zsqw > 0 || missingFieldsLeft18zsqw > 0 {
				//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft18zsqw, missingFieldsLeft18zsqw, msgp.ShowFound(found18zsqw[:]), decodeMsgFieldOrder18zsqw)
				if encodedFieldsLeft18zsqw > 0 {
					encodedFieldsLeft18zsqw--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField18zsqw = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss18zsqw < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss18zsqw = 0
					}
					for nextMiss18zsqw < maxFields18zsqw && found18zsqw[nextMiss18zsqw] {
						nextMiss18zsqw++
					}
					if nextMiss18zsqw == maxFields18zsqw {
						// filled all the empty fields!
						break doneWithStruct18zsqw
					}
					missingFieldsLeft18zsqw--
					curField18zsqw = decodeMsgFieldOrder18zsqw[nextMiss18zsqw]
				}
				//fmt.Printf("switching on curField: '%v'\n", curField18zsqw)
				switch curField18zsqw {
				// -- templateDecodeMsg ends here --

				case "NameSuey":
					found18zsqw[0] = true
					z.Inside2.NameSuey, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss18zsqw != -1 {
				dc.PopAlwaysNil()
			}

		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss17zztw != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitEmptyInside1
var decodeMsgFieldOrder17zztw = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder18zsqw = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z *OmitEmptyInside1) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[1] = (len(z.Name) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = false // struct values are never empty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *OmitEmptyInside1) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zijy [3]bool
	fieldsInUse_zbsq := z.fieldsNotEmpty(empty_zijy[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zbsq)
	if err != nil {
		return err
	}

	// write "CountOfMonteCrisco"
	err = en.Append(0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.CountOfMonteCrisco)
	if err != nil {
		panic(err)
	}
	if !empty_zijy[1] {
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Name)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zijy[2] {
		// write "Inside2"
		// map header, size 1
		// write "NameSuey"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Inside2.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OmitEmptyInside1) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "CountOfMonteCrisco"
	o = append(o, 0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
	o = msgp.AppendInt(o, z.CountOfMonteCrisco)
	if !empty[1] {
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
	}

	if !empty[2] {
		// string "Inside2"
		// map header, size 1
		// string "NameSuey"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.Inside2.NameSuey)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitEmptyInside1) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields19zlmu = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields19zlmu uint32
	if !nbs.AlwaysNil {
		totalEncodedFields19zlmu, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft19zlmu := totalEncodedFields19zlmu
	missingFieldsLeft19zlmu := maxFields19zlmu - totalEncodedFields19zlmu

	var nextMiss19zlmu int32 = -1
	var found19zlmu [maxFields19zlmu]bool
	var curField19zlmu string

doneWithStruct19zlmu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft19zlmu > 0 || missingFieldsLeft19zlmu > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft19zlmu, missingFieldsLeft19zlmu, msgp.ShowFound(found19zlmu[:]), unmarshalMsgFieldOrder19zlmu)
		if encodedFieldsLeft19zlmu > 0 {
			encodedFieldsLeft19zlmu--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField19zlmu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss19zlmu < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss19zlmu = 0
			}
			for nextMiss19zlmu < maxFields19zlmu && found19zlmu[nextMiss19zlmu] {
				nextMiss19zlmu++
			}
			if nextMiss19zlmu == maxFields19zlmu {
				// filled all the empty fields!
				break doneWithStruct19zlmu
			}
			missingFieldsLeft19zlmu--
			curField19zlmu = unmarshalMsgFieldOrder19zlmu[nextMiss19zlmu]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField19zlmu)
		switch curField19zlmu {
		// -- templateUnmarshalMsg ends here --

		case "CountOfMonteCrisco":
			found19zlmu[0] = true
			z.CountOfMonteCrisco, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "name":
			found19zlmu[1] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Inside2":
			found19zlmu[2] = true
			const maxFields20zxdi = 1

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields20zxdi uint32
			if !nbs.AlwaysNil {
				totalEncodedFields20zxdi, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft20zxdi := totalEncodedFields20zxdi
			missingFieldsLeft20zxdi := maxFields20zxdi - totalEncodedFields20zxdi

			var nextMiss20zxdi int32 = -1
			var found20zxdi [maxFields20zxdi]bool
			var curField20zxdi string

		doneWithStruct20zxdi:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft20zxdi > 0 || missingFieldsLeft20zxdi > 0 {
				//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft20zxdi, missingFieldsLeft20zxdi, msgp.ShowFound(found20zxdi[:]), unmarshalMsgFieldOrder20zxdi)
				if encodedFieldsLeft20zxdi > 0 {
					encodedFieldsLeft20zxdi--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField20zxdi = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss20zxdi < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss20zxdi = 0
					}
					for nextMiss20zxdi < maxFields20zxdi && found20zxdi[nextMiss20zxdi] {
						nextMiss20zxdi++
					}
					if nextMiss20zxdi == maxFields20zxdi {
						// filled all the empty fields!
						break doneWithStruct20zxdi
					}
					missingFieldsLeft20zxdi--
					curField20zxdi = unmarshalMsgFieldOrder20zxdi[nextMiss20zxdi]
				}
				//fmt.Printf("switching on curField: '%v'\n", curField20zxdi)
				switch curField20zxdi {
				// -- templateUnmarshalMsg ends here --

				case "NameSuey":
					found20zxdi[0] = true
					z.Inside2.NameSuey, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss20zxdi != -1 {
				bts = nbs.PopAlwaysNil()
			}

		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss19zlmu != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitEmptyInside1
var unmarshalMsgFieldOrder19zlmu = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder20zxdi = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OmitEmptyInside1) Msgsize() (s int) {
	s = 1 + 19 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 8 + 1 + 9 + msgp.StringPrefixSize + len(z.Inside2.NameSuey)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitEmptyInside2) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields21zywb = 1

	// -- templateDecodeMsg starts here--
	var totalEncodedFields21zywb uint32
	totalEncodedFields21zywb, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft21zywb := totalEncodedFields21zywb
	missingFieldsLeft21zywb := maxFields21zywb - totalEncodedFields21zywb

	var nextMiss21zywb int32 = -1
	var found21zywb [maxFields21zywb]bool
	var curField21zywb string

doneWithStruct21zywb:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft21zywb > 0 || missingFieldsLeft21zywb > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft21zywb, missingFieldsLeft21zywb, msgp.ShowFound(found21zywb[:]), decodeMsgFieldOrder21zywb)
		if encodedFieldsLeft21zywb > 0 {
			encodedFieldsLeft21zywb--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField21zywb = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss21zywb < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss21zywb = 0
			}
			for nextMiss21zywb < maxFields21zywb && found21zywb[nextMiss21zywb] {
				nextMiss21zywb++
			}
			if nextMiss21zywb == maxFields21zywb {
				// filled all the empty fields!
				break doneWithStruct21zywb
			}
			missingFieldsLeft21zywb--
			curField21zywb = decodeMsgFieldOrder21zywb[nextMiss21zywb]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField21zywb)
		switch curField21zywb {
		// -- templateDecodeMsg ends here --

		case "NameSuey":
			found21zywb[0] = true
			z.NameSuey, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss21zywb != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder21zywb = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z OmitEmptyInside2) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 1
	}
	var fieldsInUse uint32 = 1
	isempty[0] = (len(z.NameSuey) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z OmitEmptyInside2) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zpbr [1]bool
	fieldsInUse_zxai := z.fieldsNotEmpty(empty_zpbr[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zxai)
	if err != nil {
		return err
	}

	if !empty_zpbr[0] {
		// write "NameSuey"
		err = en.Append(0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z OmitEmptyInside2) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [1]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "NameSuey"
		o = append(o, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.NameSuey)
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitEmptyInside2) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields22zwmr = 1

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields22zwmr uint32
	if !nbs.AlwaysNil {
		totalEncodedFields22zwmr, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft22zwmr := totalEncodedFields22zwmr
	missingFieldsLeft22zwmr := maxFields22zwmr - totalEncodedFields22zwmr

	var nextMiss22zwmr int32 = -1
	var found22zwmr [maxFields22zwmr]bool
	var curField22zwmr string

doneWithStruct22zwmr:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft22zwmr > 0 || missingFieldsLeft22zwmr > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft22zwmr, missingFieldsLeft22zwmr, msgp.ShowFound(found22zwmr[:]), unmarshalMsgFieldOrder22zwmr)
		if encodedFieldsLeft22zwmr > 0 {
			encodedFieldsLeft22zwmr--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField22zwmr = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss22zwmr < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss22zwmr = 0
			}
			for nextMiss22zwmr < maxFields22zwmr && found22zwmr[nextMiss22zwmr] {
				nextMiss22zwmr++
			}
			if nextMiss22zwmr == maxFields22zwmr {
				// filled all the empty fields!
				break doneWithStruct22zwmr
			}
			missingFieldsLeft22zwmr--
			curField22zwmr = unmarshalMsgFieldOrder22zwmr[nextMiss22zwmr]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField22zwmr)
		switch curField22zwmr {
		// -- templateUnmarshalMsg ends here --

		case "NameSuey":
			found22zwmr[0] = true
			z.NameSuey, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss22zwmr != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder22zwmr = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OmitEmptyInside2) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.NameSuey)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OmitSimple) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields23zken = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields23zken uint32
	totalEncodedFields23zken, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft23zken := totalEncodedFields23zken
	missingFieldsLeft23zken := maxFields23zken - totalEncodedFields23zken

	var nextMiss23zken int32 = -1
	var found23zken [maxFields23zken]bool
	var curField23zken string

doneWithStruct23zken:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft23zken > 0 || missingFieldsLeft23zken > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft23zken, missingFieldsLeft23zken, msgp.ShowFound(found23zken[:]), decodeMsgFieldOrder23zken)
		if encodedFieldsLeft23zken > 0 {
			encodedFieldsLeft23zken--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField23zken = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss23zken < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss23zken = 0
			}
			for nextMiss23zken < maxFields23zken && found23zken[nextMiss23zken] {
				nextMiss23zken++
			}
			if nextMiss23zken == maxFields23zken {
				// filled all the empty fields!
				break doneWithStruct23zken
			}
			missingFieldsLeft23zken--
			curField23zken = decodeMsgFieldOrder23zken[nextMiss23zken]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField23zken)
		switch curField23zken {
		// -- templateDecodeMsg ends here --

		case "CountDrocula":
			found23zken[0] = true
			z.CountDrocula, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Inside1":
			found23zken[1] = true
			err = z.Inside1.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss23zken != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of OmitSimple
var decodeMsgFieldOrder23zken = []string{"CountDrocula", "Inside1"}

// fieldsNotEmpty supports omitempty tags
func (z *OmitSimple) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 2
	}
	var fieldsInUse uint32 = 2
	isempty[1] = false
	if isempty[1] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *OmitSimple) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zknm [2]bool
	fieldsInUse_zuwt := z.fieldsNotEmpty(empty_zknm[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zuwt)
	if err != nil {
		return err
	}

	// write "CountDrocula"
	err = en.Append(0xac, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x72, 0x6f, 0x63, 0x75, 0x6c, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.CountDrocula)
	if err != nil {
		panic(err)
	}
	if !empty_zknm[1] {
		// write "Inside1"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		if err != nil {
			return err
		}
		err = z.Inside1.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OmitSimple) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [2]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "CountDrocula"
	o = append(o, 0xac, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x72, 0x6f, 0x63, 0x75, 0x6c, 0x61)
	o = msgp.AppendInt(o, z.CountDrocula)
	if !empty[1] {
		// string "Inside1"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31)
		o, err = z.Inside1.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OmitSimple) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields24zgmw = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields24zgmw uint32
	if !nbs.AlwaysNil {
		totalEncodedFields24zgmw, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft24zgmw := totalEncodedFields24zgmw
	missingFieldsLeft24zgmw := maxFields24zgmw - totalEncodedFields24zgmw

	var nextMiss24zgmw int32 = -1
	var found24zgmw [maxFields24zgmw]bool
	var curField24zgmw string

doneWithStruct24zgmw:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft24zgmw > 0 || missingFieldsLeft24zgmw > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft24zgmw, missingFieldsLeft24zgmw, msgp.ShowFound(found24zgmw[:]), unmarshalMsgFieldOrder24zgmw)
		if encodedFieldsLeft24zgmw > 0 {
			encodedFieldsLeft24zgmw--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField24zgmw = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss24zgmw < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss24zgmw = 0
			}
			for nextMiss24zgmw < maxFields24zgmw && found24zgmw[nextMiss24zgmw] {
				nextMiss24zgmw++
			}
			if nextMiss24zgmw == maxFields24zgmw {
				// filled all the empty fields!
				break doneWithStruct24zgmw
			}
			missingFieldsLeft24zgmw--
			curField24zgmw = unmarshalMsgFieldOrder24zgmw[nextMiss24zgmw]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField24zgmw)
		switch curField24zgmw {
		// -- templateUnmarshalMsg ends here --

		case "CountDrocula":
			found24zgmw[0] = true
			z.CountDrocula, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Inside1":
			found24zgmw[1] = true
			bts, err = z.Inside1.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss24zgmw != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of OmitSimple
var unmarshalMsgFieldOrder24zgmw = []string{"CountDrocula", "Inside1"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OmitSimple) Msgsize() (s int) {
	s = 1 + 13 + msgp.IntSize + 8 + z.Inside1.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Rocky) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields25zgyu = 3

	// -- templateDecodeMsg starts here--
	var totalEncodedFields25zgyu uint32
	totalEncodedFields25zgyu, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft25zgyu := totalEncodedFields25zgyu
	missingFieldsLeft25zgyu := maxFields25zgyu - totalEncodedFields25zgyu

	var nextMiss25zgyu int32 = -1
	var found25zgyu [maxFields25zgyu]bool
	var curField25zgyu string

doneWithStruct25zgyu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft25zgyu > 0 || missingFieldsLeft25zgyu > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft25zgyu, missingFieldsLeft25zgyu, msgp.ShowFound(found25zgyu[:]), decodeMsgFieldOrder25zgyu)
		if encodedFieldsLeft25zgyu > 0 {
			encodedFieldsLeft25zgyu--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField25zgyu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss25zgyu < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss25zgyu = 0
			}
			for nextMiss25zgyu < maxFields25zgyu && found25zgyu[nextMiss25zgyu] {
				nextMiss25zgyu++
			}
			if nextMiss25zgyu == maxFields25zgyu {
				// filled all the empty fields!
				break doneWithStruct25zgyu
			}
			missingFieldsLeft25zgyu--
			curField25zgyu = decodeMsgFieldOrder25zgyu[nextMiss25zgyu]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField25zgyu)
		switch curField25zgyu {
		// -- templateDecodeMsg ends here --

		case "Bugs":
			found25zgyu[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bugs != nil {
					dc.PushAlwaysNil()
					err = z.Bugs.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bugs == nil {
					z.Bugs = new(Bunny)
				}
				err = z.Bugs.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "Road":
			found25zgyu[1] = true
			z.Road, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Moose":
			found25zgyu[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Moose != nil {
					dc.PushAlwaysNil()
					err = z.Moose.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Moose == nil {
					z.Moose = new(Moose)
				}
				err = z.Moose.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss25zgyu != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Rocky
var decodeMsgFieldOrder25zgyu = []string{"Bugs", "Road", "Moose"}

// fieldsNotEmpty supports omitempty tags
func (z *Rocky) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 3
	}
	var fieldsInUse uint32 = 3
	isempty[0] = (z.Bugs == nil) // pointer, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (len(z.Road) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Moose == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *Rocky) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zvwb [3]bool
	fieldsInUse_zcuv := z.fieldsNotEmpty(empty_zvwb[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zcuv)
	if err != nil {
		return err
	}

	if !empty_zvwb[0] {
		// write "Bugs"
		err = en.Append(0xa4, 0x42, 0x75, 0x67, 0x73)
		if err != nil {
			return err
		}
		if z.Bugs == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bugs.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zvwb[1] {
		// write "Road"
		err = en.Append(0xa4, 0x52, 0x6f, 0x61, 0x64)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Road)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zvwb[2] {
		// write "Moose"
		err = en.Append(0xa5, 0x4d, 0x6f, 0x6f, 0x73, 0x65)
		if err != nil {
			return err
		}
		if z.Moose == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Moose.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Rocky) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [3]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Bugs"
		o = append(o, 0xa4, 0x42, 0x75, 0x67, 0x73)
		if z.Bugs == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bugs.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[1] {
		// string "Road"
		o = append(o, 0xa4, 0x52, 0x6f, 0x61, 0x64)
		o = msgp.AppendString(o, z.Road)
	}

	if !empty[2] {
		// string "Moose"
		o = append(o, 0xa5, 0x4d, 0x6f, 0x6f, 0x73, 0x65)
		if z.Moose == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Moose.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Rocky) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields26zefk = 3

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields26zefk uint32
	if !nbs.AlwaysNil {
		totalEncodedFields26zefk, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft26zefk := totalEncodedFields26zefk
	missingFieldsLeft26zefk := maxFields26zefk - totalEncodedFields26zefk

	var nextMiss26zefk int32 = -1
	var found26zefk [maxFields26zefk]bool
	var curField26zefk string

doneWithStruct26zefk:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft26zefk > 0 || missingFieldsLeft26zefk > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft26zefk, missingFieldsLeft26zefk, msgp.ShowFound(found26zefk[:]), unmarshalMsgFieldOrder26zefk)
		if encodedFieldsLeft26zefk > 0 {
			encodedFieldsLeft26zefk--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField26zefk = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss26zefk < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss26zefk = 0
			}
			for nextMiss26zefk < maxFields26zefk && found26zefk[nextMiss26zefk] {
				nextMiss26zefk++
			}
			if nextMiss26zefk == maxFields26zefk {
				// filled all the empty fields!
				break doneWithStruct26zefk
			}
			missingFieldsLeft26zefk--
			curField26zefk = unmarshalMsgFieldOrder26zefk[nextMiss26zefk]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField26zefk)
		switch curField26zefk {
		// -- templateUnmarshalMsg ends here --

		case "Bugs":
			found26zefk[0] = true
			if nbs.AlwaysNil {
				if z.Bugs != nil {
					z.Bugs.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bugs {
						z.Bugs.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bugs == nil {
						z.Bugs = new(Bunny)
					}
					bts, err = z.Bugs.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "Road":
			found26zefk[1] = true
			z.Road, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Moose":
			found26zefk[2] = true
			if nbs.AlwaysNil {
				if z.Moose != nil {
					z.Moose.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Moose {
						z.Moose.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Moose == nil {
						z.Moose = new(Moose)
					}
					bts, err = z.Moose.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss26zefk != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Rocky
var unmarshalMsgFieldOrder26zefk = []string{"Bugs", "Road", "Moose"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Rocky) Msgsize() (s int) {
	s = 1 + 5
	if z.Bugs == nil {
		s += msgp.NilSize
	} else {
		s += z.Bugs.Msgsize()
	}
	s += 5 + msgp.StringPrefixSize + len(z.Road) + 6
	if z.Moose == nil {
		s += msgp.NilSize
	} else {
		s += z.Moose.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestBench) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zodb uint32
	zodb, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zodb != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zodb}
		return
	}
	z.Name, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	z.BirthDay, err = dc.ReadTime()
	if err != nil {
		panic(err)
	}
	z.Phone, err = dc.ReadString()
	if err != nil {
		panic(err)
	}
	z.Siblings, err = dc.ReadInt()
	if err != nil {
		panic(err)
	}
	z.Spouse, err = dc.ReadBool()
	if err != nil {
		panic(err)
	}
	z.Money, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *TestBench) fieldsNotEmpty(isempty []bool) uint32 {
	return 6
}

// EncodeMsg implements msgp.Encodable
func (z *TestBench) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Name)
	if err != nil {
		panic(err)
	}
	err = en.WriteTime(z.BirthDay)
	if err != nil {
		panic(err)
	}
	err = en.WriteString(z.Phone)
	if err != nil {
		panic(err)
	}
	err = en.WriteInt(z.Siblings)
	if err != nil {
		panic(err)
	}
	err = en.WriteBool(z.Spouse)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Money)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestBench) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendString(o, z.Name)
	o = msgp.AppendTime(o, z.BirthDay)
	o = msgp.AppendString(o, z.Phone)
	o = msgp.AppendInt(o, z.Siblings)
	o = msgp.AppendBool(o, z.Spouse)
	o = msgp.AppendFloat64(o, z.Money)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestBench) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zpba uint32
	zpba, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zpba != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zpba}
		return
	}
	z.Name, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	z.BirthDay, bts, err = nbs.ReadTimeBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Phone, bts, err = nbs.ReadStringBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Siblings, bts, err = nbs.ReadIntBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Spouse, bts, err = nbs.ReadBoolBytes(bts)

	if err != nil {
		panic(err)
	}
	z.Money, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestBench) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Name) + msgp.TimeSize + msgp.StringPrefixSize + len(z.Phone) + msgp.IntSize + msgp.BoolSize + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestFast) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var zbfe uint32
	zbfe, err = dc.ReadArrayHeader()
	if err != nil {
		panic(err)
	}
	if zbfe != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zbfe}
		return
	}
	z.Lat, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Long, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Alt, err = dc.ReadFloat64()
	if err != nil {
		panic(err)
	}
	z.Data, err = dc.ReadBytes(z.Data)
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fieldsNotEmpty supports omitempty tags
func (z *TestFast) fieldsNotEmpty(isempty []bool) uint32 {
	return 4
}

// EncodeMsg implements msgp.Encodable
func (z *TestFast) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return err
	}
	err = en.WriteFloat64(z.Lat)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Long)
	if err != nil {
		panic(err)
	}
	err = en.WriteFloat64(z.Alt)
	if err != nil {
		panic(err)
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestFast) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendFloat64(o, z.Lat)
	o = msgp.AppendFloat64(o, z.Long)
	o = msgp.AppendFloat64(o, z.Alt)
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestFast) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zvjg uint32
	zvjg, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		panic(err)
	}
	if zvjg != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zvjg}
		return
	}
	z.Lat, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	z.Long, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	z.Alt, bts, err = nbs.ReadFloat64Bytes(bts)

	if err != nil {
		panic(err)
	}
	if nbs.AlwaysNil || msgp.IsNil(bts) {
		if !nbs.AlwaysNil {
			bts = bts[1:]
		}
		z.Data = z.Data[:0]
	} else {
		z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

		if err != nil {
			panic(err)
		}
	}
	if err != nil {
		panic(err)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestFast) Msgsize() (s int) {
	s = 1 + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestHidden) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields27zpnh = 2

	// -- templateDecodeMsg starts here--
	var totalEncodedFields27zpnh uint32
	totalEncodedFields27zpnh, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft27zpnh := totalEncodedFields27zpnh
	missingFieldsLeft27zpnh := maxFields27zpnh - totalEncodedFields27zpnh

	var nextMiss27zpnh int32 = -1
	var found27zpnh [maxFields27zpnh]bool
	var curField27zpnh string

doneWithStruct27zpnh:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft27zpnh > 0 || missingFieldsLeft27zpnh > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft27zpnh, missingFieldsLeft27zpnh, msgp.ShowFound(found27zpnh[:]), decodeMsgFieldOrder27zpnh)
		if encodedFieldsLeft27zpnh > 0 {
			encodedFieldsLeft27zpnh--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField27zpnh = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss27zpnh < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss27zpnh = 0
			}
			for nextMiss27zpnh < maxFields27zpnh && found27zpnh[nextMiss27zpnh] {
				nextMiss27zpnh++
			}
			if nextMiss27zpnh == maxFields27zpnh {
				// filled all the empty fields!
				break doneWithStruct27zpnh
			}
			missingFieldsLeft27zpnh--
			curField27zpnh = decodeMsgFieldOrder27zpnh[nextMiss27zpnh]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField27zpnh)
		switch curField27zpnh {
		// -- templateDecodeMsg ends here --

		case "A":
			found27zpnh[0] = true
			z.A, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "B":
			found27zpnh[1] = true
			var zdlp uint32
			zdlp, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.B) >= int(zdlp) {
				z.B = (z.B)[:zdlp]
			} else {
				z.B = make([]float64, zdlp)
			}
			for zbsh := range z.B {
				z.B[zbsh], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss27zpnh != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestHidden
var decodeMsgFieldOrder27zpnh = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z *TestHidden) fieldsNotEmpty(isempty []bool) uint32 {
	return 2
}

// EncodeMsg implements msgp.Encodable
func (z *TestHidden) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "A"
	err = en.Append(0x82, 0xa1, 0x41)
	if err != nil {
		return err
	}
	err = en.WriteString(z.A)
	if err != nil {
		panic(err)
	}
	// write "B"
	err = en.Append(0xa1, 0x42)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.B)))
	if err != nil {
		panic(err)
	}
	for zbsh := range z.B {
		err = en.WriteFloat64(z.B[zbsh])
		if err != nil {
			panic(err)
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestHidden) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "A"
	o = append(o, 0x82, 0xa1, 0x41)
	o = msgp.AppendString(o, z.A)
	// string "B"
	o = append(o, 0xa1, 0x42)
	o = msgp.AppendArrayHeader(o, uint32(len(z.B)))
	for zbsh := range z.B {
		o = msgp.AppendFloat64(o, z.B[zbsh])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestHidden) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields28zkfj = 2

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields28zkfj uint32
	if !nbs.AlwaysNil {
		totalEncodedFields28zkfj, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft28zkfj := totalEncodedFields28zkfj
	missingFieldsLeft28zkfj := maxFields28zkfj - totalEncodedFields28zkfj

	var nextMiss28zkfj int32 = -1
	var found28zkfj [maxFields28zkfj]bool
	var curField28zkfj string

doneWithStruct28zkfj:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft28zkfj > 0 || missingFieldsLeft28zkfj > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft28zkfj, missingFieldsLeft28zkfj, msgp.ShowFound(found28zkfj[:]), unmarshalMsgFieldOrder28zkfj)
		if encodedFieldsLeft28zkfj > 0 {
			encodedFieldsLeft28zkfj--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField28zkfj = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss28zkfj < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss28zkfj = 0
			}
			for nextMiss28zkfj < maxFields28zkfj && found28zkfj[nextMiss28zkfj] {
				nextMiss28zkfj++
			}
			if nextMiss28zkfj == maxFields28zkfj {
				// filled all the empty fields!
				break doneWithStruct28zkfj
			}
			missingFieldsLeft28zkfj--
			curField28zkfj = unmarshalMsgFieldOrder28zkfj[nextMiss28zkfj]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField28zkfj)
		switch curField28zkfj {
		// -- templateUnmarshalMsg ends here --

		case "A":
			found28zkfj[0] = true
			z.A, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "B":
			found28zkfj[1] = true
			if nbs.AlwaysNil {
				(z.B) = (z.B)[:0]
			} else {

				var zfyx uint32
				zfyx, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.B) >= int(zfyx) {
					z.B = (z.B)[:zfyx]
				} else {
					z.B = make([]float64, zfyx)
				}
				for zbsh := range z.B {
					z.B[zbsh], bts, err = nbs.ReadFloat64Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss28zkfj != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestHidden
var unmarshalMsgFieldOrder28zkfj = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestHidden) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.A) + 2 + msgp.ArrayHeaderSize + (len(z.B) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestOmitEmpty) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields29zrfe = 29

	// -- templateDecodeMsg starts here--
	var totalEncodedFields29zrfe uint32
	totalEncodedFields29zrfe, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft29zrfe := totalEncodedFields29zrfe
	missingFieldsLeft29zrfe := maxFields29zrfe - totalEncodedFields29zrfe

	var nextMiss29zrfe int32 = -1
	var found29zrfe [maxFields29zrfe]bool
	var curField29zrfe string

doneWithStruct29zrfe:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft29zrfe > 0 || missingFieldsLeft29zrfe > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft29zrfe, missingFieldsLeft29zrfe, msgp.ShowFound(found29zrfe[:]), decodeMsgFieldOrder29zrfe)
		if encodedFieldsLeft29zrfe > 0 {
			encodedFieldsLeft29zrfe--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField29zrfe = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss29zrfe < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss29zrfe = 0
			}
			for nextMiss29zrfe < maxFields29zrfe && found29zrfe[nextMiss29zrfe] {
				nextMiss29zrfe++
			}
			if nextMiss29zrfe == maxFields29zrfe {
				// filled all the empty fields!
				break doneWithStruct29zrfe
			}
			missingFieldsLeft29zrfe--
			curField29zrfe = decodeMsgFieldOrder29zrfe[nextMiss29zrfe]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField29zrfe)
		switch curField29zrfe {
		// -- templateDecodeMsg ends here --

		case "Name":
			found29zrfe[0] = true
			z.Name, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "BirthDay":
			found29zrfe[1] = true
			z.BirthDay, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "Phone":
			found29zrfe[2] = true
			z.Phone, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Siblings":
			found29zrfe[3] = true
			z.Siblings, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Spouse":
			found29zrfe[4] = true
			z.Spouse, err = dc.ReadBool()
			if err != nil {
				panic(err)
			}
		case "Money":
			found29zrfe[5] = true
			z.Money, err = dc.ReadFloat64()
			if err != nil {
				panic(err)
			}
		case "SliceName":
			found29zrfe[6] = true
			var zjks uint32
			zjks, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceName) >= int(zjks) {
				z.SliceName = (z.SliceName)[:zjks]
			} else {
				z.SliceName = make([]string, zjks)
			}
			for zpeg := range z.SliceName {
				z.SliceName[zpeg], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SliceBirthDay":
			found29zrfe[7] = true
			var zrwp uint32
			zrwp, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceBirthDay) >= int(zrwp) {
				z.SliceBirthDay = (z.SliceBirthDay)[:zrwp]
			} else {
				z.SliceBirthDay = make([]time.Time, zrwp)
			}
			for zdzw := range z.SliceBirthDay {
				z.SliceBirthDay[zdzw], err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "SlicePhone":
			found29zrfe[8] = true
			var zapq uint32
			zapq, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SlicePhone) >= int(zapq) {
				z.SlicePhone = (z.SlicePhone)[:zapq]
			} else {
				z.SlicePhone = make([]string, zapq)
			}
			for zdgs := range z.SlicePhone {
				z.SlicePhone[zdgs], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SliceSiblings":
			found29zrfe[9] = true
			var zxwe uint32
			zxwe, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceSiblings) >= int(zxwe) {
				z.SliceSiblings = (z.SliceSiblings)[:zxwe]
			} else {
				z.SliceSiblings = make([]int, zxwe)
			}
			for zszv := range z.SliceSiblings {
				z.SliceSiblings[zszv], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "SliceSpouse":
			found29zrfe[10] = true
			var znvh uint32
			znvh, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceSpouse) >= int(znvh) {
				z.SliceSpouse = (z.SliceSpouse)[:znvh]
			} else {
				z.SliceSpouse = make([]bool, znvh)
			}
			for ztdr := range z.SliceSpouse {
				z.SliceSpouse[ztdr], err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "SliceMoney":
			found29zrfe[11] = true
			var zapw uint32
			zapw, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.SliceMoney) >= int(zapw) {
				z.SliceMoney = (z.SliceMoney)[:zapw]
			} else {
				z.SliceMoney = make([]float64, zapw)
			}
			for zsda := range z.SliceMoney {
				z.SliceMoney[zsda], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayName":
			found29zrfe[12] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zadk uint32
				zadk, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zadk != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zadk}
					return
				}
			}
			for zwvu := range z.ArrayName {
				z.ArrayName[zwvu], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayBirthDay":
			found29zrfe[13] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zkel uint32
				zkel, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zkel != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zkel}
					return
				}
			}
			for zaki := range z.ArrayBirthDay {
				z.ArrayBirthDay[zaki], err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayPhone":
			found29zrfe[14] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zeyn uint32
				zeyn, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zeyn != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zeyn}
					return
				}
			}
			for zxdk := range z.ArrayPhone {
				z.ArrayPhone[zxdk], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "ArraySiblings":
			found29zrfe[15] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zbjw uint32
				zbjw, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zbjw != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zbjw}
					return
				}
			}
			for zjuy := range z.ArraySiblings {
				z.ArraySiblings[zjuy], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "ArraySpouse":
			found29zrfe[16] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zbti uint32
				zbti, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zbti != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zbti}
					return
				}
			}
			for zamf := range z.ArraySpouse {
				z.ArraySpouse[zamf], err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "ArrayMoney":
			found29zrfe[17] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zjsg uint32
				zjsg, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zjsg != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zjsg}
					return
				}
			}
			for zetn := range z.ArrayMoney {
				z.ArrayMoney[zetn], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "MapStringString":
			found29zrfe[18] = true
			var zuzq uint32
			zuzq, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MapStringString == nil && zuzq > 0 {
				z.MapStringString = make(map[string]string, zuzq)
			} else if len(z.MapStringString) > 0 {
				for key, _ := range z.MapStringString {
					delete(z.MapStringString, key)
				}
			}
			for zuzq > 0 {
				zuzq--
				var zrpb string
				var zguh string
				zrpb, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zguh, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.MapStringString[zrpb] = zguh
			}
		case "MapStringIface":
			found29zrfe[19] = true
			var zjog uint32
			zjog, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MapStringIface == nil && zjog > 0 {
				z.MapStringIface = make(map[string]interface{}, zjog)
			} else if len(z.MapStringIface) > 0 {
				for key, _ := range z.MapStringIface {
					delete(z.MapStringIface, key)
				}
			}
			for zjog > 0 {
				zjog--
				var zbht string
				var zgjy interface{}
				zbht, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zgjy, err = dc.ReadIntf()
				if err != nil {
					panic(err)
				}
				z.MapStringIface[zbht] = zgjy
			}
		case "PtrName":
			found29zrfe[20] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrName == nil {
					z.PtrName = new(string)
				}
				*z.PtrName, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "PtrBirthDay":
			found29zrfe[21] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrBirthDay == nil {
					z.PtrBirthDay = new(time.Time)
				}
				*z.PtrBirthDay, err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		case "PtrPhone":
			found29zrfe[22] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrPhone == nil {
					z.PtrPhone = new(string)
				}
				*z.PtrPhone, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "PtrSiblings":
			found29zrfe[23] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrSiblings == nil {
					z.PtrSiblings = new(int)
				}
				*z.PtrSiblings, err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "PtrSpouse":
			found29zrfe[24] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrSpouse == nil {
					z.PtrSpouse = new(bool)
				}
				*z.PtrSpouse, err = dc.ReadBool()
				if err != nil {
					panic(err)
				}
			}
		case "PtrMoney":
			found29zrfe[25] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrMoney == nil {
					z.PtrMoney = new(float64)
				}
				*z.PtrMoney, err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "Inside1":
			found29zrfe[26] = true
			const maxFields30zigg = 3

			// -- templateDecodeMsg starts here--
			var totalEncodedFields30zigg uint32
			totalEncodedFields30zigg, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft30zigg := totalEncodedFields30zigg
			missingFieldsLeft30zigg := maxFields30zigg - totalEncodedFields30zigg

			var nextMiss30zigg int32 = -1
			var found30zigg [maxFields30zigg]bool
			var curField30zigg string

		doneWithStruct30zigg:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft30zigg > 0 || missingFieldsLeft30zigg > 0 {
				//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft30zigg, missingFieldsLeft30zigg, msgp.ShowFound(found30zigg[:]), decodeMsgFieldOrder30zigg)
				if encodedFieldsLeft30zigg > 0 {
					encodedFieldsLeft30zigg--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField30zigg = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss30zigg < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss30zigg = 0
					}
					for nextMiss30zigg < maxFields30zigg && found30zigg[nextMiss30zigg] {
						nextMiss30zigg++
					}
					if nextMiss30zigg == maxFields30zigg {
						// filled all the empty fields!
						break doneWithStruct30zigg
					}
					missingFieldsLeft30zigg--
					curField30zigg = decodeMsgFieldOrder30zigg[nextMiss30zigg]
				}
				//fmt.Printf("switching on curField: '%v'\n", curField30zigg)
				switch curField30zigg {
				// -- templateDecodeMsg ends here --

				case "CountOfMonteCrisco":
					found30zigg[0] = true
					z.Inside1.CountOfMonteCrisco, err = dc.ReadInt()
					if err != nil {
						panic(err)
					}
				case "name":
					found30zigg[1] = true
					z.Inside1.Name, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				case "Inside2":
					found30zigg[2] = true
					const maxFields31zkff = 1

					// -- templateDecodeMsg starts here--
					var totalEncodedFields31zkff uint32
					totalEncodedFields31zkff, err = dc.ReadMapHeader()
					if err != nil {
						return
					}
					encodedFieldsLeft31zkff := totalEncodedFields31zkff
					missingFieldsLeft31zkff := maxFields31zkff - totalEncodedFields31zkff

					var nextMiss31zkff int32 = -1
					var found31zkff [maxFields31zkff]bool
					var curField31zkff string

				doneWithStruct31zkff:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft31zkff > 0 || missingFieldsLeft31zkff > 0 {
						//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft31zkff, missingFieldsLeft31zkff, msgp.ShowFound(found31zkff[:]), decodeMsgFieldOrder31zkff)
						if encodedFieldsLeft31zkff > 0 {
							encodedFieldsLeft31zkff--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								return
							}
							curField31zkff = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss31zkff < 0 {
								// tell the reader to only give us Nils
								// until further notice.
								dc.PushAlwaysNil()
								nextMiss31zkff = 0
							}
							for nextMiss31zkff < maxFields31zkff && found31zkff[nextMiss31zkff] {
								nextMiss31zkff++
							}
							if nextMiss31zkff == maxFields31zkff {
								// filled all the empty fields!
								break doneWithStruct31zkff
							}
							missingFieldsLeft31zkff--
							curField31zkff = decodeMsgFieldOrder31zkff[nextMiss31zkff]
						}
						//fmt.Printf("switching on curField: '%v'\n", curField31zkff)
						switch curField31zkff {
						// -- templateDecodeMsg ends here --

						case "NameSuey":
							found31zkff[0] = true
							z.Inside1.Inside2.NameSuey, err = dc.ReadString()
							if err != nil {
								panic(err)
							}
						default:
							err = dc.Skip()
							if err != nil {
								panic(err)
							}
						}
					}
					if nextMiss31zkff != -1 {
						dc.PopAlwaysNil()
					}

				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss30zigg != -1 {
				dc.PopAlwaysNil()
			}

		case "Greetings":
			found29zrfe[27] = true
			z.Greetings, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found29zrfe[28] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bullwinkle != nil {
					dc.PushAlwaysNil()
					err = z.Bullwinkle.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bullwinkle == nil {
					z.Bullwinkle = new(Rocky)
				}
				err = z.Bullwinkle.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss29zrfe != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestOmitEmpty
var decodeMsgFieldOrder29zrfe = []string{"Name", "BirthDay", "Phone", "Siblings", "Spouse", "Money", "SliceName", "SliceBirthDay", "SlicePhone", "SliceSiblings", "SliceSpouse", "SliceMoney", "ArrayName", "ArrayBirthDay", "ArrayPhone", "ArraySiblings", "ArraySpouse", "ArrayMoney", "MapStringString", "MapStringIface", "PtrName", "PtrBirthDay", "PtrPhone", "PtrSiblings", "PtrSpouse", "PtrMoney", "Inside1", "Greetings", "Bullwinkle"}

// fields of OmitEmptyInside1
var decodeMsgFieldOrder30zigg = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var decodeMsgFieldOrder31zkff = []string{"NameSuey"}

// fieldsNotEmpty supports omitempty tags
func (z *TestOmitEmpty) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 29
	}
	var fieldsInUse uint32 = 29
	isempty[0] = (len(z.Name) == 0) // string, omitempty
	if isempty[0] {
		fieldsInUse--
	}
	isempty[1] = (z.BirthDay.IsZero()) // time.Time, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (len(z.Phone) == 0) // string, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (z.Siblings == 0) // number, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (!z.Spouse) // bool, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (z.Money == 0) // number, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (len(z.SliceName) == 0) // string, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (len(z.SliceBirthDay) == 0) // string, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (len(z.SlicePhone) == 0) // string, omitempty
	if isempty[8] {
		fieldsInUse--
	}
	isempty[9] = (len(z.SliceSiblings) == 0) // string, omitempty
	if isempty[9] {
		fieldsInUse--
	}
	isempty[10] = (len(z.SliceSpouse) == 0) // string, omitempty
	if isempty[10] {
		fieldsInUse--
	}
	isempty[11] = (len(z.SliceMoney) == 0) // string, omitempty
	if isempty[11] {
		fieldsInUse--
	}
	isempty[12] = (len(z.ArrayName) == 0) // string, omitempty
	if isempty[12] {
		fieldsInUse--
	}
	isempty[13] = (len(z.ArrayBirthDay) == 0) // string, omitempty
	if isempty[13] {
		fieldsInUse--
	}
	isempty[14] = (len(z.ArrayPhone) == 0) // string, omitempty
	if isempty[14] {
		fieldsInUse--
	}
	isempty[15] = (len(z.ArraySiblings) == 0) // string, omitempty
	if isempty[15] {
		fieldsInUse--
	}
	isempty[16] = (len(z.ArraySpouse) == 0) // string, omitempty
	if isempty[16] {
		fieldsInUse--
	}
	isempty[17] = (len(z.ArrayMoney) == 0) // string, omitempty
	if isempty[17] {
		fieldsInUse--
	}
	isempty[18] = (len(z.MapStringString) == 0) // string, omitempty
	if isempty[18] {
		fieldsInUse--
	}
	isempty[19] = (len(z.MapStringIface) == 0) // string, omitempty
	if isempty[19] {
		fieldsInUse--
	}
	isempty[20] = (z.PtrName == nil) // pointer, omitempty
	if isempty[20] {
		fieldsInUse--
	}
	isempty[21] = (z.PtrBirthDay == nil) // pointer, omitempty
	if isempty[21] {
		fieldsInUse--
	}
	isempty[22] = (z.PtrPhone == nil) // pointer, omitempty
	if isempty[22] {
		fieldsInUse--
	}
	isempty[23] = (z.PtrSiblings == nil) // pointer, omitempty
	if isempty[23] {
		fieldsInUse--
	}
	isempty[24] = (z.PtrSpouse == nil) // pointer, omitempty
	if isempty[24] {
		fieldsInUse--
	}
	isempty[25] = (z.PtrMoney == nil) // pointer, omitempty
	if isempty[25] {
		fieldsInUse--
	}
	isempty[26] = false // struct values are never empty
	if isempty[26] {
		fieldsInUse--
	}
	isempty[27] = (len(z.Greetings) == 0) // string, omitempty
	if isempty[27] {
		fieldsInUse--
	}
	isempty[28] = (z.Bullwinkle == nil) // pointer, omitempty
	if isempty[28] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *TestOmitEmpty) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zuze [29]bool
	fieldsInUse_zewu := z.fieldsNotEmpty(empty_zuze[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zewu)
	if err != nil {
		return err
	}

	if !empty_zuze[0] {
		// write "Name"
		err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Name)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[1] {
		// write "BirthDay"
		err = en.Append(0xa8, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteTime(z.BirthDay)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[2] {
		// write "Phone"
		err = en.Append(0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Phone)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[3] {
		// write "Siblings"
		err = en.Append(0xa8, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.Siblings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[4] {
		// write "Spouse"
		err = en.Append(0xa6, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.Spouse)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[5] {
		// write "Money"
		err = en.Append(0xa5, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteFloat64(z.Money)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[6] {
		// write "SliceName"
		err = en.Append(0xa9, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceName)))
		if err != nil {
			panic(err)
		}
		for zpeg := range z.SliceName {
			err = en.WriteString(z.SliceName[zpeg])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[7] {
		// write "SliceBirthDay"
		err = en.Append(0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceBirthDay)))
		if err != nil {
			panic(err)
		}
		for zdzw := range z.SliceBirthDay {
			err = en.WriteTime(z.SliceBirthDay[zdzw])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[8] {
		// write "SlicePhone"
		err = en.Append(0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SlicePhone)))
		if err != nil {
			panic(err)
		}
		for zdgs := range z.SlicePhone {
			err = en.WriteString(z.SlicePhone[zdgs])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[9] {
		// write "SliceSiblings"
		err = en.Append(0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceSiblings)))
		if err != nil {
			panic(err)
		}
		for zszv := range z.SliceSiblings {
			err = en.WriteInt(z.SliceSiblings[zszv])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[10] {
		// write "SliceSpouse"
		err = en.Append(0xab, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceSpouse)))
		if err != nil {
			panic(err)
		}
		for ztdr := range z.SliceSpouse {
			err = en.WriteBool(z.SliceSpouse[ztdr])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[11] {
		// write "SliceMoney"
		err = en.Append(0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(uint32(len(z.SliceMoney)))
		if err != nil {
			panic(err)
		}
		for zsda := range z.SliceMoney {
			err = en.WriteFloat64(z.SliceMoney[zsda])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[12] {
		// write "ArrayName"
		err = en.Append(0xa9, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zwvu := range z.ArrayName {
			err = en.WriteString(z.ArrayName[zwvu])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[13] {
		// write "ArrayBirthDay"
		err = en.Append(0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zaki := range z.ArrayBirthDay {
			err = en.WriteTime(z.ArrayBirthDay[zaki])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[14] {
		// write "ArrayPhone"
		err = en.Append(0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zxdk := range z.ArrayPhone {
			err = en.WriteString(z.ArrayPhone[zxdk])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[15] {
		// write "ArraySiblings"
		err = en.Append(0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zjuy := range z.ArraySiblings {
			err = en.WriteInt(z.ArraySiblings[zjuy])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[16] {
		// write "ArraySpouse"
		err = en.Append(0xab, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zamf := range z.ArraySpouse {
			err = en.WriteBool(z.ArraySpouse[zamf])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[17] {
		// write "ArrayMoney"
		err = en.Append(0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zetn := range z.ArrayMoney {
			err = en.WriteFloat64(z.ArrayMoney[zetn])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[18] {
		// write "MapStringString"
		err = en.Append(0xaf, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MapStringString)))
		if err != nil {
			panic(err)
		}
		for zrpb, zguh := range z.MapStringString {
			err = en.WriteString(zrpb)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zguh)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[19] {
		// write "MapStringIface"
		err = en.Append(0xae, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x66, 0x61, 0x63, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MapStringIface)))
		if err != nil {
			panic(err)
		}
		for zbht, zgjy := range z.MapStringIface {
			err = en.WriteString(zbht)
			if err != nil {
				panic(err)
			}
			err = en.WriteIntf(zgjy)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[20] {
		// write "PtrName"
		err = en.Append(0xa7, 0x50, 0x74, 0x72, 0x4e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		if z.PtrName == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PtrName)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[21] {
		// write "PtrBirthDay"
		err = en.Append(0xab, 0x50, 0x74, 0x72, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if err != nil {
			return err
		}
		if z.PtrBirthDay == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteTime(*z.PtrBirthDay)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[22] {
		// write "PtrPhone"
		err = en.Append(0xa8, 0x50, 0x74, 0x72, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if err != nil {
			return err
		}
		if z.PtrPhone == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PtrPhone)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[23] {
		// write "PtrSiblings"
		err = en.Append(0xab, 0x50, 0x74, 0x72, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		if z.PtrSiblings == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.PtrSiblings)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[24] {
		// write "PtrSpouse"
		err = en.Append(0xa9, 0x50, 0x74, 0x72, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if err != nil {
			return err
		}
		if z.PtrSpouse == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.PtrSpouse)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[25] {
		// write "PtrMoney"
		err = en.Append(0xa8, 0x50, 0x74, 0x72, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if err != nil {
			return err
		}
		if z.PtrMoney == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.PtrMoney)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zuze[26] {
		// write "Inside1"
		// map header, size 3
		// write "CountOfMonteCrisco"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31, 0x83, 0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
		if err != nil {
			return err
		}
		err = en.WriteInt(z.Inside1.CountOfMonteCrisco)
		if err != nil {
			panic(err)
		}
		// write "name"
		err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Inside1.Name)
		if err != nil {
			panic(err)
		}
		// write "Inside2"
		// map header, size 1
		// write "NameSuey"
		err = en.Append(0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Inside1.Inside2.NameSuey)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[27] {
		// write "Greetings"
		err = en.Append(0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Greetings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zuze[28] {
		// write "Bullwinkle"
		err = en.Append(0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if err != nil {
			return err
		}
		if z.Bullwinkle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullwinkle.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestOmitEmpty) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [29]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	if !empty[0] {
		// string "Name"
		o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Name)
	}

	if !empty[1] {
		// string "BirthDay"
		o = append(o, 0xa8, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendTime(o, z.BirthDay)
	}

	if !empty[2] {
		// string "Phone"
		o = append(o, 0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendString(o, z.Phone)
	}

	if !empty[3] {
		// string "Siblings"
		o = append(o, 0xa8, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendInt(o, z.Siblings)
	}

	if !empty[4] {
		// string "Spouse"
		o = append(o, 0xa6, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendBool(o, z.Spouse)
	}

	if !empty[5] {
		// string "Money"
		o = append(o, 0xa5, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendFloat64(o, z.Money)
	}

	if !empty[6] {
		// string "SliceName"
		o = append(o, 0xa9, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceName)))
		for zpeg := range z.SliceName {
			o = msgp.AppendString(o, z.SliceName[zpeg])
		}
	}

	if !empty[7] {
		// string "SliceBirthDay"
		o = append(o, 0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceBirthDay)))
		for zdzw := range z.SliceBirthDay {
			o = msgp.AppendTime(o, z.SliceBirthDay[zdzw])
		}
	}

	if !empty[8] {
		// string "SlicePhone"
		o = append(o, 0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SlicePhone)))
		for zdgs := range z.SlicePhone {
			o = msgp.AppendString(o, z.SlicePhone[zdgs])
		}
	}

	if !empty[9] {
		// string "SliceSiblings"
		o = append(o, 0xad, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceSiblings)))
		for zszv := range z.SliceSiblings {
			o = msgp.AppendInt(o, z.SliceSiblings[zszv])
		}
	}

	if !empty[10] {
		// string "SliceSpouse"
		o = append(o, 0xab, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceSpouse)))
		for ztdr := range z.SliceSpouse {
			o = msgp.AppendBool(o, z.SliceSpouse[ztdr])
		}
	}

	if !empty[11] {
		// string "SliceMoney"
		o = append(o, 0xaa, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SliceMoney)))
		for zsda := range z.SliceMoney {
			o = msgp.AppendFloat64(o, z.SliceMoney[zsda])
		}
	}

	if !empty[12] {
		// string "ArrayName"
		o = append(o, 0xa9, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4e, 0x61, 0x6d, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zwvu := range z.ArrayName {
			o = msgp.AppendString(o, z.ArrayName[zwvu])
		}
	}

	if !empty[13] {
		// string "ArrayBirthDay"
		o = append(o, 0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zaki := range z.ArrayBirthDay {
			o = msgp.AppendTime(o, z.ArrayBirthDay[zaki])
		}
	}

	if !empty[14] {
		// string "ArrayPhone"
		o = append(o, 0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zxdk := range z.ArrayPhone {
			o = msgp.AppendString(o, z.ArrayPhone[zxdk])
		}
	}

	if !empty[15] {
		// string "ArraySiblings"
		o = append(o, 0xad, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, 3)
		for zjuy := range z.ArraySiblings {
			o = msgp.AppendInt(o, z.ArraySiblings[zjuy])
		}
	}

	if !empty[16] {
		// string "ArraySpouse"
		o = append(o, 0xab, 0x41, 0x72, 0x72, 0x61, 0x79, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		o = msgp.AppendArrayHeader(o, 3)
		for zamf := range z.ArraySpouse {
			o = msgp.AppendBool(o, z.ArraySpouse[zamf])
		}
	}

	if !empty[17] {
		// string "ArrayMoney"
		o = append(o, 0xaa, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zetn := range z.ArrayMoney {
			o = msgp.AppendFloat64(o, z.ArrayMoney[zetn])
		}
	}

	if !empty[18] {
		// string "MapStringString"
		o = append(o, 0xaf, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
		o = msgp.AppendMapHeader(o, uint32(len(z.MapStringString)))
		for zrpb, zguh := range z.MapStringString {
			o = msgp.AppendString(o, zrpb)
			o = msgp.AppendString(o, zguh)
		}
	}

	if !empty[19] {
		// string "MapStringIface"
		o = append(o, 0xae, 0x4d, 0x61, 0x70, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x66, 0x61, 0x63, 0x65)
		o = msgp.AppendMapHeader(o, uint32(len(z.MapStringIface)))
		for zbht, zgjy := range z.MapStringIface {
			o = msgp.AppendString(o, zbht)
			o, err = msgp.AppendIntf(o, zgjy)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[20] {
		// string "PtrName"
		o = append(o, 0xa7, 0x50, 0x74, 0x72, 0x4e, 0x61, 0x6d, 0x65)
		if z.PtrName == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PtrName)
		}
	}

	if !empty[21] {
		// string "PtrBirthDay"
		o = append(o, 0xab, 0x50, 0x74, 0x72, 0x42, 0x69, 0x72, 0x74, 0x68, 0x44, 0x61, 0x79)
		if z.PtrBirthDay == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendTime(o, *z.PtrBirthDay)
		}
	}

	if !empty[22] {
		// string "PtrPhone"
		o = append(o, 0xa8, 0x50, 0x74, 0x72, 0x50, 0x68, 0x6f, 0x6e, 0x65)
		if z.PtrPhone == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PtrPhone)
		}
	}

	if !empty[23] {
		// string "PtrSiblings"
		o = append(o, 0xab, 0x50, 0x74, 0x72, 0x53, 0x69, 0x62, 0x6c, 0x69, 0x6e, 0x67, 0x73)
		if z.PtrSiblings == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.PtrSiblings)
		}
	}

	if !empty[24] {
		// string "PtrSpouse"
		o = append(o, 0xa9, 0x50, 0x74, 0x72, 0x53, 0x70, 0x6f, 0x75, 0x73, 0x65)
		if z.PtrSpouse == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.PtrSpouse)
		}
	}

	if !empty[25] {
		// string "PtrMoney"
		o = append(o, 0xa8, 0x50, 0x74, 0x72, 0x4d, 0x6f, 0x6e, 0x65, 0x79)
		if z.PtrMoney == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.PtrMoney)
		}
	}

	if !empty[26] {
		// string "Inside1"
		// map header, size 3
		// string "CountOfMonteCrisco"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x31, 0x83, 0xb2, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x66, 0x4d, 0x6f, 0x6e, 0x74, 0x65, 0x43, 0x72, 0x69, 0x73, 0x63, 0x6f)
		o = msgp.AppendInt(o, z.Inside1.CountOfMonteCrisco)
		// string "name"
		o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Inside1.Name)
		// string "Inside2"
		// map header, size 1
		// string "NameSuey"
		o = append(o, 0xa7, 0x49, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x32, 0x81, 0xa8, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x65, 0x79)
		o = msgp.AppendString(o, z.Inside1.Inside2.NameSuey)
	}

	if !empty[27] {
		// string "Greetings"
		o = append(o, 0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendString(o, z.Greetings)
	}

	if !empty[28] {
		// string "Bullwinkle"
		o = append(o, 0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if z.Bullwinkle == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullwinkle.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestOmitEmpty) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields32zewh = 29

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields32zewh uint32
	if !nbs.AlwaysNil {
		totalEncodedFields32zewh, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft32zewh := totalEncodedFields32zewh
	missingFieldsLeft32zewh := maxFields32zewh - totalEncodedFields32zewh

	var nextMiss32zewh int32 = -1
	var found32zewh [maxFields32zewh]bool
	var curField32zewh string

doneWithStruct32zewh:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft32zewh > 0 || missingFieldsLeft32zewh > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft32zewh, missingFieldsLeft32zewh, msgp.ShowFound(found32zewh[:]), unmarshalMsgFieldOrder32zewh)
		if encodedFieldsLeft32zewh > 0 {
			encodedFieldsLeft32zewh--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField32zewh = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss32zewh < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss32zewh = 0
			}
			for nextMiss32zewh < maxFields32zewh && found32zewh[nextMiss32zewh] {
				nextMiss32zewh++
			}
			if nextMiss32zewh == maxFields32zewh {
				// filled all the empty fields!
				break doneWithStruct32zewh
			}
			missingFieldsLeft32zewh--
			curField32zewh = unmarshalMsgFieldOrder32zewh[nextMiss32zewh]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField32zewh)
		switch curField32zewh {
		// -- templateUnmarshalMsg ends here --

		case "Name":
			found32zewh[0] = true
			z.Name, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "BirthDay":
			found32zewh[1] = true
			z.BirthDay, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Phone":
			found32zewh[2] = true
			z.Phone, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Siblings":
			found32zewh[3] = true
			z.Siblings, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Spouse":
			found32zewh[4] = true
			z.Spouse, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Money":
			found32zewh[5] = true
			z.Money, bts, err = nbs.ReadFloat64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "SliceName":
			found32zewh[6] = true
			if nbs.AlwaysNil {
				(z.SliceName) = (z.SliceName)[:0]
			} else {

				var zpdk uint32
				zpdk, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceName) >= int(zpdk) {
					z.SliceName = (z.SliceName)[:zpdk]
				} else {
					z.SliceName = make([]string, zpdk)
				}
				for zpeg := range z.SliceName {
					z.SliceName[zpeg], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceBirthDay":
			found32zewh[7] = true
			if nbs.AlwaysNil {
				(z.SliceBirthDay) = (z.SliceBirthDay)[:0]
			} else {

				var zive uint32
				zive, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceBirthDay) >= int(zive) {
					z.SliceBirthDay = (z.SliceBirthDay)[:zive]
				} else {
					z.SliceBirthDay = make([]time.Time, zive)
				}
				for zdzw := range z.SliceBirthDay {
					z.SliceBirthDay[zdzw], bts, err = nbs.ReadTimeBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SlicePhone":
			found32zewh[8] = true
			if nbs.AlwaysNil {
				(z.SlicePhone) = (z.SlicePhone)[:0]
			} else {

				var zlnn uint32
				zlnn, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SlicePhone) >= int(zlnn) {
					z.SlicePhone = (z.SlicePhone)[:zlnn]
				} else {
					z.SlicePhone = make([]string, zlnn)
				}
				for zdgs := range z.SlicePhone {
					z.SlicePhone[zdgs], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceSiblings":
			found32zewh[9] = true
			if nbs.AlwaysNil {
				(z.SliceSiblings) = (z.SliceSiblings)[:0]
			} else {

				var zoke uint32
				zoke, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceSiblings) >= int(zoke) {
					z.SliceSiblings = (z.SliceSiblings)[:zoke]
				} else {
					z.SliceSiblings = make([]int, zoke)
				}
				for zszv := range z.SliceSiblings {
					z.SliceSiblings[zszv], bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceSpouse":
			found32zewh[10] = true
			if nbs.AlwaysNil {
				(z.SliceSpouse) = (z.SliceSpouse)[:0]
			} else {

				var zimh uint32
				zimh, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceSpouse) >= int(zimh) {
					z.SliceSpouse = (z.SliceSpouse)[:zimh]
				} else {
					z.SliceSpouse = make([]bool, zimh)
				}
				for ztdr := range z.SliceSpouse {
					z.SliceSpouse[ztdr], bts, err = nbs.ReadBoolBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SliceMoney":
			found32zewh[11] = true
			if nbs.AlwaysNil {
				(z.SliceMoney) = (z.SliceMoney)[:0]
			} else {

				var zzhl uint32
				zzhl, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.SliceMoney) >= int(zzhl) {
					z.SliceMoney = (z.SliceMoney)[:zzhl]
				} else {
					z.SliceMoney = make([]float64, zzhl)
				}
				for zsda := range z.SliceMoney {
					z.SliceMoney[zsda], bts, err = nbs.ReadFloat64Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "ArrayName":
			found32zewh[12] = true
			var zlsz uint32
			zlsz, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zlsz != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zlsz}
				return
			}
			for zwvu := range z.ArrayName {
				z.ArrayName[zwvu], bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayBirthDay":
			found32zewh[13] = true
			var zkzt uint32
			zkzt, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zkzt != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zkzt}
				return
			}
			for zaki := range z.ArrayBirthDay {
				z.ArrayBirthDay[zaki], bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayPhone":
			found32zewh[14] = true
			var zwwb uint32
			zwwb, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zwwb != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zwwb}
				return
			}
			for zxdk := range z.ArrayPhone {
				z.ArrayPhone[zxdk], bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArraySiblings":
			found32zewh[15] = true
			var ztwq uint32
			ztwq, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && ztwq != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: ztwq}
				return
			}
			for zjuy := range z.ArraySiblings {
				z.ArraySiblings[zjuy], bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArraySpouse":
			found32zewh[16] = true
			var zxjc uint32
			zxjc, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zxjc != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zxjc}
				return
			}
			for zamf := range z.ArraySpouse {
				z.ArraySpouse[zamf], bts, err = nbs.ReadBoolBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ArrayMoney":
			found32zewh[17] = true
			var zxaq uint32
			zxaq, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zxaq != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zxaq}
				return
			}
			for zetn := range z.ArrayMoney {
				z.ArrayMoney[zetn], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "MapStringString":
			found32zewh[18] = true
			if nbs.AlwaysNil {
				if len(z.MapStringString) > 0 {
					for key, _ := range z.MapStringString {
						delete(z.MapStringString, key)
					}
				}

			} else {

				var zjzr uint32
				zjzr, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MapStringString == nil && zjzr > 0 {
					z.MapStringString = make(map[string]string, zjzr)
				} else if len(z.MapStringString) > 0 {
					for key, _ := range z.MapStringString {
						delete(z.MapStringString, key)
					}
				}
				for zjzr > 0 {
					var zrpb string
					var zguh string
					zjzr--
					zrpb, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zguh, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MapStringString[zrpb] = zguh
				}
			}
		case "MapStringIface":
			found32zewh[19] = true
			if nbs.AlwaysNil {
				if len(z.MapStringIface) > 0 {
					for key, _ := range z.MapStringIface {
						delete(z.MapStringIface, key)
					}
				}

			} else {

				var zeyj uint32
				zeyj, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MapStringIface == nil && zeyj > 0 {
					z.MapStringIface = make(map[string]interface{}, zeyj)
				} else if len(z.MapStringIface) > 0 {
					for key, _ := range z.MapStringIface {
						delete(z.MapStringIface, key)
					}
				}
				for zeyj > 0 {
					var zbht string
					var zgjy interface{}
					zeyj--
					zbht, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zgjy, bts, err = nbs.ReadIntfBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MapStringIface[zbht] = zgjy
				}
			}
		case "PtrName":
			found32zewh[20] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrName == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrName == nil {
					z.PtrName = new(string)
				}
				*z.PtrName, bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrBirthDay":
			found32zewh[21] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrBirthDay == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrBirthDay == nil {
					z.PtrBirthDay = new(time.Time)
				}
				*z.PtrBirthDay, bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrPhone":
			found32zewh[22] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrPhone == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrPhone == nil {
					z.PtrPhone = new(string)
				}
				*z.PtrPhone, bts, err = nbs.ReadStringBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrSiblings":
			found32zewh[23] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrSiblings == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrSiblings == nil {
					z.PtrSiblings = new(int)
				}
				*z.PtrSiblings, bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrSpouse":
			found32zewh[24] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrSpouse == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrSpouse == nil {
					z.PtrSpouse = new(bool)
				}
				*z.PtrSpouse, bts, err = nbs.ReadBoolBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "PtrMoney":
			found32zewh[25] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrMoney == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrMoney == nil {
					z.PtrMoney = new(float64)
				}
				*z.PtrMoney, bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "Inside1":
			found32zewh[26] = true
			const maxFields33zzvo = 3

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields33zzvo uint32
			if !nbs.AlwaysNil {
				totalEncodedFields33zzvo, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft33zzvo := totalEncodedFields33zzvo
			missingFieldsLeft33zzvo := maxFields33zzvo - totalEncodedFields33zzvo

			var nextMiss33zzvo int32 = -1
			var found33zzvo [maxFields33zzvo]bool
			var curField33zzvo string

		doneWithStruct33zzvo:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft33zzvo > 0 || missingFieldsLeft33zzvo > 0 {
				//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft33zzvo, missingFieldsLeft33zzvo, msgp.ShowFound(found33zzvo[:]), unmarshalMsgFieldOrder33zzvo)
				if encodedFieldsLeft33zzvo > 0 {
					encodedFieldsLeft33zzvo--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField33zzvo = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss33zzvo < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss33zzvo = 0
					}
					for nextMiss33zzvo < maxFields33zzvo && found33zzvo[nextMiss33zzvo] {
						nextMiss33zzvo++
					}
					if nextMiss33zzvo == maxFields33zzvo {
						// filled all the empty fields!
						break doneWithStruct33zzvo
					}
					missingFieldsLeft33zzvo--
					curField33zzvo = unmarshalMsgFieldOrder33zzvo[nextMiss33zzvo]
				}
				//fmt.Printf("switching on curField: '%v'\n", curField33zzvo)
				switch curField33zzvo {
				// -- templateUnmarshalMsg ends here --

				case "CountOfMonteCrisco":
					found33zzvo[0] = true
					z.Inside1.CountOfMonteCrisco, bts, err = nbs.ReadIntBytes(bts)

					if err != nil {
						panic(err)
					}
				case "name":
					found33zzvo[1] = true
					z.Inside1.Name, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				case "Inside2":
					found33zzvo[2] = true
					const maxFields34zjkd = 1

					// -- templateUnmarshalMsg starts here--
					var totalEncodedFields34zjkd uint32
					if !nbs.AlwaysNil {
						totalEncodedFields34zjkd, bts, err = nbs.ReadMapHeaderBytes(bts)
						if err != nil {
							panic(err)
							return
						}
					}
					encodedFieldsLeft34zjkd := totalEncodedFields34zjkd
					missingFieldsLeft34zjkd := maxFields34zjkd - totalEncodedFields34zjkd

					var nextMiss34zjkd int32 = -1
					var found34zjkd [maxFields34zjkd]bool
					var curField34zjkd string

				doneWithStruct34zjkd:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft34zjkd > 0 || missingFieldsLeft34zjkd > 0 {
						//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft34zjkd, missingFieldsLeft34zjkd, msgp.ShowFound(found34zjkd[:]), unmarshalMsgFieldOrder34zjkd)
						if encodedFieldsLeft34zjkd > 0 {
							encodedFieldsLeft34zjkd--
							field, bts, err = nbs.ReadMapKeyZC(bts)
							if err != nil {
								panic(err)
								return
							}
							curField34zjkd = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss34zjkd < 0 {
								// set bts to contain just mnil (0xc0)
								bts = nbs.PushAlwaysNil(bts)
								nextMiss34zjkd = 0
							}
							for nextMiss34zjkd < maxFields34zjkd && found34zjkd[nextMiss34zjkd] {
								nextMiss34zjkd++
							}
							if nextMiss34zjkd == maxFields34zjkd {
								// filled all the empty fields!
								break doneWithStruct34zjkd
							}
							missingFieldsLeft34zjkd--
							curField34zjkd = unmarshalMsgFieldOrder34zjkd[nextMiss34zjkd]
						}
						//fmt.Printf("switching on curField: '%v'\n", curField34zjkd)
						switch curField34zjkd {
						// -- templateUnmarshalMsg ends here --

						case "NameSuey":
							found34zjkd[0] = true
							z.Inside1.Inside2.NameSuey, bts, err = nbs.ReadStringBytes(bts)

							if err != nil {
								panic(err)
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								panic(err)
							}
						}
					}
					if nextMiss34zjkd != -1 {
						bts = nbs.PopAlwaysNil()
					}

				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss33zzvo != -1 {
				bts = nbs.PopAlwaysNil()
			}

		case "Greetings":
			found32zewh[27] = true
			z.Greetings, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found32zewh[28] = true
			if nbs.AlwaysNil {
				if z.Bullwinkle != nil {
					z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bullwinkle {
						z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bullwinkle == nil {
						z.Bullwinkle = new(Rocky)
					}
					bts, err = z.Bullwinkle.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss32zewh != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestOmitEmpty
var unmarshalMsgFieldOrder32zewh = []string{"Name", "BirthDay", "Phone", "Siblings", "Spouse", "Money", "SliceName", "SliceBirthDay", "SlicePhone", "SliceSiblings", "SliceSpouse", "SliceMoney", "ArrayName", "ArrayBirthDay", "ArrayPhone", "ArraySiblings", "ArraySpouse", "ArrayMoney", "MapStringString", "MapStringIface", "PtrName", "PtrBirthDay", "PtrPhone", "PtrSiblings", "PtrSpouse", "PtrMoney", "Inside1", "Greetings", "Bullwinkle"}

// fields of OmitEmptyInside1
var unmarshalMsgFieldOrder33zzvo = []string{"CountOfMonteCrisco", "name", "Inside2"}

// fields of OmitEmptyInside2
var unmarshalMsgFieldOrder34zjkd = []string{"NameSuey"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestOmitEmpty) Msgsize() (s int) {
	s = 3 + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.TimeSize + 6 + msgp.StringPrefixSize + len(z.Phone) + 9 + msgp.IntSize + 7 + msgp.BoolSize + 6 + msgp.Float64Size + 10 + msgp.ArrayHeaderSize
	for zpeg := range z.SliceName {
		s += msgp.StringPrefixSize + len(z.SliceName[zpeg])
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.SliceBirthDay) * (msgp.TimeSize)) + 11 + msgp.ArrayHeaderSize
	for zdgs := range z.SlicePhone {
		s += msgp.StringPrefixSize + len(z.SlicePhone[zdgs])
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.SliceSiblings) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.SliceSpouse) * (msgp.BoolSize)) + 11 + msgp.ArrayHeaderSize + (len(z.SliceMoney) * (msgp.Float64Size)) + 10 + msgp.ArrayHeaderSize
	for zwvu := range z.ArrayName {
		s += msgp.StringPrefixSize + len(z.ArrayName[zwvu])
	}
	s += 14 + msgp.ArrayHeaderSize + (3 * (msgp.TimeSize)) + 11 + msgp.ArrayHeaderSize
	for zxdk := range z.ArrayPhone {
		s += msgp.StringPrefixSize + len(z.ArrayPhone[zxdk])
	}
	s += 14 + msgp.ArrayHeaderSize + (3 * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (3 * (msgp.BoolSize)) + 11 + msgp.ArrayHeaderSize + (3 * (msgp.Float64Size)) + 16 + msgp.MapHeaderSize
	if z.MapStringString != nil {
		for zrpb, zguh := range z.MapStringString {
			_ = zguh
			s += msgp.StringPrefixSize + len(zrpb) + msgp.StringPrefixSize + len(zguh)
		}
	}
	s += 15 + msgp.MapHeaderSize
	if z.MapStringIface != nil {
		for zbht, zgjy := range z.MapStringIface {
			_ = zgjy
			s += msgp.StringPrefixSize + len(zbht) + msgp.GuessSize(zgjy)
		}
	}
	s += 8
	if z.PtrName == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PtrName)
	}
	s += 12
	if z.PtrBirthDay == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 9
	if z.PtrPhone == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PtrPhone)
	}
	s += 12
	if z.PtrSiblings == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.PtrSpouse == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 9
	if z.PtrMoney == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 8 + 1 + 19 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Inside1.Name) + 8 + 1 + 9 + msgp.StringPrefixSize + len(z.Inside1.Inside2.NameSuey) + 10 + msgp.StringPrefixSize + len(z.Greetings) + 11
	if z.Bullwinkle == nil {
		s += msgp.NilSize
	} else {
		s += z.Bullwinkle.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TestType) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields35zsvo = 11

	// -- templateDecodeMsg starts here--
	var totalEncodedFields35zsvo uint32
	totalEncodedFields35zsvo, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft35zsvo := totalEncodedFields35zsvo
	missingFieldsLeft35zsvo := maxFields35zsvo - totalEncodedFields35zsvo

	var nextMiss35zsvo int32 = -1
	var found35zsvo [maxFields35zsvo]bool
	var curField35zsvo string

doneWithStruct35zsvo:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft35zsvo > 0 || missingFieldsLeft35zsvo > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft35zsvo, missingFieldsLeft35zsvo, msgp.ShowFound(found35zsvo[:]), decodeMsgFieldOrder35zsvo)
		if encodedFieldsLeft35zsvo > 0 {
			encodedFieldsLeft35zsvo--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField35zsvo = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss35zsvo < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss35zsvo = 0
			}
			for nextMiss35zsvo < maxFields35zsvo && found35zsvo[nextMiss35zsvo] {
				nextMiss35zsvo++
			}
			if nextMiss35zsvo == maxFields35zsvo {
				// filled all the empty fields!
				break doneWithStruct35zsvo
			}
			missingFieldsLeft35zsvo--
			curField35zsvo = decodeMsgFieldOrder35zsvo[nextMiss35zsvo]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField35zsvo)
		switch curField35zsvo {
		// -- templateDecodeMsg ends here --

		case "float":
			found35zsvo[0] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.F == nil {
					z.F = new(float64)
				}
				*z.F, err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "elements":
			found35zsvo[1] = true
			var znnw uint32
			znnw, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.Els == nil && znnw > 0 {
				z.Els = make(map[string]string, znnw)
			} else if len(z.Els) > 0 {
				for key, _ := range z.Els {
					delete(z.Els, key)
				}
			}
			for znnw > 0 {
				znnw--
				var zwoz string
				var zvqe string
				zwoz, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zvqe, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.Els[zwoz] = zvqe
			}
		case "object":
			found35zsvo[2] = true
			const maxFields36zmkf = 2

			// -- templateDecodeMsg starts here--
			var totalEncodedFields36zmkf uint32
			totalEncodedFields36zmkf, err = dc.ReadMapHeader()
			if err != nil {
				return
			}
			encodedFieldsLeft36zmkf := totalEncodedFields36zmkf
			missingFieldsLeft36zmkf := maxFields36zmkf - totalEncodedFields36zmkf

			var nextMiss36zmkf int32 = -1
			var found36zmkf [maxFields36zmkf]bool
			var curField36zmkf string

		doneWithStruct36zmkf:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft36zmkf > 0 || missingFieldsLeft36zmkf > 0 {
				//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft36zmkf, missingFieldsLeft36zmkf, msgp.ShowFound(found36zmkf[:]), decodeMsgFieldOrder36zmkf)
				if encodedFieldsLeft36zmkf > 0 {
					encodedFieldsLeft36zmkf--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						return
					}
					curField36zmkf = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss36zmkf < 0 {
						// tell the reader to only give us Nils
						// until further notice.
						dc.PushAlwaysNil()
						nextMiss36zmkf = 0
					}
					for nextMiss36zmkf < maxFields36zmkf && found36zmkf[nextMiss36zmkf] {
						nextMiss36zmkf++
					}
					if nextMiss36zmkf == maxFields36zmkf {
						// filled all the empty fields!
						break doneWithStruct36zmkf
					}
					missingFieldsLeft36zmkf--
					curField36zmkf = decodeMsgFieldOrder36zmkf[nextMiss36zmkf]
				}
				//fmt.Printf("switching on curField: '%v'\n", curField36zmkf)
				switch curField36zmkf {
				// -- templateDecodeMsg ends here --

				case "value_a":
					found36zmkf[0] = true
					z.Obj.ValueA, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				case "value_b":
					found36zmkf[1] = true
					z.Obj.ValueB, err = dc.ReadBytes(z.Obj.ValueB)
					if err != nil {
						panic(err)
					}
				default:
					err = dc.Skip()
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss36zmkf != -1 {
				dc.PopAlwaysNil()
			}

		case "child":
			found35zsvo[3] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Child != nil {
					dc.PushAlwaysNil()
					err = z.Child.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Child == nil {
					z.Child = new(TestType)
				}
				err = z.Child.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "time":
			found35zsvo[4] = true
			z.Time, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "any":
			found35zsvo[5] = true
			z.Any, err = dc.ReadIntf()
			if err != nil {
				panic(err)
			}
		case "appended":
			found35zsvo[6] = true
			err = z.Appended.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "num":
			found35zsvo[7] = true
			err = z.Num.DecodeMsg(dc)
			if err != nil {
				panic(err)
			}
		case "Slice1":
			found35zsvo[8] = true
			var zjxv uint32
			zjxv, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Slice1) >= int(zjxv) {
				z.Slice1 = (z.Slice1)[:zjxv]
			} else {
				z.Slice1 = make([]string, zjxv)
			}
			for zccq := range z.Slice1 {
				z.Slice1[zccq], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "Slice2":
			found35zsvo[9] = true
			var zewb uint32
			zewb, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Slice2) >= int(zewb) {
				z.Slice2 = (z.Slice2)[:zewb]
			} else {
				z.Slice2 = make([]string, zewb)
			}
			for zrkq := range z.Slice2 {
				z.Slice2[zrkq], err = dc.ReadString()
				if err != nil {
					panic(err)
				}
			}
		case "SlicePtr":
			found35zsvo[10] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				z.SlicePtr = nil
			} else {
				if z.SlicePtr == nil {
					z.SlicePtr = new([]string)
				}
				var zcru uint32
				zcru, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if cap(*z.SlicePtr) >= int(zcru) {
					*z.SlicePtr = (*z.SlicePtr)[:zcru]
				} else {
					*z.SlicePtr = make([]string, zcru)
				}
				for zptj := range *z.SlicePtr {
					(*z.SlicePtr)[zptj], err = dc.ReadString()
					if err != nil {
						panic(err)
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss35zsvo != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TestType
var decodeMsgFieldOrder35zsvo = []string{"float", "elements", "object", "child", "time", "any", "appended", "num", "Slice1", "Slice2", "SlicePtr"}

// fields of struct{;ValueA string;;ValueB []byte;;}
var decodeMsgFieldOrder36zmkf = []string{"value_a", "value_b"}

// fieldsNotEmpty supports omitempty tags
func (z *TestType) fieldsNotEmpty(isempty []bool) uint32 {
	return 11
}

// EncodeMsg implements msgp.Encodable
func (z *TestType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "float"
	err = en.Append(0x8b, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74)
	if err != nil {
		return err
	}
	if z.F == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteFloat64(*z.F)
		if err != nil {
			panic(err)
		}
	}
	// write "elements"
	err = en.Append(0xa8, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteMapHeader(uint32(len(z.Els)))
	if err != nil {
		panic(err)
	}
	for zwoz, zvqe := range z.Els {
		err = en.WriteString(zwoz)
		if err != nil {
			panic(err)
		}
		err = en.WriteString(zvqe)
		if err != nil {
			panic(err)
		}
	}
	// write "object"
	// map header, size 2
	// write "value_a"
	err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x82, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x61)
	if err != nil {
		return err
	}
	err = en.WriteString(z.Obj.ValueA)
	if err != nil {
		panic(err)
	}
	// write "value_b"
	err = en.Append(0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Obj.ValueB)
	if err != nil {
		panic(err)
	}
	// write "child"
	err = en.Append(0xa5, 0x63, 0x68, 0x69, 0x6c, 0x64)
	if err != nil {
		return err
	}
	if z.Child == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Child.EncodeMsg(en)
		if err != nil {
			panic(err)
		}
	}
	// write "time"
	err = en.Append(0xa4, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteTime(z.Time)
	if err != nil {
		panic(err)
	}
	// write "any"
	err = en.Append(0xa3, 0x61, 0x6e, 0x79)
	if err != nil {
		return err
	}
	err = en.WriteIntf(z.Any)
	if err != nil {
		panic(err)
	}
	// write "appended"
	err = en.Append(0xa8, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x65, 0x64)
	if err != nil {
		return err
	}
	err = z.Appended.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	// write "num"
	err = en.Append(0xa3, 0x6e, 0x75, 0x6d)
	if err != nil {
		return err
	}
	err = z.Num.EncodeMsg(en)
	if err != nil {
		panic(err)
	}
	// write "Slice1"
	err = en.Append(0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x31)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice1)))
	if err != nil {
		panic(err)
	}
	for zccq := range z.Slice1 {
		err = en.WriteString(z.Slice1[zccq])
		if err != nil {
			panic(err)
		}
	}
	// write "Slice2"
	err = en.Append(0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x32)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Slice2)))
	if err != nil {
		panic(err)
	}
	for zrkq := range z.Slice2 {
		err = en.WriteString(z.Slice2[zrkq])
		if err != nil {
			panic(err)
		}
	}
	// write "SlicePtr"
	err = en.Append(0xa8, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x74, 0x72)
	if err != nil {
		return err
	}
	if z.SlicePtr == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteArrayHeader(uint32(len(*z.SlicePtr)))
		if err != nil {
			panic(err)
		}
		for zptj := range *z.SlicePtr {
			err = en.WriteString((*z.SlicePtr)[zptj])
			if err != nil {
				panic(err)
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TestType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "float"
	o = append(o, 0x8b, 0xa5, 0x66, 0x6c, 0x6f, 0x61, 0x74)
	if z.F == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendFloat64(o, *z.F)
	}
	// string "elements"
	o = append(o, 0xa8, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Els)))
	for zwoz, zvqe := range z.Els {
		o = msgp.AppendString(o, zwoz)
		o = msgp.AppendString(o, zvqe)
	}
	// string "object"
	// map header, size 2
	// string "value_a"
	o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x82, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x61)
	o = msgp.AppendString(o, z.Obj.ValueA)
	// string "value_b"
	o = append(o, 0xa7, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62)
	o = msgp.AppendBytes(o, z.Obj.ValueB)
	// string "child"
	o = append(o, 0xa5, 0x63, 0x68, 0x69, 0x6c, 0x64)
	if z.Child == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Child.MarshalMsg(o)
		if err != nil {
			panic(err)
		}
	}
	// string "time"
	o = append(o, 0xa4, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Time)
	// string "any"
	o = append(o, 0xa3, 0x61, 0x6e, 0x79)
	o, err = msgp.AppendIntf(o, z.Any)
	if err != nil {
		panic(err)
	}
	// string "appended"
	o = append(o, 0xa8, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x65, 0x64)
	o, err = z.Appended.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	// string "num"
	o = append(o, 0xa3, 0x6e, 0x75, 0x6d)
	o, err = z.Num.MarshalMsg(o)
	if err != nil {
		panic(err)
	}
	// string "Slice1"
	o = append(o, 0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice1)))
	for zccq := range z.Slice1 {
		o = msgp.AppendString(o, z.Slice1[zccq])
	}
	// string "Slice2"
	o = append(o, 0xa6, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Slice2)))
	for zrkq := range z.Slice2 {
		o = msgp.AppendString(o, z.Slice2[zrkq])
	}
	// string "SlicePtr"
	o = append(o, 0xa8, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x50, 0x74, 0x72)
	if z.SlicePtr == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(*z.SlicePtr)))
		for zptj := range *z.SlicePtr {
			o = msgp.AppendString(o, (*z.SlicePtr)[zptj])
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TestType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields37zozu = 11

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields37zozu uint32
	if !nbs.AlwaysNil {
		totalEncodedFields37zozu, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft37zozu := totalEncodedFields37zozu
	missingFieldsLeft37zozu := maxFields37zozu - totalEncodedFields37zozu

	var nextMiss37zozu int32 = -1
	var found37zozu [maxFields37zozu]bool
	var curField37zozu string

doneWithStruct37zozu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft37zozu > 0 || missingFieldsLeft37zozu > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft37zozu, missingFieldsLeft37zozu, msgp.ShowFound(found37zozu[:]), unmarshalMsgFieldOrder37zozu)
		if encodedFieldsLeft37zozu > 0 {
			encodedFieldsLeft37zozu--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField37zozu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss37zozu < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss37zozu = 0
			}
			for nextMiss37zozu < maxFields37zozu && found37zozu[nextMiss37zozu] {
				nextMiss37zozu++
			}
			if nextMiss37zozu == maxFields37zozu {
				// filled all the empty fields!
				break doneWithStruct37zozu
			}
			missingFieldsLeft37zozu--
			curField37zozu = unmarshalMsgFieldOrder37zozu[nextMiss37zozu]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField37zozu)
		switch curField37zozu {
		// -- templateUnmarshalMsg ends here --

		case "float":
			found37zozu[0] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.F == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.F == nil {
					z.F = new(float64)
				}
				*z.F, bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "elements":
			found37zozu[1] = true
			if nbs.AlwaysNil {
				if len(z.Els) > 0 {
					for key, _ := range z.Els {
						delete(z.Els, key)
					}
				}

			} else {

				var zzcf uint32
				zzcf, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.Els == nil && zzcf > 0 {
					z.Els = make(map[string]string, zzcf)
				} else if len(z.Els) > 0 {
					for key, _ := range z.Els {
						delete(z.Els, key)
					}
				}
				for zzcf > 0 {
					var zwoz string
					var zvqe string
					zzcf--
					zwoz, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zvqe, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.Els[zwoz] = zvqe
				}
			}
		case "object":
			found37zozu[2] = true
			const maxFields38zjhq = 2

			// -- templateUnmarshalMsg starts here--
			var totalEncodedFields38zjhq uint32
			if !nbs.AlwaysNil {
				totalEncodedFields38zjhq, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
					return
				}
			}
			encodedFieldsLeft38zjhq := totalEncodedFields38zjhq
			missingFieldsLeft38zjhq := maxFields38zjhq - totalEncodedFields38zjhq

			var nextMiss38zjhq int32 = -1
			var found38zjhq [maxFields38zjhq]bool
			var curField38zjhq string

		doneWithStruct38zjhq:
			// First fill all the encoded fields, then
			// treat the remaining, missing fields, as Nil.
			for encodedFieldsLeft38zjhq > 0 || missingFieldsLeft38zjhq > 0 {
				//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft38zjhq, missingFieldsLeft38zjhq, msgp.ShowFound(found38zjhq[:]), unmarshalMsgFieldOrder38zjhq)
				if encodedFieldsLeft38zjhq > 0 {
					encodedFieldsLeft38zjhq--
					field, bts, err = nbs.ReadMapKeyZC(bts)
					if err != nil {
						panic(err)
						return
					}
					curField38zjhq = msgp.UnsafeString(field)
				} else {
					//missing fields need handling
					if nextMiss38zjhq < 0 {
						// set bts to contain just mnil (0xc0)
						bts = nbs.PushAlwaysNil(bts)
						nextMiss38zjhq = 0
					}
					for nextMiss38zjhq < maxFields38zjhq && found38zjhq[nextMiss38zjhq] {
						nextMiss38zjhq++
					}
					if nextMiss38zjhq == maxFields38zjhq {
						// filled all the empty fields!
						break doneWithStruct38zjhq
					}
					missingFieldsLeft38zjhq--
					curField38zjhq = unmarshalMsgFieldOrder38zjhq[nextMiss38zjhq]
				}
				//fmt.Printf("switching on curField: '%v'\n", curField38zjhq)
				switch curField38zjhq {
				// -- templateUnmarshalMsg ends here --

				case "value_a":
					found38zjhq[0] = true
					z.Obj.ValueA, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				case "value_b":
					found38zjhq[1] = true
					if nbs.AlwaysNil || msgp.IsNil(bts) {
						if !nbs.AlwaysNil {
							bts = bts[1:]
						}
						z.Obj.ValueB = z.Obj.ValueB[:0]
					} else {
						z.Obj.ValueB, bts, err = nbs.ReadBytesBytes(bts, z.Obj.ValueB)

						if err != nil {
							panic(err)
						}
					}
					if err != nil {
						panic(err)
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						panic(err)
					}
				}
			}
			if nextMiss38zjhq != -1 {
				bts = nbs.PopAlwaysNil()
			}

		case "child":
			found37zozu[3] = true
			if nbs.AlwaysNil {
				if z.Child != nil {
					z.Child.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Child {
						z.Child.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Child == nil {
						z.Child = new(TestType)
					}
					bts, err = z.Child.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "time":
			found37zozu[4] = true
			z.Time, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "any":
			found37zozu[5] = true
			z.Any, bts, err = nbs.ReadIntfBytes(bts)

			if err != nil {
				panic(err)
			}
		case "appended":
			found37zozu[6] = true
			bts, err = z.Appended.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "num":
			found37zozu[7] = true
			bts, err = z.Num.UnmarshalMsg(bts)
			if err != nil {
				panic(err)
			}
			if err != nil {
				panic(err)
			}
		case "Slice1":
			found37zozu[8] = true
			if nbs.AlwaysNil {
				(z.Slice1) = (z.Slice1)[:0]
			} else {

				var zbjf uint32
				zbjf, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Slice1) >= int(zbjf) {
					z.Slice1 = (z.Slice1)[:zbjf]
				} else {
					z.Slice1 = make([]string, zbjf)
				}
				for zccq := range z.Slice1 {
					z.Slice1[zccq], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "Slice2":
			found37zozu[9] = true
			if nbs.AlwaysNil {
				(z.Slice2) = (z.Slice2)[:0]
			} else {

				var zyso uint32
				zyso, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Slice2) >= int(zyso) {
					z.Slice2 = (z.Slice2)[:zyso]
				} else {
					z.Slice2 = make([]string, zyso)
				}
				for zrkq := range z.Slice2 {
					z.Slice2[zrkq], bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "SlicePtr":
			found37zozu[10] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.SlicePtr == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.SlicePtr == nil {
					z.SlicePtr = new([]string)
				}
				if nbs.AlwaysNil {
					(*z.SlicePtr) = (*z.SlicePtr)[:0]
				} else {

					var zszc uint32
					zszc, bts, err = nbs.ReadArrayHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if cap(*z.SlicePtr) >= int(zszc) {
						*z.SlicePtr = (*z.SlicePtr)[:zszc]
					} else {
						*z.SlicePtr = make([]string, zszc)
					}
					for zptj := range *z.SlicePtr {
						(*z.SlicePtr)[zptj], bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss37zozu != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TestType
var unmarshalMsgFieldOrder37zozu = []string{"float", "elements", "object", "child", "time", "any", "appended", "num", "Slice1", "Slice2", "SlicePtr"}

// fields of struct{;ValueA string;;ValueB []byte;;}
var unmarshalMsgFieldOrder38zjhq = []string{"value_a", "value_b"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TestType) Msgsize() (s int) {
	s = 1 + 6
	if z.F == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 9 + msgp.MapHeaderSize
	if z.Els != nil {
		for zwoz, zvqe := range z.Els {
			_ = zvqe
			s += msgp.StringPrefixSize + len(zwoz) + msgp.StringPrefixSize + len(zvqe)
		}
	}
	s += 7 + 1 + 8 + msgp.StringPrefixSize + len(z.Obj.ValueA) + 8 + msgp.BytesPrefixSize + len(z.Obj.ValueB) + 6
	if z.Child == nil {
		s += msgp.NilSize
	} else {
		s += z.Child.Msgsize()
	}
	s += 5 + msgp.TimeSize + 4 + msgp.GuessSize(z.Any) + 9 + z.Appended.Msgsize() + 4 + z.Num.Msgsize() + 7 + msgp.ArrayHeaderSize
	for zccq := range z.Slice1 {
		s += msgp.StringPrefixSize + len(z.Slice1[zccq])
	}
	s += 7 + msgp.ArrayHeaderSize
	for zrkq := range z.Slice2 {
		s += msgp.StringPrefixSize + len(z.Slice2[zrkq])
	}
	s += 9
	if z.SlicePtr == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ArrayHeaderSize
		for zptj := range *z.SlicePtr {
			s += msgp.StringPrefixSize + len((*z.SlicePtr)[zptj])
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Things) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields39zfjj = 6

	// -- templateDecodeMsg starts here--
	var totalEncodedFields39zfjj uint32
	totalEncodedFields39zfjj, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft39zfjj := totalEncodedFields39zfjj
	missingFieldsLeft39zfjj := maxFields39zfjj - totalEncodedFields39zfjj

	var nextMiss39zfjj int32 = -1
	var found39zfjj [maxFields39zfjj]bool
	var curField39zfjj string

doneWithStruct39zfjj:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft39zfjj > 0 || missingFieldsLeft39zfjj > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft39zfjj, missingFieldsLeft39zfjj, msgp.ShowFound(found39zfjj[:]), decodeMsgFieldOrder39zfjj)
		if encodedFieldsLeft39zfjj > 0 {
			encodedFieldsLeft39zfjj--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField39zfjj = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss39zfjj < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss39zfjj = 0
			}
			for nextMiss39zfjj < maxFields39zfjj && found39zfjj[nextMiss39zfjj] {
				nextMiss39zfjj++
			}
			if nextMiss39zfjj == maxFields39zfjj {
				// filled all the empty fields!
				break doneWithStruct39zfjj
			}
			missingFieldsLeft39zfjj--
			curField39zfjj = decodeMsgFieldOrder39zfjj[nextMiss39zfjj]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField39zfjj)
		switch curField39zfjj {
		// -- templateDecodeMsg ends here --

		case "complex":
			found39zfjj[0] = true
			z.Cmplx, err = dc.ReadComplex64()
			if err != nil {
				panic(err)
			}
		case "values":
			found39zfjj[1] = true
			var zjry uint32
			zjry, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Vals) >= int(zjry) {
				z.Vals = (z.Vals)[:zjry]
			} else {
				z.Vals = make([]int32, zjry)
			}
			for zdmu := range z.Vals {
				z.Vals[zdmu], err = dc.ReadInt32()
				if err != nil {
					panic(err)
				}
			}
		case "arr":
			found39zfjj[2] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zmjo uint32
				zmjo, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zmjo != msgp.ExtensionPrefixSize {
					err = msgp.ArrayError{Wanted: msgp.ExtensionPrefixSize, Got: zmjo}
					return
				}
			}
			for zduz := range z.Arr {
				z.Arr[zduz], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "arr2":
			found39zfjj[3] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zvdz uint32
				zvdz, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zvdz != 4 {
					err = msgp.ArrayError{Wanted: 4, Got: zvdz}
					return
				}
			}
			for zlte := range z.Arr2 {
				z.Arr2[zlte], err = dc.ReadFloat64()
				if err != nil {
					panic(err)
				}
			}
		case "ext":
			found39zfjj[4] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				// we have an base.Value of Ext: replace the Ext iff already allocated
				if z.Ext != nil {
					z.Ext = new(msgp.RawExtension)
				}
			} else {
				// we have bytes in dc to read

				if z.Ext == nil {
					z.Ext = new(msgp.RawExtension)
				}
				if !dc.IsNil() {
					err = dc.ReadExtension(z.Ext)
				} else {
					err = dc.ReadNil()
				}

				if err != nil {
					panic(err)
				}
			}
		case "oext":
			found39zfjj[5] = true
			if !dc.IsNil() {
				err = dc.ReadExtension(&z.Oext)
			} else {
				err = dc.ReadNil()
			}

			if err != nil {
				panic(err)
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss39zfjj != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of Things
var decodeMsgFieldOrder39zfjj = []string{"complex", "values", "arr", "arr2", "ext", "oext"}

// fieldsNotEmpty supports omitempty tags
func (z *Things) fieldsNotEmpty(isempty []bool) uint32 {
	return 6
}

// EncodeMsg implements msgp.Encodable
func (z *Things) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "complex"
	err = en.Append(0x86, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78)
	if err != nil {
		return err
	}
	err = en.WriteComplex64(z.Cmplx)
	if err != nil {
		panic(err)
	}
	// write "values"
	err = en.Append(0xa6, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Vals)))
	if err != nil {
		panic(err)
	}
	for zdmu := range z.Vals {
		err = en.WriteInt32(z.Vals[zdmu])
		if err != nil {
			panic(err)
		}
	}
	// write "arr"
	err = en.Append(0xa3, 0x61, 0x72, 0x72)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(msgp.ExtensionPrefixSize)
	if err != nil {
		panic(err)
	}
	for zduz := range z.Arr {
		err = en.WriteFloat64(z.Arr[zduz])
		if err != nil {
			panic(err)
		}
	}
	// write "arr2"
	err = en.Append(0xa4, 0x61, 0x72, 0x72, 0x32)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(4)
	if err != nil {
		panic(err)
	}
	for zlte := range z.Arr2 {
		err = en.WriteFloat64(z.Arr2[zlte])
		if err != nil {
			panic(err)
		}
	}
	// write "ext"
	err = en.Append(0xa3, 0x65, 0x78, 0x74)
	if err != nil {
		return err
	}
	if z.Ext == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteExtension(z.Ext)
		if err != nil {
			panic(err)
		}
	}
	// write "oext"
	err = en.Append(0xa4, 0x6f, 0x65, 0x78, 0x74)
	if err != nil {
		return err
	}
	err = en.WriteExtension(&z.Oext)
	if err != nil {
		panic(err)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Things) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "complex"
	o = append(o, 0x86, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78)
	o = msgp.AppendComplex64(o, z.Cmplx)
	// string "values"
	o = append(o, 0xa6, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Vals)))
	for zdmu := range z.Vals {
		o = msgp.AppendInt32(o, z.Vals[zdmu])
	}
	// string "arr"
	o = append(o, 0xa3, 0x61, 0x72, 0x72)
	o = msgp.AppendArrayHeader(o, msgp.ExtensionPrefixSize)
	for zduz := range z.Arr {
		o = msgp.AppendFloat64(o, z.Arr[zduz])
	}
	// string "arr2"
	o = append(o, 0xa4, 0x61, 0x72, 0x72, 0x32)
	o = msgp.AppendArrayHeader(o, 4)
	for zlte := range z.Arr2 {
		o = msgp.AppendFloat64(o, z.Arr2[zlte])
	}
	// string "ext"
	o = append(o, 0xa3, 0x65, 0x78, 0x74)
	if z.Ext == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = msgp.AppendExtension(o, z.Ext)
		if err != nil {
			panic(err)
		}
	}
	// string "oext"
	o = append(o, 0xa4, 0x6f, 0x65, 0x78, 0x74)
	o, err = msgp.AppendExtension(o, &z.Oext)
	if err != nil {
		panic(err)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Things) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields40zrzm = 6

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields40zrzm uint32
	if !nbs.AlwaysNil {
		totalEncodedFields40zrzm, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft40zrzm := totalEncodedFields40zrzm
	missingFieldsLeft40zrzm := maxFields40zrzm - totalEncodedFields40zrzm

	var nextMiss40zrzm int32 = -1
	var found40zrzm [maxFields40zrzm]bool
	var curField40zrzm string

doneWithStruct40zrzm:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft40zrzm > 0 || missingFieldsLeft40zrzm > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft40zrzm, missingFieldsLeft40zrzm, msgp.ShowFound(found40zrzm[:]), unmarshalMsgFieldOrder40zrzm)
		if encodedFieldsLeft40zrzm > 0 {
			encodedFieldsLeft40zrzm--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField40zrzm = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss40zrzm < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss40zrzm = 0
			}
			for nextMiss40zrzm < maxFields40zrzm && found40zrzm[nextMiss40zrzm] {
				nextMiss40zrzm++
			}
			if nextMiss40zrzm == maxFields40zrzm {
				// filled all the empty fields!
				break doneWithStruct40zrzm
			}
			missingFieldsLeft40zrzm--
			curField40zrzm = unmarshalMsgFieldOrder40zrzm[nextMiss40zrzm]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField40zrzm)
		switch curField40zrzm {
		// -- templateUnmarshalMsg ends here --

		case "complex":
			found40zrzm[0] = true
			z.Cmplx, bts, err = nbs.ReadComplex64Bytes(bts)

			if err != nil {
				panic(err)
			}
		case "values":
			found40zrzm[1] = true
			if nbs.AlwaysNil {
				(z.Vals) = (z.Vals)[:0]
			} else {

				var ztbb uint32
				ztbb, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Vals) >= int(ztbb) {
					z.Vals = (z.Vals)[:ztbb]
				} else {
					z.Vals = make([]int32, ztbb)
				}
				for zdmu := range z.Vals {
					z.Vals[zdmu], bts, err = nbs.ReadInt32Bytes(bts)

					if err != nil {
						panic(err)
					}
				}
			}
		case "arr":
			found40zrzm[2] = true
			var zcah uint32
			zcah, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zcah != msgp.ExtensionPrefixSize {
				err = msgp.ArrayError{Wanted: msgp.ExtensionPrefixSize, Got: zcah}
				return
			}
			for zduz := range z.Arr {
				z.Arr[zduz], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "arr2":
			found40zrzm[3] = true
			var zhts uint32
			zhts, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zhts != 4 {
				err = msgp.ArrayError{Wanted: 4, Got: zhts}
				return
			}
			for zlte := range z.Arr2 {
				z.Arr2[zlte], bts, err = nbs.ReadFloat64Bytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "ext":
			found40zrzm[4] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				// don't try to re-use extension pointers
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Ext = nil
			} else {
				// we have data

				if z.Ext == nil {
					z.Ext = new(msgp.RawExtension)
				}
				bts, err = nbs.ReadExtensionBytes(bts, z.Ext)

				if err != nil {
					panic(err)
				}
			}
		case "oext":
			found40zrzm[5] = true
			if nbs.AlwaysNil || msgp.IsNil(bts) {
				if !nbs.AlwaysNil {
					bts = bts[1:]
				}
				z.Oext = msgp.RawExtension{}
			} else {
				bts, err = nbs.ReadExtensionBytes(bts, &z.Oext)

				if err != nil {
					panic(err)
				}
			}
			if err != nil {
				panic(err)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss40zrzm != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of Things
var unmarshalMsgFieldOrder40zrzm = []string{"complex", "values", "arr", "arr2", "ext", "oext"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Things) Msgsize() (s int) {
	s = 1 + 8 + msgp.Complex64Size + 7 + msgp.ArrayHeaderSize + (len(z.Vals) * (msgp.Int32Size)) + 4 + msgp.ArrayHeaderSize + (msgp.ExtensionPrefixSize * (msgp.Float64Size)) + 5 + msgp.ArrayHeaderSize + (4 * (msgp.Float64Size)) + 4
	if z.Ext == nil {
		s += msgp.NilSize
	} else {
		s += msgp.ExtensionPrefixSize + z.Ext.Len()
	}
	s += 5 + msgp.ExtensionPrefixSize + z.Oext.Len()
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *TopNester) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields41zkow = 9

	// -- templateDecodeMsg starts here--
	var totalEncodedFields41zkow uint32
	totalEncodedFields41zkow, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft41zkow := totalEncodedFields41zkow
	missingFieldsLeft41zkow := maxFields41zkow - totalEncodedFields41zkow

	var nextMiss41zkow int32 = -1
	var found41zkow [maxFields41zkow]bool
	var curField41zkow string

doneWithStruct41zkow:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft41zkow > 0 || missingFieldsLeft41zkow > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft41zkow, missingFieldsLeft41zkow, msgp.ShowFound(found41zkow[:]), decodeMsgFieldOrder41zkow)
		if encodedFieldsLeft41zkow > 0 {
			encodedFieldsLeft41zkow--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField41zkow = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss41zkow < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss41zkow = 0
			}
			for nextMiss41zkow < maxFields41zkow && found41zkow[nextMiss41zkow] {
				nextMiss41zkow++
			}
			if nextMiss41zkow == maxFields41zkow {
				// filled all the empty fields!
				break doneWithStruct41zkow
			}
			missingFieldsLeft41zkow--
			curField41zkow = decodeMsgFieldOrder41zkow[nextMiss41zkow]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField41zkow)
		switch curField41zkow {
		// -- templateDecodeMsg ends here --

		case "TopId":
			found41zkow[0] = true
			z.TopId, err = dc.ReadInt()
			if err != nil {
				panic(err)
			}
		case "Greetings":
			found41zkow[1] = true
			z.Greetings, err = dc.ReadString()
			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found41zkow[2] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

				if z.Bullwinkle != nil {
					dc.PushAlwaysNil()
					err = z.Bullwinkle.DecodeMsg(dc)
					if err != nil {
						return
					}
					dc.PopAlwaysNil()
				}
			} else {
				// not Nil, we have something to read

				if z.Bullwinkle == nil {
					z.Bullwinkle = new(Rocky)
				}
				err = z.Bullwinkle.DecodeMsg(dc)
				if err != nil {
					panic(err)
				}
			}
		case "MyIntArray":
			found41zkow[3] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zixf uint32
				zixf, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zixf != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zixf}
					return
				}
			}
			for zkdr := range z.MyIntArray {
				z.MyIntArray[zkdr], err = dc.ReadInt()
				if err != nil {
					panic(err)
				}
			}
		case "MyByteArray":
			found41zkow[4] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.MyByteArray[:])
			if err != nil {
				panic(err)
			}
		case "MyMap":
			found41zkow[5] = true
			var zdkb uint32
			zdkb, err = dc.ReadMapHeader()
			if err != nil {
				panic(err)
			}
			if z.MyMap == nil && zdkb > 0 {
				z.MyMap = make(map[string]string, zdkb)
			} else if len(z.MyMap) > 0 {
				for key, _ := range z.MyMap {
					delete(z.MyMap, key)
				}
			}
			for zdkb > 0 {
				zdkb--
				var zesr string
				var zdzi string
				zesr, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				zdzi, err = dc.ReadString()
				if err != nil {
					panic(err)
				}
				z.MyMap[zesr] = zdzi
			}
		case "MyArrayMap":
			found41zkow[6] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			} else {

				var zgor uint32
				zgor, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if !dc.IsNil() && zgor != 3 {
					err = msgp.ArrayError{Wanted: 3, Got: zgor}
					return
				}
			}
			for zttk := range z.MyArrayMap {
				var zlzv uint32
				zlzv, err = dc.ReadMapHeader()
				if err != nil {
					panic(err)
				}
				if z.MyArrayMap[zttk] == nil && zlzv > 0 {
					z.MyArrayMap[zttk] = make(map[string]string, zlzv)
				} else if len(z.MyArrayMap[zttk]) > 0 {
					for key, _ := range z.MyArrayMap[zttk] {
						delete(z.MyArrayMap[zttk], key)
					}
				}
				for zlzv > 0 {
					zlzv--
					var zfir string
					var zbap string
					zfir, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
					zbap, err = dc.ReadString()
					if err != nil {
						panic(err)
					}
					z.MyArrayMap[zttk][zfir] = zbap
				}
			}
		case "TopTime":
			found41zkow[7] = true
			z.TopTime, err = dc.ReadTime()
			if err != nil {
				panic(err)
			}
		case "PtrTime":
			found41zkow[8] = true
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}

			} else {

				if z.PtrTime == nil {
					z.PtrTime = new(time.Time)
				}
				*z.PtrTime, err = dc.ReadTime()
				if err != nil {
					panic(err)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss41zkow != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of TopNester
var decodeMsgFieldOrder41zkow = []string{"TopId", "Greetings", "Bullwinkle", "MyIntArray", "MyByteArray", "MyMap", "MyArrayMap", "TopTime", "PtrTime"}

// fieldsNotEmpty supports omitempty tags
func (z *TopNester) fieldsNotEmpty(isempty []bool) uint32 {
	if len(isempty) == 0 {
		return 9
	}
	var fieldsInUse uint32 = 9
	isempty[1] = (len(z.Greetings) == 0) // string, omitempty
	if isempty[1] {
		fieldsInUse--
	}
	isempty[2] = (z.Bullwinkle == nil) // pointer, omitempty
	if isempty[2] {
		fieldsInUse--
	}
	isempty[3] = (len(z.MyIntArray) == 0) // string, omitempty
	if isempty[3] {
		fieldsInUse--
	}
	isempty[4] = (len(z.MyByteArray) == 0) // string, omitempty
	if isempty[4] {
		fieldsInUse--
	}
	isempty[5] = (len(z.MyMap) == 0) // string, omitempty
	if isempty[5] {
		fieldsInUse--
	}
	isempty[6] = (len(z.MyArrayMap) == 0) // string, omitempty
	if isempty[6] {
		fieldsInUse--
	}
	isempty[7] = (z.TopTime.IsZero()) // time.Time, omitempty
	if isempty[7] {
		fieldsInUse--
	}
	isempty[8] = (z.PtrTime == nil) // pointer, omitempty
	if isempty[8] {
		fieldsInUse--
	}

	return fieldsInUse
}

// EncodeMsg implements msgp.Encodable
func (z *TopNester) EncodeMsg(en *msgp.Writer) (err error) {

	// honor the omitempty tags
	var empty_zqjl [9]bool
	fieldsInUse_zwij := z.fieldsNotEmpty(empty_zqjl[:])

	// map header
	err = en.WriteMapHeader(fieldsInUse_zwij)
	if err != nil {
		return err
	}

	// write "TopId"
	err = en.Append(0xa5, 0x54, 0x6f, 0x70, 0x49, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteInt(z.TopId)
	if err != nil {
		panic(err)
	}
	if !empty_zqjl[1] {
		// write "Greetings"
		err = en.Append(0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return err
		}
		err = en.WriteString(z.Greetings)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zqjl[2] {
		// write "Bullwinkle"
		err = en.Append(0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if err != nil {
			return err
		}
		if z.Bullwinkle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullwinkle.EncodeMsg(en)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zqjl[3] {
		// write "MyIntArray"
		err = en.Append(0xaa, 0x4d, 0x79, 0x49, 0x6e, 0x74, 0x41, 0x72, 0x72, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zkdr := range z.MyIntArray {
			err = en.WriteInt(z.MyIntArray[zkdr])
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zqjl[4] {
		// write "MyByteArray"
		err = en.Append(0xab, 0x4d, 0x79, 0x42, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79)
		if err != nil {
			return err
		}
		err = en.WriteBytes(z.MyByteArray[:])
		if err != nil {
			panic(err)
		}
	}

	if !empty_zqjl[5] {
		// write "MyMap"
		err = en.Append(0xa5, 0x4d, 0x79, 0x4d, 0x61, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteMapHeader(uint32(len(z.MyMap)))
		if err != nil {
			panic(err)
		}
		for zesr, zdzi := range z.MyMap {
			err = en.WriteString(zesr)
			if err != nil {
				panic(err)
			}
			err = en.WriteString(zdzi)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty_zqjl[6] {
		// write "MyArrayMap"
		err = en.Append(0xaa, 0x4d, 0x79, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x61, 0x70)
		if err != nil {
			return err
		}
		err = en.WriteArrayHeader(3)
		if err != nil {
			panic(err)
		}
		for zttk := range z.MyArrayMap {
			err = en.WriteMapHeader(uint32(len(z.MyArrayMap[zttk])))
			if err != nil {
				panic(err)
			}
			for zfir, zbap := range z.MyArrayMap[zttk] {
				err = en.WriteString(zfir)
				if err != nil {
					panic(err)
				}
				err = en.WriteString(zbap)
				if err != nil {
					panic(err)
				}
			}
		}
	}

	if !empty_zqjl[7] {
		// write "TopTime"
		err = en.Append(0xa7, 0x54, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return err
		}
		err = en.WriteTime(z.TopTime)
		if err != nil {
			panic(err)
		}
	}

	if !empty_zqjl[8] {
		// write "PtrTime"
		err = en.Append(0xa7, 0x50, 0x74, 0x72, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return err
		}
		if z.PtrTime == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteTime(*z.PtrTime)
			if err != nil {
				panic(err)
			}
		}
	}

	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TopNester) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())

	// honor the omitempty tags
	var empty [9]bool
	fieldsInUse := z.fieldsNotEmpty(empty[:])
	o = msgp.AppendMapHeader(o, fieldsInUse)

	// string "TopId"
	o = append(o, 0xa5, 0x54, 0x6f, 0x70, 0x49, 0x64)
	o = msgp.AppendInt(o, z.TopId)
	if !empty[1] {
		// string "Greetings"
		o = append(o, 0xa9, 0x47, 0x72, 0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o = msgp.AppendString(o, z.Greetings)
	}

	if !empty[2] {
		// string "Bullwinkle"
		o = append(o, 0xaa, 0x42, 0x75, 0x6c, 0x6c, 0x77, 0x69, 0x6e, 0x6b, 0x6c, 0x65)
		if z.Bullwinkle == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullwinkle.MarshalMsg(o)
			if err != nil {
				panic(err)
			}
		}
	}

	if !empty[3] {
		// string "MyIntArray"
		o = append(o, 0xaa, 0x4d, 0x79, 0x49, 0x6e, 0x74, 0x41, 0x72, 0x72, 0x61, 0x79)
		o = msgp.AppendArrayHeader(o, 3)
		for zkdr := range z.MyIntArray {
			o = msgp.AppendInt(o, z.MyIntArray[zkdr])
		}
	}

	if !empty[4] {
		// string "MyByteArray"
		o = append(o, 0xab, 0x4d, 0x79, 0x42, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79)
		o = msgp.AppendBytes(o, z.MyByteArray[:])
	}

	if !empty[5] {
		// string "MyMap"
		o = append(o, 0xa5, 0x4d, 0x79, 0x4d, 0x61, 0x70)
		o = msgp.AppendMapHeader(o, uint32(len(z.MyMap)))
		for zesr, zdzi := range z.MyMap {
			o = msgp.AppendString(o, zesr)
			o = msgp.AppendString(o, zdzi)
		}
	}

	if !empty[6] {
		// string "MyArrayMap"
		o = append(o, 0xaa, 0x4d, 0x79, 0x41, 0x72, 0x72, 0x61, 0x79, 0x4d, 0x61, 0x70)
		o = msgp.AppendArrayHeader(o, 3)
		for zttk := range z.MyArrayMap {
			o = msgp.AppendMapHeader(o, uint32(len(z.MyArrayMap[zttk])))
			for zfir, zbap := range z.MyArrayMap[zttk] {
				o = msgp.AppendString(o, zfir)
				o = msgp.AppendString(o, zbap)
			}
		}
	}

	if !empty[7] {
		// string "TopTime"
		o = append(o, 0xa7, 0x54, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.TopTime)
	}

	if !empty[8] {
		// string "PtrTime"
		o = append(o, 0xa7, 0x50, 0x74, 0x72, 0x54, 0x69, 0x6d, 0x65)
		if z.PtrTime == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendTime(o, *z.PtrTime)
		}
	}

	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TopNester) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields42zucu = 9

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields42zucu uint32
	if !nbs.AlwaysNil {
		totalEncodedFields42zucu, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft42zucu := totalEncodedFields42zucu
	missingFieldsLeft42zucu := maxFields42zucu - totalEncodedFields42zucu

	var nextMiss42zucu int32 = -1
	var found42zucu [maxFields42zucu]bool
	var curField42zucu string

doneWithStruct42zucu:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft42zucu > 0 || missingFieldsLeft42zucu > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft42zucu, missingFieldsLeft42zucu, msgp.ShowFound(found42zucu[:]), unmarshalMsgFieldOrder42zucu)
		if encodedFieldsLeft42zucu > 0 {
			encodedFieldsLeft42zucu--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField42zucu = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss42zucu < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss42zucu = 0
			}
			for nextMiss42zucu < maxFields42zucu && found42zucu[nextMiss42zucu] {
				nextMiss42zucu++
			}
			if nextMiss42zucu == maxFields42zucu {
				// filled all the empty fields!
				break doneWithStruct42zucu
			}
			missingFieldsLeft42zucu--
			curField42zucu = unmarshalMsgFieldOrder42zucu[nextMiss42zucu]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField42zucu)
		switch curField42zucu {
		// -- templateUnmarshalMsg ends here --

		case "TopId":
			found42zucu[0] = true
			z.TopId, bts, err = nbs.ReadIntBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Greetings":
			found42zucu[1] = true
			z.Greetings, bts, err = nbs.ReadStringBytes(bts)

			if err != nil {
				panic(err)
			}
		case "Bullwinkle":
			found42zucu[2] = true
			if nbs.AlwaysNil {
				if z.Bullwinkle != nil {
					z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
				}
			} else {
				// not nbs.AlwaysNil
				if msgp.IsNil(bts) {
					bts = bts[1:]
					if nil != z.Bullwinkle {
						z.Bullwinkle.UnmarshalMsg(msgp.OnlyNilSlice)
					}
				} else {
					// not nbs.AlwaysNil and not IsNil(bts): have something to read

					if z.Bullwinkle == nil {
						z.Bullwinkle = new(Rocky)
					}
					bts, err = z.Bullwinkle.UnmarshalMsg(bts)
					if err != nil {
						panic(err)
					}
					if err != nil {
						panic(err)
					}
				}
			}
		case "MyIntArray":
			found42zucu[3] = true
			var zgua uint32
			zgua, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zgua != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zgua}
				return
			}
			for zkdr := range z.MyIntArray {
				z.MyIntArray[zkdr], bts, err = nbs.ReadIntBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		case "MyByteArray":
			found42zucu[4] = true
			bts, err = nbs.ReadExactBytes(bts, z.MyByteArray[:])
			if err != nil {
				panic(err)
			}
		case "MyMap":
			found42zucu[5] = true
			if nbs.AlwaysNil {
				if len(z.MyMap) > 0 {
					for key, _ := range z.MyMap {
						delete(z.MyMap, key)
					}
				}

			} else {

				var zqjq uint32
				zqjq, bts, err = nbs.ReadMapHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if z.MyMap == nil && zqjq > 0 {
					z.MyMap = make(map[string]string, zqjq)
				} else if len(z.MyMap) > 0 {
					for key, _ := range z.MyMap {
						delete(z.MyMap, key)
					}
				}
				for zqjq > 0 {
					var zesr string
					var zdzi string
					zqjq--
					zesr, bts, err = nbs.ReadStringBytes(bts)
					if err != nil {
						panic(err)
					}
					zdzi, bts, err = nbs.ReadStringBytes(bts)

					if err != nil {
						panic(err)
					}
					z.MyMap[zesr] = zdzi
				}
			}
		case "MyArrayMap":
			found42zucu[6] = true
			var zutx uint32
			zutx, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				panic(err)
			}
			if !nbs.IsNil(bts) && zutx != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zutx}
				return
			}
			for zttk := range z.MyArrayMap {
				if nbs.AlwaysNil {
					if len(z.MyArrayMap[zttk]) > 0 {
						for key, _ := range z.MyArrayMap[zttk] {
							delete(z.MyArrayMap[zttk], key)
						}
					}

				} else {

					var zyrj uint32
					zyrj, bts, err = nbs.ReadMapHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if z.MyArrayMap[zttk] == nil && zyrj > 0 {
						z.MyArrayMap[zttk] = make(map[string]string, zyrj)
					} else if len(z.MyArrayMap[zttk]) > 0 {
						for key, _ := range z.MyArrayMap[zttk] {
							delete(z.MyArrayMap[zttk], key)
						}
					}
					for zyrj > 0 {
						var zfir string
						var zbap string
						zyrj--
						zfir, bts, err = nbs.ReadStringBytes(bts)
						if err != nil {
							panic(err)
						}
						zbap, bts, err = nbs.ReadStringBytes(bts)

						if err != nil {
							panic(err)
						}
						z.MyArrayMap[zttk][zfir] = zbap
					}
				}
			}
		case "TopTime":
			found42zucu[7] = true
			z.TopTime, bts, err = nbs.ReadTimeBytes(bts)

			if err != nil {
				panic(err)
			}
		case "PtrTime":
			found42zucu[8] = true
			// default gPtr logic.
			if nbs.PeekNil(bts) && z.PtrTime == nil {
				// consume the nil
				bts, err = nbs.ReadNilBytes(bts)
				if err != nil {
					return
				}
			} else {
				// read as-if the wire has bytes, letting nbs take care of nils.

				if z.PtrTime == nil {
					z.PtrTime = new(time.Time)
				}
				*z.PtrTime, bts, err = nbs.ReadTimeBytes(bts)

				if err != nil {
					panic(err)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss42zucu != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of TopNester
var unmarshalMsgFieldOrder42zucu = []string{"TopId", "Greetings", "Bullwinkle", "MyIntArray", "MyByteArray", "MyMap", "MyArrayMap", "TopTime", "PtrTime"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TopNester) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 10 + msgp.StringPrefixSize + len(z.Greetings) + 11
	if z.Bullwinkle == nil {
		s += msgp.NilSize
	} else {
		s += z.Bullwinkle.Msgsize()
	}
	s += 11 + msgp.ArrayHeaderSize + (3 * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (3 * (msgp.ByteSize)) + 6 + msgp.MapHeaderSize
	if z.MyMap != nil {
		for zesr, zdzi := range z.MyMap {
			_ = zdzi
			s += msgp.StringPrefixSize + len(zesr) + msgp.StringPrefixSize + len(zdzi)
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zttk := range z.MyArrayMap {
		s += msgp.MapHeaderSize
		if z.MyArrayMap[zttk] != nil {
			for zfir, zbap := range z.MyArrayMap[zttk] {
				_ = zbap
				s += msgp.StringPrefixSize + len(zfir) + msgp.StringPrefixSize + len(zbap)
			}
		}
	}
	s += 8 + msgp.TimeSize + 8
	if z.PtrTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *X) DecodeMsg(dc *msgp.Reader) (err error) {
	var sawTopNil bool
	if dc.IsNil() {
		sawTopNil = true
		err = dc.ReadNil()
		if err != nil {
			return
		}
		dc.PushAlwaysNil()
	}

	var field []byte
	_ = field
	const maxFields43zwhi = 5

	// -- templateDecodeMsg starts here--
	var totalEncodedFields43zwhi uint32
	totalEncodedFields43zwhi, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	encodedFieldsLeft43zwhi := totalEncodedFields43zwhi
	missingFieldsLeft43zwhi := maxFields43zwhi - totalEncodedFields43zwhi

	var nextMiss43zwhi int32 = -1
	var found43zwhi [maxFields43zwhi]bool
	var curField43zwhi string

doneWithStruct43zwhi:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft43zwhi > 0 || missingFieldsLeft43zwhi > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft43zwhi, missingFieldsLeft43zwhi, msgp.ShowFound(found43zwhi[:]), decodeMsgFieldOrder43zwhi)
		if encodedFieldsLeft43zwhi > 0 {
			encodedFieldsLeft43zwhi--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				return
			}
			curField43zwhi = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss43zwhi < 0 {
				// tell the reader to only give us Nils
				// until further notice.
				dc.PushAlwaysNil()
				nextMiss43zwhi = 0
			}
			for nextMiss43zwhi < maxFields43zwhi && found43zwhi[nextMiss43zwhi] {
				nextMiss43zwhi++
			}
			if nextMiss43zwhi == maxFields43zwhi {
				// filled all the empty fields!
				break doneWithStruct43zwhi
			}
			missingFieldsLeft43zwhi--
			curField43zwhi = decodeMsgFieldOrder43zwhi[nextMiss43zwhi]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField43zwhi)
		switch curField43zwhi {
		// -- templateDecodeMsg ends here --

		case "Values":
			found43zwhi[0] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.Values[:])
			if err != nil {
				panic(err)
			}
		case "More":
			found43zwhi[1] = true
			if dc.AlwaysNil {
				// nothing more here
			} else if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					return
				}
			}
			err = dc.ReadExactBytes(z.More[:])
			if err != nil {
				panic(err)
			}
		case "Others":
			found43zwhi[2] = true
			var zrwb uint32
			zrwb, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Others) >= int(zrwb) {
				z.Others = (z.Others)[:zrwb]
			} else {
				z.Others = make([][32]int32, zrwb)
			}
			for zrdc := range z.Others {
				if dc.AlwaysNil {
					// nothing more here
				} else if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						return
					}
				} else {

					var znfx uint32
					znfx, err = dc.ReadArrayHeader()
					if err != nil {
						panic(err)
					}
					if !dc.IsNil() && znfx != 32 {
						err = msgp.ArrayError{Wanted: 32, Got: znfx}
						return
					}
				}
				for zezc := range z.Others[zrdc] {
					z.Others[zrdc][zezc], err = dc.ReadInt32()
					if err != nil {
						panic(err)
					}
				}
			}
		case "Matrix":
			found43zwhi[3] = true
			var zfdh uint32
			zfdh, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.Matrix) >= int(zfdh) {
				z.Matrix = (z.Matrix)[:zfdh]
			} else {
				z.Matrix = make([][]int32, zfdh)
			}
			for zliu := range z.Matrix {
				var zaou uint32
				zaou, err = dc.ReadArrayHeader()
				if err != nil {
					panic(err)
				}
				if cap(z.Matrix[zliu]) >= int(zaou) {
					z.Matrix[zliu] = (z.Matrix[zliu])[:zaou]
				} else {
					z.Matrix[zliu] = make([]int32, zaou)
				}
				for zrup := range z.Matrix[zliu] {
					z.Matrix[zliu][zrup], err = dc.ReadInt32()
					if err != nil {
						panic(err)
					}
				}
			}
		case "ManyFixed":
			found43zwhi[4] = true
			var zzpf uint32
			zzpf, err = dc.ReadArrayHeader()
			if err != nil {
				panic(err)
			}
			if cap(z.ManyFixed) >= int(zzpf) {
				z.ManyFixed = (z.ManyFixed)[:zzpf]
			} else {
				z.ManyFixed = make([]Fixed, zzpf)
			}
			for zund := range z.ManyFixed {
				const maxFields44zaev = 2

				// -- templateDecodeMsg starts here--
				var totalEncodedFields44zaev uint32
				totalEncodedFields44zaev, err = dc.ReadMapHeader()
				if err != nil {
					return
				}
				encodedFieldsLeft44zaev := totalEncodedFields44zaev
				missingFieldsLeft44zaev := maxFields44zaev - totalEncodedFields44zaev

				var nextMiss44zaev int32 = -1
				var found44zaev [maxFields44zaev]bool
				var curField44zaev string

			doneWithStruct44zaev:
				// First fill all the encoded fields, then
				// treat the remaining, missing fields, as Nil.
				for encodedFieldsLeft44zaev > 0 || missingFieldsLeft44zaev > 0 {
					//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft44zaev, missingFieldsLeft44zaev, msgp.ShowFound(found44zaev[:]), decodeMsgFieldOrder44zaev)
					if encodedFieldsLeft44zaev > 0 {
						encodedFieldsLeft44zaev--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							return
						}
						curField44zaev = msgp.UnsafeString(field)
					} else {
						//missing fields need handling
						if nextMiss44zaev < 0 {
							// tell the reader to only give us Nils
							// until further notice.
							dc.PushAlwaysNil()
							nextMiss44zaev = 0
						}
						for nextMiss44zaev < maxFields44zaev && found44zaev[nextMiss44zaev] {
							nextMiss44zaev++
						}
						if nextMiss44zaev == maxFields44zaev {
							// filled all the empty fields!
							break doneWithStruct44zaev
						}
						missingFieldsLeft44zaev--
						curField44zaev = decodeMsgFieldOrder44zaev[nextMiss44zaev]
					}
					//fmt.Printf("switching on curField: '%v'\n", curField44zaev)
					switch curField44zaev {
					// -- templateDecodeMsg ends here --

					case "A":
						found44zaev[0] = true
						z.ManyFixed[zund].A, err = dc.ReadFloat64()
						if err != nil {
							panic(err)
						}
					case "B":
						found44zaev[1] = true
						z.ManyFixed[zund].B, err = dc.ReadBool()
						if err != nil {
							panic(err)
						}
					default:
						err = dc.Skip()
						if err != nil {
							panic(err)
						}
					}
				}
				if nextMiss44zaev != -1 {
					dc.PopAlwaysNil()
				}

			}
		default:
			err = dc.Skip()
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss43zwhi != -1 {
		dc.PopAlwaysNil()
	}

	if sawTopNil {
		dc.PopAlwaysNil()
	}

	return
}

// fields of X
var decodeMsgFieldOrder43zwhi = []string{"Values", "More", "Others", "Matrix", "ManyFixed"}

// fields of Fixed
var decodeMsgFieldOrder44zaev = []string{"A", "B"}

// fieldsNotEmpty supports omitempty tags
func (z *X) fieldsNotEmpty(isempty []bool) uint32 {
	return 5
}

// EncodeMsg implements msgp.Encodable
func (z *X) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "Values"
	err = en.Append(0x85, 0xa6, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.Values[:])
	if err != nil {
		panic(err)
	}
	// write "More"
	err = en.Append(0xa4, 0x4d, 0x6f, 0x72, 0x65)
	if err != nil {
		return err
	}
	err = en.WriteBytes(z.More[:])
	if err != nil {
		panic(err)
	}
	// write "Others"
	err = en.Append(0xa6, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x73)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Others)))
	if err != nil {
		panic(err)
	}
	for zrdc := range z.Others {
		err = en.WriteArrayHeader(32)
		if err != nil {
			panic(err)
		}
		for zezc := range z.Others[zrdc] {
			err = en.WriteInt32(z.Others[zrdc][zezc])
			if err != nil {
				panic(err)
			}
		}
	}
	// write "Matrix"
	err = en.Append(0xa6, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.Matrix)))
	if err != nil {
		panic(err)
	}
	for zliu := range z.Matrix {
		err = en.WriteArrayHeader(uint32(len(z.Matrix[zliu])))
		if err != nil {
			panic(err)
		}
		for zrup := range z.Matrix[zliu] {
			err = en.WriteInt32(z.Matrix[zliu][zrup])
			if err != nil {
				panic(err)
			}
		}
	}
	// write "ManyFixed"
	err = en.Append(0xa9, 0x4d, 0x61, 0x6e, 0x79, 0x46, 0x69, 0x78, 0x65, 0x64)
	if err != nil {
		return err
	}
	err = en.WriteArrayHeader(uint32(len(z.ManyFixed)))
	if err != nil {
		panic(err)
	}
	for zund := range z.ManyFixed {
		// map header, size 2
		// write "A"
		err = en.Append(0x82, 0xa1, 0x41)
		if err != nil {
			return err
		}
		err = en.WriteFloat64(z.ManyFixed[zund].A)
		if err != nil {
			panic(err)
		}
		// write "B"
		err = en.Append(0xa1, 0x42)
		if err != nil {
			return err
		}
		err = en.WriteBool(z.ManyFixed[zund].B)
		if err != nil {
			panic(err)
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *X) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "Values"
	o = append(o, 0x85, 0xa6, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendBytes(o, z.Values[:])
	// string "More"
	o = append(o, 0xa4, 0x4d, 0x6f, 0x72, 0x65)
	o = msgp.AppendBytes(o, z.More[:])
	// string "Others"
	o = append(o, 0xa6, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Others)))
	for zrdc := range z.Others {
		o = msgp.AppendArrayHeader(o, 32)
		for zezc := range z.Others[zrdc] {
			o = msgp.AppendInt32(o, z.Others[zrdc][zezc])
		}
	}
	// string "Matrix"
	o = append(o, 0xa6, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Matrix)))
	for zliu := range z.Matrix {
		o = msgp.AppendArrayHeader(o, uint32(len(z.Matrix[zliu])))
		for zrup := range z.Matrix[zliu] {
			o = msgp.AppendInt32(o, z.Matrix[zliu][zrup])
		}
	}
	// string "ManyFixed"
	o = append(o, 0xa9, 0x4d, 0x61, 0x6e, 0x79, 0x46, 0x69, 0x78, 0x65, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ManyFixed)))
	for zund := range z.ManyFixed {
		// map header, size 2
		// string "A"
		o = append(o, 0x82, 0xa1, 0x41)
		o = msgp.AppendFloat64(o, z.ManyFixed[zund].A)
		// string "B"
		o = append(o, 0xa1, 0x42)
		o = msgp.AppendBool(o, z.ManyFixed[zund].B)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *X) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var field []byte
	_ = field
	const maxFields45zzcq = 5

	// -- templateUnmarshalMsg starts here--
	var totalEncodedFields45zzcq uint32
	if !nbs.AlwaysNil {
		totalEncodedFields45zzcq, bts, err = nbs.ReadMapHeaderBytes(bts)
		if err != nil {
			panic(err)
			return
		}
	}
	encodedFieldsLeft45zzcq := totalEncodedFields45zzcq
	missingFieldsLeft45zzcq := maxFields45zzcq - totalEncodedFields45zzcq

	var nextMiss45zzcq int32 = -1
	var found45zzcq [maxFields45zzcq]bool
	var curField45zzcq string

doneWithStruct45zzcq:
	// First fill all the encoded fields, then
	// treat the remaining, missing fields, as Nil.
	for encodedFieldsLeft45zzcq > 0 || missingFieldsLeft45zzcq > 0 {
		//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft45zzcq, missingFieldsLeft45zzcq, msgp.ShowFound(found45zzcq[:]), unmarshalMsgFieldOrder45zzcq)
		if encodedFieldsLeft45zzcq > 0 {
			encodedFieldsLeft45zzcq--
			field, bts, err = nbs.ReadMapKeyZC(bts)
			if err != nil {
				panic(err)
				return
			}
			curField45zzcq = msgp.UnsafeString(field)
		} else {
			//missing fields need handling
			if nextMiss45zzcq < 0 {
				// set bts to contain just mnil (0xc0)
				bts = nbs.PushAlwaysNil(bts)
				nextMiss45zzcq = 0
			}
			for nextMiss45zzcq < maxFields45zzcq && found45zzcq[nextMiss45zzcq] {
				nextMiss45zzcq++
			}
			if nextMiss45zzcq == maxFields45zzcq {
				// filled all the empty fields!
				break doneWithStruct45zzcq
			}
			missingFieldsLeft45zzcq--
			curField45zzcq = unmarshalMsgFieldOrder45zzcq[nextMiss45zzcq]
		}
		//fmt.Printf("switching on curField: '%v'\n", curField45zzcq)
		switch curField45zzcq {
		// -- templateUnmarshalMsg ends here --

		case "Values":
			found45zzcq[0] = true
			bts, err = nbs.ReadExactBytes(bts, z.Values[:])
			if err != nil {
				panic(err)
			}
		case "More":
			found45zzcq[1] = true
			bts, err = nbs.ReadExactBytes(bts, z.More[:])
			if err != nil {
				panic(err)
			}
		case "Others":
			found45zzcq[2] = true
			if nbs.AlwaysNil {
				(z.Others) = (z.Others)[:0]
			} else {

				var zrnc uint32
				zrnc, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Others) >= int(zrnc) {
					z.Others = (z.Others)[:zrnc]
				} else {
					z.Others = make([][32]int32, zrnc)
				}
				for zrdc := range z.Others {
					var zlbq uint32
					zlbq, bts, err = nbs.ReadArrayHeaderBytes(bts)
					if err != nil {
						panic(err)
					}
					if !nbs.IsNil(bts) && zlbq != 32 {
						err = msgp.ArrayError{Wanted: 32, Got: zlbq}
						return
					}
					for zezc := range z.Others[zrdc] {
						z.Others[zrdc][zezc], bts, err = nbs.ReadInt32Bytes(bts)

						if err != nil {
							panic(err)
						}
					}
				}
			}
		case "Matrix":
			found45zzcq[3] = true
			if nbs.AlwaysNil {
				(z.Matrix) = (z.Matrix)[:0]
			} else {

				var znmc uint32
				znmc, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.Matrix) >= int(znmc) {
					z.Matrix = (z.Matrix)[:znmc]
				} else {
					z.Matrix = make([][]int32, znmc)
				}
				for zliu := range z.Matrix {
					if nbs.AlwaysNil {
						(z.Matrix[zliu]) = (z.Matrix[zliu])[:0]
					} else {

						var zkyl uint32
						zkyl, bts, err = nbs.ReadArrayHeaderBytes(bts)
						if err != nil {
							panic(err)
						}
						if cap(z.Matrix[zliu]) >= int(zkyl) {
							z.Matrix[zliu] = (z.Matrix[zliu])[:zkyl]
						} else {
							z.Matrix[zliu] = make([]int32, zkyl)
						}
						for zrup := range z.Matrix[zliu] {
							z.Matrix[zliu][zrup], bts, err = nbs.ReadInt32Bytes(bts)

							if err != nil {
								panic(err)
							}
						}
					}
				}
			}
		case "ManyFixed":
			found45zzcq[4] = true
			if nbs.AlwaysNil {
				(z.ManyFixed) = (z.ManyFixed)[:0]
			} else {

				var zikw uint32
				zikw, bts, err = nbs.ReadArrayHeaderBytes(bts)
				if err != nil {
					panic(err)
				}
				if cap(z.ManyFixed) >= int(zikw) {
					z.ManyFixed = (z.ManyFixed)[:zikw]
				} else {
					z.ManyFixed = make([]Fixed, zikw)
				}
				for zund := range z.ManyFixed {
					const maxFields46zdis = 2

					// -- templateUnmarshalMsg starts here--
					var totalEncodedFields46zdis uint32
					if !nbs.AlwaysNil {
						totalEncodedFields46zdis, bts, err = nbs.ReadMapHeaderBytes(bts)
						if err != nil {
							panic(err)
							return
						}
					}
					encodedFieldsLeft46zdis := totalEncodedFields46zdis
					missingFieldsLeft46zdis := maxFields46zdis - totalEncodedFields46zdis

					var nextMiss46zdis int32 = -1
					var found46zdis [maxFields46zdis]bool
					var curField46zdis string

				doneWithStruct46zdis:
					// First fill all the encoded fields, then
					// treat the remaining, missing fields, as Nil.
					for encodedFieldsLeft46zdis > 0 || missingFieldsLeft46zdis > 0 {
						//fmt.Printf("encodedFieldsLeft: %v, missingFieldsLeft: %v, found: '%v', fields: '%#v'\n", encodedFieldsLeft46zdis, missingFieldsLeft46zdis, msgp.ShowFound(found46zdis[:]), unmarshalMsgFieldOrder46zdis)
						if encodedFieldsLeft46zdis > 0 {
							encodedFieldsLeft46zdis--
							field, bts, err = nbs.ReadMapKeyZC(bts)
							if err != nil {
								panic(err)
								return
							}
							curField46zdis = msgp.UnsafeString(field)
						} else {
							//missing fields need handling
							if nextMiss46zdis < 0 {
								// set bts to contain just mnil (0xc0)
								bts = nbs.PushAlwaysNil(bts)
								nextMiss46zdis = 0
							}
							for nextMiss46zdis < maxFields46zdis && found46zdis[nextMiss46zdis] {
								nextMiss46zdis++
							}
							if nextMiss46zdis == maxFields46zdis {
								// filled all the empty fields!
								break doneWithStruct46zdis
							}
							missingFieldsLeft46zdis--
							curField46zdis = unmarshalMsgFieldOrder46zdis[nextMiss46zdis]
						}
						//fmt.Printf("switching on curField: '%v'\n", curField46zdis)
						switch curField46zdis {
						// -- templateUnmarshalMsg ends here --

						case "A":
							found46zdis[0] = true
							z.ManyFixed[zund].A, bts, err = nbs.ReadFloat64Bytes(bts)

							if err != nil {
								panic(err)
							}
						case "B":
							found46zdis[1] = true
							z.ManyFixed[zund].B, bts, err = nbs.ReadBoolBytes(bts)

							if err != nil {
								panic(err)
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								panic(err)
							}
						}
					}
					if nextMiss46zdis != -1 {
						bts = nbs.PopAlwaysNil()
					}

				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
		}
	}
	if nextMiss45zzcq != -1 {
		bts = nbs.PopAlwaysNil()
	}

	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	return
}

// fields of X
var unmarshalMsgFieldOrder45zzcq = []string{"Values", "More", "Others", "Matrix", "ManyFixed"}

// fields of Fixed
var unmarshalMsgFieldOrder46zdis = []string{"A", "B"}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *X) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 5 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 7 + msgp.ArrayHeaderSize + (len(z.Others) * (32 * (msgp.Int32Size))) + 7 + msgp.ArrayHeaderSize
	for zliu := range z.Matrix {
		s += msgp.ArrayHeaderSize + (len(z.Matrix[zliu]) * (msgp.Int32Size))
	}
	s += 10 + msgp.ArrayHeaderSize + (len(z.ManyFixed) * (5 + msgp.Float64Size + msgp.BoolSize))
	return
}
